Download at WoweBook.Com

Praise for Head First Design Patterns
“I received the book yesterday and started to read it on the way home... and I couldn’t stop. I took it to the
gym and I expect people saw me smiling a lot while I was exercising and reading. This is tres ‘cool’. It is
fun but they cover a lot of ground and they are right to the point. I’m really impressed.”
— Erich Gamma, IBM Distinguished Engineer,
and co-author of Design Patterns
“‘Head First Design Patterns’ manages to mix fun, belly-laughs, insight, technical depth and great practical
advice in one entertaining and thought provoking read. Whether you are new to design patterns, or have
been using them for years, you are sure to get something from visiting Objectville.”
— Richard Helm, coauthor of “Design Patterns” with rest of the
Gang of Four - Erich Gamma, Ralph Johnson and John Vlissides
“I feel like a thousand pounds of books have just been lifted off of my head.”
— Ward Cunningham, inventor of the Wiki
and founder of the Hillside Group
“This book is close to perfect, because of the way it combines expertise and readability. It speaks with
authority and it reads beautifully. It’s one of the very few software books I’ve ever read that strikes me as
indispensable. (I’d put maybe 10 books in this category, at the outside.)”
— David Gelernter, Professor of Computer Science,
Yale University and author of “Mirror Worlds” and “Machine Beauty”
“A Nose Dive into the realm of patterns, a land where complex things become simple, but where simple
things can also become complex. I can think of no better tour guides than the Freemans.”
— Miko Matsumura, Industry Analyst, The Middleware Company
Former Chief Java Evangelist, Sun Microsystems
“I laughed, I cried, it moved me.”
— Daniel Steinberg, Editor-in-Chief, java.net
“My ﬁrst reaction was to roll on the ﬂoor laughing. After I picked myself up, I realized that not only is the
book technically accurate, it is the easiest to understand introduction to design patterns that I have seen.”
— Dr. Timothy A. Budd, Associate Professor of Computer Science at
Oregon State University and author of more than a dozen books,
including “C++ for Java Programmers”
“Jerry Rice runs patterns better than any receiver in the NFL, but the Freemans have out run him.
Seriously...this is one of the funniest and smartest books on software design I’ve ever read.”
— Aaron LaBerge, VP Technology, ESPN.com

Download at WoweBook.Com

More Praise for Head First Design Patterns
“Great code design is, ﬁrst and foremost, great information design. A code designer is teaching a computer how to do something, and it is no surprise that a great teacher of computers should turn out to be
a great teacher of programmers. This book’s admirable clarity, humor and substantial doses of clever
make it the sort of book that helps even non-programmers think well about problem-solving.”
— Cory Doctorow, co-editor of Boing Boing
and author of “Down and Out in the Magic Kingdom”
and “Someone Comes to Town, Someone Leaves Town”
“There’s an old saying in the computer and videogame business – well, it can’t be that old because the
discipline is not all that old – and it goes something like this: Design is Life. What’s particularly curious
about this phrase is that even today almost no one who works at the craft of creating electronic games
can agree on what it means to “design” a game. Is the designer a software engineer? An art director?
A storyteller? An architect or a builder? A pitch person or a visionary? Can an individual indeed be in
part all of these? And most importantly, who the %$!#&* cares?
It has been said that the “designed by” credit in interactive entertainment is akin to the “directed by”
credit in ﬁlmmaking, which in fact allows it to share DNA with perhaps the single most controversial,
overstated, and too often entirely lacking in humility credit grab ever propagated on commercial art.
Good company, eh? Yet if Design is Life, then perhaps it is time we spent some quality cycles thinking
about what it is.
Eric and Elisabeth Freeman have intrepidly volunteered to look behind the code curtain for us in
“Head First Design Patterns.” I’m not sure either of them cares all that much about the PlayStation
or X-Box, nor should they. Yet they do address the notion of design at a signiﬁcantly honest level such
that anyone looking for ego reinforcement of his or her own brilliant auteurship is best advised not to
go digging here where truth is stunningly revealed. Sophists and circus barkers need not apply. Next
generation literati please come equipped with a pencil.”
— Ken Goldstein, Executive Vice President & Managing Director,
Disney Online
“Just the right tone for the geeked-out, casual-cool guru coder in all of us. The right reference for
practical development strategies—gets my brain going without having to slog through a bunch of tired,
stale professor-speak.”
— Travis Kalanick, Founder of Scour and Red Swoosh
Member of the MIT TR100
“This book combines good humors, great examples, and in-depth knowledge of Design Patterns in
such a way that makes learning fun. Being in the entertainment technology industry, I am intrigued
by the Hollywood Principle and the home theater Facade Pattern, to name a few. The understanding
of Design Patterns not only helps us create reusable and maintainable quality software, but also helps
sharpen our problem-solving skills across all problem domains. This book is a must read for all computer professionals and students.”
— Newton Lee, Founder and Editor-in-Chief, Association for Computing
Machinery’s (ACM) Computers in Entertainment (acmcie.org)

Download at WoweBook.Com

More Praise for Head First Design Patterns
“If there’s one subject that needs to be taught better, needs to be more fun to learn, it’s design patterns.
Thank goodness for Head First Design Patterns.
From the awesome Head First Java folks, this book uses every conceivable trick to help you understand
and remember. Not just loads of pictures: pictures of humans, which tend to interest other humans.
Surprises everywhere. Stories, because humans love narrative. (Stories about things like pizza and
chocolate. Need we say more?) Plus, it’s darned funny.
It also covers an enormous swath of concepts and techniques, including nearly all the patterns you’ll
use most (observer, decorator, factory, singleton, command, adapter, façade, template method, iterator,
composite, state, proxy). Read it, and those won’t be ‘just words’: they’ll be memories that tickle you,
and tools you own.”
— Bill Camarda, READ ONLY
“After using Head First Java to teach our freshman how to start programming, I was eagerly waiting to
see the next book in the series. Head First Design Patterns is that book and I am delighted. I am sure
it will quickly become the standard ﬁrst design patterns book to read, and is already the book I am
recommending to students.”
— Ben Bederson, Associate Professor of Computer Science & Director of the
Human-Computer Interaction Lab, University of Maryland
“Usually when reading through a book or article on design patterns I’d have to occasionally stick myself in
the eye with something just to make sure I was paying attention. Not with this book. Odd as it may sound,
this book makes learning about design patterns fun.
While other books on design patterns are saying, ‘Buehler... Buehler... Buehler...’ this book is on the ﬂoat
belting out ‘Shake it up, baby!’”
— Eric Wuehler
“I literally love this book. In fact, I kissed this book in front of my wife.”
— Satish Kumar

Praise for the Head First approach
“Java technology is everywhere—in mobile phones, cars, cameras, printers, games, PDAs, ATMs, smart
cards, gas pumps, sports stadiums, medical devices, Web cams, servers, you name it. If you develop
software and haven’t learned Java, it’s deﬁnitely time to dive in—Head First.”
— Scott McNealy, Sun Microsystems Chairman, President and CEO
“It’s fast, irreverent, fun, and engaging. Be careful—you might actually learn something!”
— Ken Arnold, former Senior Engineer at Sun Microsystems
Co-author (with James Gosling, creator of Java),
“The Java Programming Language”
Download at WoweBook.Com

Other related books from O’Reilly
Learning Java
Java in a Nutshell
Java Enterprise in a Nutshell
Java Examples in a Nutshell
Java Cookbook
J2EE Design Patterns

Other books in O'Reilly's Head First series
Head First Java
Head First EJB
Head First Servlets & JSP
Head First Object-Oriented Analysis & Design
Head First HTML with CSS & XHTML
Head Rush Ajax
Head First PMP
Head First SQL (2007)
Head First C# (2007)
Head First Software Development (2007)
Head First JavaScript (2007)

Be watching for more books in the Head First series!

Download at WoweBook.Com

Head First Design Patterns
Wouldn’t it be dreamy if
there was a Design Patterns
book that was more fun than going
to the dentist, and more revealing
than an IRS form? It’s probably
just a fantasy...

Eric Freeman
Elisabeth Freeman
with
Kathy Sierra
Bert Bates

Beijing • Cambridge • Köln • Paris • Sebastopol • Taipei • Tokyo

Download at WoweBook.Com

+HDG)LUVW'HVLJQ3DWWHUQV
Ja-ZQK.ZMMUIV-TQ[IJM\P.ZMMUIV3I\Pa;QMZZIIVL*MZ\*I\M[
+WXaZQOP\7¼:MQTTa5MLQI1VK)TTZQOP\[ZM[MZ^ML
8ZQV\MLQV\PM=VQ\ML;\I\M[WN )UMZQKI
8]JTQ[PMLJa7¼:MQTTa5MLQI1VK/ZI^MV[\MQV0QOP_Ia6WZ\P;MJI[\WXWT+)!
7¼:MQTTa5MLQIJWWS[UIaJMX]ZKPI[MLNWZML]KI\QWVITJ][QVM[[WZ[ITM[XZWUW\QWVIT][M7VTQVMMLQ\QWV[IZM
IT[WI^IQTIJTMNWZUW[\\Q\TM[[INIZQWZMQTTaKWU.WZUWZMQVNWZUI\QWVKWV\IK\W]ZKWZXWZI\MQV[\Q\]\QWVIT[ITM[
LMXIZ\UMV\" !! !! WZKWZXWZI\M(WZMQTTaKWU

(GLWRU

5QSM4W]SQLM[

&RYHU'HVLJQHU

-TTQM>WTKSPI][MV

3DWWHUQ:UDQJOHUV

-ZQK.ZMMUIV-TQ[IJM\P.ZMMUIV

)DFDGH'HFRUDWLRQ

-TQ[IJM\P.ZMMUIV

6WUDWHJ\

3I\Pa;QMZZIIVL*MZ\*I\M[

2EVHUYHU

7TQ^MZ

3ULQWLQJ+LVWRU\
7K\WJMZ".QZ[\-LQ\QWV
<PM7¼:MQTTaTWOWQ[IZMOQ[\MZML\ZILMUIZSWN 7¼:MQTTa5MLQI1VK2I^IIVLITT2I^IJI[ML\ZILMUIZS[IVLTWOW[
IZM\ZILMUIZS[WZZMOQ[\MZML\ZILMUIZS[WN ;]V5QKZW[a[\MU[1VKQV\PM=VQ\ML;\I\M[IVLW\PMZKW]V\ZQM[
7¼:MQTTa5MLQI1VKQ[QVLMXMVLMV\WN ;]V5QKZW[a[\MU[
5IVaWN \PMLM[QOVI\QWV[][MLJaUIV]NIK\]ZMZ[IVL[MTTMZ[\WLQ[\QVO]Q[P\PMQZXZWL]K\[IZMKTIQUMLI[
\ZILMUIZS[
?PMZM\PW[MLM[QOVI\QWV[IXXMIZQV\PQ[JWWSIVL7¼:MQTTa5MLQI1VK_I[I_IZMWN I\ZILMUIZSKTIQU\PM
LM[QOVI\QWV[PI^MJMMVXZQV\MLQVKIX[WZQVQ\QITKIX[
?PQTMM^MZaXZMKI]\QWVPI[JMMV\ISMVQV\PMXZMXIZI\QWVWN \PQ[JWWS\PMX]JTQ[PMZIVL\PMI]\PWZ[I[[]UMVW
ZM[XWV[QJQTQ\aNWZMZZWZ[WZWUQ[[QWV[WZNWZLIUIOM[ZM[]T\QVONZWU\PM][MWN \PMQVNWZUI\QWVKWV\IQVMLPMZMQV
1VW\PMZ_WZL[QN aW]][MIVa\PQVOQV0MIL.QZ[\,M[QOV8I\\MZV[\W[IaZ]VIV]KTMIZXW_MZXTIV\aW]¼ZMWVaW]Z
W_V?MLWPW_M^MZMVKW]ZIOMaW]\W][M\PM,2>QM_IXX
6WL]KS[_MZMPIZUMLQV\PMUISQVOWN \PQ[JWWS
<PMWZQOQVIT/W.IOZMML\WPI^M\PMQZXPW\W[QV\PQ[JWWSAM[\PMaZMITTaIZM\PI\OWWLTWWSQVO

ISBN-10: 0-596-00712-4

ISBN-13: 978-0-596-00712-6

[M]

[7/07]

Download at WoweBook.Com

To the Gang of Four, whose insight and expertise in capturing
and communicating Design Patterns has changed the face of
software design forever, and bettered the lives of developers
throughout the world.

But seriously, when are we going to see a second edition? After all,
it’s been only ten years!

Download at WoweBook.Com

WKHDXWKRUV

)]\PWZ[,M^MTWXMZ[WN0MIL.QZ[\,M[QOV8I\\MZV[
)UHHPDQ

K
(OLVDEHW

(ULF)UHHPDQ

-TQ[IJM\PQ[IVI]\PWZ[WN\_IZMLM^MTWXMZIVL
LQOQ\ITIZ\Q[\;PM¼[JMMVQV^WT^ML_Q\P\PM1V\MZVM\
[QVKM\PMMIZTaLIa[PI^QVOKWNW]VLML<PM)LI
8ZWRMK\<)8IVI_IZL_QVVQVO_MJ[Q\MNWZ_WUMV
QVKWUX]\QVOVW_ILWX\MLJa\PM)+55WZM
ZMKMV\Ta-TQ[IJM\PTMILZM[MIZKPIVLLM^MTWXUMV\
MNNWZ\[QVLQOQ\ITUMLQII\\PM?IT\,Q[VMa+WUXIVa
_PMZM[PMKWQV^MV\ML5W\QWVIKWV\MV\[a[\MU\PI\
LMTQ^MZ[\MZIJa\M[WN ^QLMWM^MZaLIa\W,Q[VMa-;86
IVL5W^QM[KWU][MZ[
-TQ[IJM\PQ[IKWUX]\MZ[KQMV\Q[\I\PMIZ\IVLPWTL[
OZIL]I\MLMOZMM[QV+WUX]\MZ;KQMVKMNZWUAITM
=VQ^MZ[Q\aIVL1VLQIVI=VQ^MZ[Q\a;PM¼[_WZSMLQV
I^IZQM\aWN IZMI[QVKT]LQVO^Q[]ITTIVO]IOM[:;;
[aVLQKI\QWVIVL1V\MZVM\[a[\MU[;PM¼[IT[WJMMVIV
IK\Q^MIL^WKI\MNWZ_WUMVQVKWUX]\QVOLM^MTWXQVO
XZWOZIU[\PI\MVKW]ZIOM_WUIV\WMV\MZ\PMÅMTL
<PM[MLIa[aW]¼TTÅVLPMZ[QXXQVO[WUM2I^IWZ+WKWI
WVPMZ5IKIT\PW]OP[PMLZMIU[WN ILIa_PMV\PM
_PWTM_WZTLQ[][QVO;KPMUM
-TQ[IJM\PPI[TW^MLPQSQVOIVL\PMW]\LWWZ[[QVKMPMZ
LIa[OZW_QVO]XQV;KW\TIVL?PMV[PM¼[W]\LWWZ[
PMZKIUMZIQ[VM^MZNIZ;PM¼[IT[WIVI^QLKaKTQ[\
^MOM\IZQIVIVLIVQUITTW^MZ
AW]KIV[MVLPMZMUIQTI\JM\P(_QKSMLTa[UIZ\KWU

-ZQKQ[IKWUX]\MZ[KQMV\Q[\_Q\PIXI[[QWVNWZUMLQIIVL
[WN\_IZMIZKPQ\MK\]ZM[0MR][\_ZIXXML]XNW]ZaMIZ[I\
ILZMIURWJ·LQZMK\QVO1V\MZVM\JZWILJIVLIVL_QZMTM[[
MNNWZ\[I\,Q[VMa·IVLQ[VW_JIKS\W_ZQ\QVOKZMI\QVOKWWT
[WN\_IZMIVLPIKSQVO2I^IIVL5IK[
-ZQK[XMV\ITW\WN \PM»![_WZSQVOWVIT\MZVI\Q^M[\W\PM
LM[S\WXUM\IXPWZ_Q\P,I^QL/MTMZV\MZIVL\PMa¼ZM
JW\P[\QTTI[SQVO\PMY]M[\QWV¹_PaLW1PI^M\WOQ^MIÅTM
IVIUM'º*I[MLWV\PQ[_WZS-ZQKTIVLMLI8P,I\
AITM=VQ^MZ[Q\aQV»!0MIT[WKWNW]VLML5QZZWZ?WZTL[
<MKPVWTWOQM[VW_IKY]QZML\WKZMI\MIKWUUMZKQIT
^MZ[QWVWN PQ[\PM[Q[_WZS4QNM[\ZMIU[
1VIXZM^QW][TQNM-ZQKJ]QT\[WN\_IZMNWZVM\_WZS[IVL
[]XMZKWUX]\MZ[AW]UQOP\SVW_PQUNZWU[]KPJWWS[I[
2I^I;XIKM[8ZQVKQXTM[8I\\MZV[IVL8ZIK\QKM-ZQKPI[NWVL
UMUWZQM[WN QUXTMUMV\QVO\]XTM[XIKM[a[\MU[WV
<PQVSQVO5IKPQVM+5[IVLKZMI\QVO[WUMWN \PMÅZ[\
1V\MZVM\QVNWZUI\QWV[a[\MU[NWZ6);)QV\PMTI\M [
-ZQKQ[K]ZZMV\TaTQ^QVOQV\PMPQOPLM[MZ\VMIZ;IV\I
.M?PMVPM¼[VW\_ZQ\QVO\M`\WZKWLMaW]¼TTÅVLPQU
[XMVLQVOUWZM\QUM\_MISQVO\PIV_I\KPQVOPQ[PWUM
\PMI\MZIVL\ZaQVO\WZM[\WZQVOIKQZKI! [,ZIOWV¼[4IQZ
^QLMWOIUM0MIT[W_W]TLV¼\UQVLUWWVTQOP\QVOI[IV
MTMK\ZWVQKI,2
?ZQ\M\WPQUI\MZQK(_QKSMLTa[UIZ\KWUWZ^Q[Q\PQ[JTWO
I\P\\X"___MZQKNZMMUIVKWU

YLLL
Download at WoweBook.Com

Creators of the Head First series
(and co-conspirators on this book)
Kathy Sierra

Bert Bates

Bert is a long-time software developer and architect,

Kathy has been interested in learning theory since

her days as a game designer (she wrote games for Virgin,
MGM, and Amblin’). She developed much of the Head
First format while teaching New Media Authoring for
UCLA Extension’s Entertainment Studies program.
More recently, she’s been a master trainer for Sun
Microsystems, teaching Sun’s Java instructors how to
teach the latest Java technologies, and developing several
of Sun’s certiﬁcation exams. Together with Bert Bates,
she has been actively using the Head First concepts to
teach throusands of developers. Kathy is the founder of
javaranch.com, which won a 2003 and 2004 Software
Development magazine Jolt Cola Productivity Award.
You might catch her teaching Java on the Java Jam Geek
Cruise (geekcruises.com).
She recently moved from California to Colorado, where
she’s had to learn new words like, “ice scraper” and
“ﬂeece”, but the lightning there is fantastic.

but a decade-long stint in artiﬁcial intelligence drove
his interest in learning theory and technology-based
training. He’s been helping clients becoming better
programmers ever since. Recently, he’s been heading
up the development team for several of Sun’s Java
Certiﬁcation exams.

He spent the ﬁrst decade of his software career
travelling the world to help broadcast clients like
Radio New Zealand, the Weather Channel, and the
Arts & Entertainment Network (A & E). One of his
all-time favorite projects was building a full rail system
simulation for Union Paciﬁc Railroad.
Bert is a long-time, hopelessly addicted go player, and
has been working on a go program for way too long.
He’s a fair guitar player and is now trying his hand at
banjo.
Look for him on javaranch, on the IGS go server, or
you can write to him at terrapin@wickedlysmart.com.

Likes: runing, skiing, skateboarding, playing with her
Icelandic horse, and weird science. Dislikes: entropy.
You can ﬁnd her on javaranch, or occasionally blogging
on java.net. Write to her at kathy@wickedlysmart.com.

Download at WoweBook.Com

table of contents

Table of Contents (summary)
Intro

xxv

1

Welcome to Design Patterns: an introduction

1

2

Keeping your Objects in the know: the Observer Pattern

37

3

Decorating Objects: the Decorator Pattern

79

4

Baking with OO goodness: the Factory Pattern

109

5

One of a Kind Objects: the Singleton Pattern

169

6

Encapsulating Invocation: the Command Pattern

191

7

Being Adaptive: the Adapter and Facade Patterns

235

8

Encapsulating Algorithms: theTemplate Method Pattern

275

9

Well-managed Collections: the Iterator and Composite Patterns

315

10

The State of Things: the State Pattern

385

11

Controlling Object Access: the Proxy Pattern

429

12

Patterns of Patterns: Compound Patterns

499

13

Patterns in the Real World: Better Living with Patterns

577

14

Appendix: Leftover Patterns

611

Table of Contents (the real thing)
Intro
Your brain on Design Patterns.

Here you are trying to learn something, while

here your brain is doing you a favor by making sure the learning doesn’t stick. Your brain’s
thinking, “Better leave room for more important things, like which wild animals to avoid and
whether naked snowboarding is a bad idea.” So how do you trick your brain into thinking
that your life depends on knowing Design Patterns?
Who is this book for?

xxvi

We know what your brain is thinking

xxvii

Metacognition

xxix

Bend your brain into submission

xxxi

Technical reviewers

xxxiv

Acknowledgements

xxxv

x
Download at WoweBook.Com

1

intro to Design Patterns
Welcome to Design Patterns
Someone has already solved your problems. In this chapter,
you’ll learn why (and how) you can exploit the wisdom and lessons learned by
other developers who’ve been down the same design problem road and survived
the trip. Before we’re done, we’ll look at the use and beneﬁts of design patterns,
look at some key OO design principles, and walk through an example of how one
pattern works. The best way to use patterns is to load your brain with them and
then recognize places in your designs and existing applications where you can
apply them. Instead of code reuse, with patterns you get experience reuse.

Remember, knowing
concepts like abstraction,
inheritance, and polymorphism do
not make you a good object oriented
designer. A design guru thinks
about how to create ﬂexible
designs that are maintainable
and that can cope with
change.

The SimUDuck app

2

Joe thinks about inheritance...

5

How about an interface?

6

The one constant in software development

8

Separating what changes from what stays the same

10

Designing the Duck Behaviors

11

Testing the Duck code

18

Setting behavior dynamically

20

The Big Picture on encapsulated behaviors

22

HAS-A can be better than IS-A

23

The Strategy Pattern

24

The power of a shared pattern vocabulary

28

How do I use Design Patterns?

29

Tools for your Design Toolbox

32

Exercise Solutions

34
AIN

r

avio
ﬂy beh

ulated

Encaps

Your BR

e>>

<<interfac

vior

FlyBeha

fly()

y
FlyNoWa

ings
FlyWithW

fly() {
- can’t fly!
// do nothing

fly() {
ts duck flying
// implemen
ior flyBehav
havior;
havior quackBe

Client

}

}

ior;

FlyBehav

ulated

QuackBe

Encaps

swim()
display()

quack

r

behavio

e>>

<<interfac

ehavior

QuackB

uack()

performQ

quack()

ly()

performF

avior()
)
Behavior(
..
setQuack
methods.
duck-like
// OTHER

setFlyBeh

MuteQuack
Squeak
Quack
Decoy Duck

Rubber

Redhead

Object that
holds state

Duck

{
display()
}
a redhead
// looks like

quack) {
ts duck quacking
// implemen

{
display()
duck }
a decoy
// looks like

quack() {
duckie squeak
// rubber

}

}

}

OBSERVER

8

8

Su
bje

Duck

{
display()
ck }
a rubberdu
// looks like

int

ct Obje

ct
Dog Obje

8
8
8

Duck Obje

Mo

Automatic update/notification

ct

Cat Object

ec
use Obj

t

Observers

oller

Contr

t Objects

Duck

quack() {
- can’t quack!
// do nothing

Dependen

Mallard

{
display()
}
a mallard
// looks like

ct

A Bunch of Patterns

Duck

MVC
l

est
Requ

Mode

View

new
Your Code,ednowwith
and improv erns!
design patt

xi
Download at WoweBook.Com

table of contents

2

the Observer Pattern
Keeping your Objects in the Know
Don’t miss out when something interesting happens!
We’ve got a pattern that keeps your objects in the know when something they
might care about happens. Objects can even decide at runtime whether they
want to be kept informed. The Observer Pattern is one of the most heavily used
patterns in the JDK, and it’s incredibly useful. Before we’re done, we’ll also look
at one to many relationships and loose coupling (yeah, that’s right, we said
coupling). With Observer, you’ll be the life of the Patterns Party.

OO Basics
what varies
Encapsulate
herition over in
si
o
p
m
o
C
r
Favo
tance
not
Interfaces,
o
t
m
a
r
g
o
r
P
ions
implementat
led
loosely coup
Strive for ween objects that
designs bet
interact

39

Meet the Observer Pattern

44

Publishers + Subscribers = Observer Pattern

45

Five minute drama: a subject for observation

48

The Observer Pattern defined

51

The power of Loose Coupling

53

Designing the Weather Station

56

Implementing the Weather Station

57

Using Java’s built-in Observer Pattern

64

The dark side of java.util.Observable

71

Tools for your Design Toolbox

74

Exercise Solutions

78

ONE TO MANY RELATIONSHIP

Object that
holds state

8

8
int

ct Obje

ct

Su
bje

ct
Dog Obje

8
8
8

Duck Obje

Automatic update/notification

xii
Download at WoweBook.Com

Mo

ct

Cat Object

ec
use Obj

t

Observers

Dependent Objects

s

OO Principle

Abstraction
n
Encapsulatio
m
is
Polymorph
Inheritence

The Weather Monitoring application

3

the Decorator Pattern
Decorating Objects
Just call this chapter “Design Eye for the Inheritance
Guy.” We’ll re-examine the typical overuse of inheritance and you’ll learn how
to decorate your classes at runtime using a form of object composition. Why?
Once you know the techniques of decorating, you’ll be able to give your (or
someone else’s) objects new responsibilities without making any code changes
to the underlying classes.

I used to think real men
subclassed everything. That was until
I learned the power of extension
at runtime, rather than at compile
time. Now look at me !

Welcome to Starbuzz Coffee

80

The Open-Closed Principle

86

Meet the Decorator Pattern

88

Constructing a Drink Order with Decorators

89

The Decorator Pattern Defined

91

Decorating our Beverages

92

Writing the Starbuzz code

95

Real World Decorators: Java I/O

100

Writing your own Java I/O Decorator

102

Tools for your Design Toolbox

105

Exercise Solutions

106

xiii
Download at WoweBook.Com

table of contents

4

the Factory Pattern
Baking with OO Goodness
Get ready to cook some loosely coupled OO designs.
There is more to making objects than just using the new operator. You’ll learn
that instantiation is an activity that shouldn’t always be done in public and can
often lead to coupling problems. And you don’t want that, do you? Find out how
Factory Patterns can help save you from embarrasing dependencies.

The clients of the Abstract
Factory are the two
instances of our PizzaStore,
NYPizzaStore and
ChicagoStylePizzaSore.
NYPizzaStore
createPizza()

The abstract PizzaIngredientFactory
is the interface that defines how to
make a family of related products
- everything we need to make a pizza.

<<interface>>
Dough

ThickCrustDough

ThinCrustDough

<<interface>>
PizzaIngredientFactory

When you see “new”, think “concrete”

110

Objectville Pizza

112

Encapsulating object creation

114

Building a simple pizza factory

115

The Simple Factory defined

117

A Framework for the pizza store

120

Allowing the subclasses to decide

121

Let’s make a PizzaStore

123

Declaring a factory method

125

Meet the Factory Method Pattern

131

Parallel class hierarchies

132

Factory Method Pattern defined

134

A very dependent PizzaStore

137

Looking at object dependencies

138

The Dependency Inversion Principle

139

Meanwhile, back at the PizzaStore...

144

Families of ingredients...

145

Building our ingredient factories

146

Looking at the Abstract Factory

153

Behind the scenes

154

Abstract Factory Pattern deﬁned

156

Factory Method and Abstract Factory compared

160

Tools for your Design Toolbox

162

Exercise Solutions

164

createDough()

<<interface>>
Sauce

createSauce()
createCheese()
createVeggies()
createPepperoni()

PlumTomatoSauce

createClam()

NYPizzaIngredientFactory

ChicagoPizzaIngredientFactory

createDough()

createDough()

createSauce()

createSauce()

createCheese()

createCheese()

createVeggies()

createVeggies()

createPepperoni()

createPepperoni()

createClam()

createClam()

MarinaraSauce

<<interface>>
Cheese

Mozzarella Cheese

ReggianoCheese

<<interface>>
Clams

The job of the concrete
pizza factories is to
make pizza ingredients.
Each factory knows
how to create the right
objects for their region.

FrozenClams

Each factory produces a different
implementation for the family of products.

FreshClams

xiv
Download at WoweBook.Com

5

the Singleton Pattern
One of a Kind Objects
The Singleton Pattern: your ticket to creating one-of-akind objects, for which there is only one instance. You
might be happy to know that of all patterns, the Singleton is the simplest in terms
of its class diagram; in fact the diagram holds just a single class! But don’t get
too comfortable; despite its simplicity from a class design perspective, we’ll
encounter quite a few bumps and potholes in its implementation. So buckle
up—this one’s not as simple as it seems...
One and only one object

170

The Little Singleton

171

Dissecting the classic Singleton Pattern

173

Confessions of a Singleton

174

The Chocolate Factory

175

Singleton Pattern defined

177

Houston, we have a problem...

178

BE the JVM

179

Dealing with multithreading

180

Singleton Q&A

184

Tools for your Design Toolbox

186

Exercise Solutions

188

Hershey, PA

OO Pattenersnasinfaesmilya onofe-algotori-thmmnaans,r-ly

ef ak
itiniote
dso
ad
th
vidi-ine eanan
actjeesohct
roat
seyrov-ereaderachfit-beoondrtw
mob
StrOatbeg
- Pth
Adntt
ysctdem
r
e,-an
rysof
eeF
ef
c
a
d-myn
it
th
es
c
ri
aliliDvalam
t
cy
e
at
go
c
je
o
e,
ul
en
al
a
D
es
h
ob
e
at
t
e
th
st
an
am
encadpsepenAdbstrra
but
s
f
M
ts
to
le
ge
y
ng
s
r
an
gy
ie
ti
ibed
o
ch
te
x
ea
t
lit
ob
le
c
bi
cr
f
ct
a
an
si
.
St
je
asitjeleshoctonut, lyg inha-s t
a
it
F
or
on
at
.
cl
ng
e
e
f
ob
d
le
sp
ustidurjeup
reabn inonteerface at
ectas wte
atea
pr
th
anns
ssed
chanwge
he
Eid
intoal poin
fnttioor
iecr
-dov
ieor
ob
f
s
e
nd
cl
n
t
as
ac
or
cl
en
om
no
t
ec
ob
rf
ex
e
fr
gl
le
D
ch
te
y
g
ar
or
ep
hi
a
in
.
tl
f
d
wovclidaseses. a class
tsSdinor sssuesbcladec
llyenreden
geprte
canden
ssnciniddre
te
indedpeep
laat
bcto
coan
stan
inlath
eirceac
leictifon
Method lets .
alivyisulyeeng
ry
atec
to
.
F
aualtotemsprn
it
e.
to
y.
at
lit
ss
ti
anof acce ation to the subclasses
iona
functst
ti
defer instan

xv
Download at WoweBook.Com

table of contents

6

the Command Pattern
Encapsulating Invocation
In this chapter we take encapsulation to a whole new
level: we’re going to encapsulate method invocation.
That’s right, by encapsulating invocation we can crystallize pieces of computation
so that the object invoking the computation doesn’t need to worry about how to do
things; it just uses our crystallized method to get it done. We can also do some
wickedly smart things with these encapsulated method invocations, like save
them away for logging or reuse them to implement undo in our code.

er
sists of an ord
The Order con
omer’s menu
slip and the custwritten on it.
are
t
tha
s
item
crea

eese
with Ch
Burger Shake
Malt

I’ll have a Burger
with Cheese and a Malt
Shake

teO

rde

r()

ere
rt H
Sta
takeO

rder(

The customer knows
what he wants and
creates an order.

)

The Waitress takes the Order,
gets around to it, she calls and when she
orderUp()
method to begin the Order’sitsprepar
ation.

or

de

rU

p(

)

The Short Order
Cook follows the
instructions of
the Order and
produces the meal.

se
with Chee
Burger Shake
Malt

makeBurger(), makeShake()

192

The Remote Control

193

Taking a look at the vendor classes

194

Meanwhile, back at the Diner...

197

Let’s study the Diner interaction

198

The Objectville Diner Roles and Responsibilities

199

From the Diner to the Command Pattern

201

Our first command object

203

The Command Pattern defined

206

The Command Pattern and the Remote Control

208

Implementing the Remote Control

210

Putting the Remote Control through its paces

212

Time to write that documentation

215

Using state to implement Undo

220

Every remote needs a Party Mode!

224

Using a Macro Command

225

More uses of the Command Pattern: Queuing requests

228

More uses of the Command Pattern: Logging requests

229

Tools for your Design Toolbox

230

Exercise Solutions

232

ou

tp

ut

s all
rder ha
The O structions e
the in to prepar
neededeal. The e
the m directs th k
Order Order Cooe
Short methods lik
with urger().
makeB

Home Automation or Bust

xvi
Download at WoweBook.Com

7

the Adapter and Facade Patterns
Being Adaptive
In this chapter we’re going to attempt such impossible
feats as putting a square peg in a round hole. Sound impossible?
Not when we have Design Patterns. Remember the Decorator Pattern? We
wrapped objects to give them new responsibilities. Now we’re going to wrap some
objects with a different purpose: to make their interfaces look like something they’re
not. Why would we do that? So we can adapt a design expecting one interface to a
class that implements a different interface. That’s not all, while we’re at it we’re going
to look at another pattern that wraps objects to simplify their interface.

European Wall Outlet

AC Power Adapter

Standard AC Plug

Adapters all around us

236

Object Oriented Adapters

237

The Adapter Pattern explained

241

Adapter Pattern defined

243

Object and Class Adapters

244

Tonight’s talk: The Object Adapter and Class Adapter

247

Real World Adapters

248

Adapting an Enumeration to an Iterator

249

Tonight’s talk: The Decorator Pattern and the Adapter Pattern

252

Home Sweet Home Theater

255

Lights, Camera, Facade!

258

Constructing your Home Theater Facade

261

Facade Pattern defined

264

The Principle of Least Knowledge

265

Tools for your Design Toolbox

270

Exercise Solutions

272

)

Adap tee

est(

qu
Re

reques

Client

t()

nted
The Client is impleme
against the target interface

ted
nsla

tra

Adap ter
adaptee
interface

e
rfac

te
t in
rge

ta

nts the
The Adapter impleme
an
target interface and holds
instance of the Adaptee

Turkey was the
ce
adaptee interfa

xvii
Download at WoweBook.Com

table of contents

the Template Method Pattern

8

Encapsulating Algorithms
We’ve encapsulated object creation, method invocation,
complex interfaces, ducks, pizzas... what could be next?
We’re going to get down to encapsulating pieces of algorithms so that subclasses can
hook themselves right into a computation anytime they want. We’re even going to
learn about a design principle inspired by Hollywood.

We’ve recognized
that the two recipes
are essentially the
same, although
some of the steps
require different
implementations. So
we’ve generalized the
recipe and placed it in
the base class.

Te a
Boil some wat

1
2

Ste ep

er

C o f fe e
1

the water
the tea bag in

3

Pou r tea in a

4

Add lemon

2
3

cup

4

Bo il some
Brew th
e
Po ur co ff

Add suga
r

wate r

co ffee gr

ee in a cu

inds

p

and mi lk

Caffeine Beverage
generalize

1
2

Brew

relies on

3

Pour beverage in a cup

4

Add condiments

subclass for

ss

Tea subcla

some steps

2

Steep the teabag in the

4

Add lemon

water

Boil some water

knows
Caffeine Beveragesteps of
and controls theperforms
the recipe, and f, but
itsel
3
steps 1 and
fee
relies on Tea orandCof4.
to do steps 2

Whipping up some coffee and tea classes

277

Abstracting Coffee and Tea

280

Taking the design further

281

Abstracting prepareRecipe()

282

What have we done?

285

Meet the Template Method

286

Let’s make some tea

287

What did the Template Method get us?

288

Template Method Pattern defined

289

Code up close

290

Hooked on Template Method...

292

Using the hook

293

Coffee? Tea? Nah, let’s run the TestDrive

294

The Hollywood Principle

296

The Hollywood Principle and the Template Method

297

Template Methods in the Wild

299

Sorting with Template Method

300

We’ve got some ducks to sort

301

Comparing ducks and ducks

302

The making of the sorting duck machine

304

Swingin’ with Frames

306

Applets

307

Tonight’s talk: Template Method and Strategy

308

Tools for your Design Toolbox

311

Exercise Solutions

312

generalize

relies on
subclass for
some steps

Coffee

subclass

fee gri nds

2

Bre w the cof

4

Add sug ar and

mil k

xviii
Download at WoweBook.Com

the Iterator and Composite Patterns

9

Well-Managed Collections
There are lots of ways to stuff objects into a collection.
Put them in an Array, a Stack, a List, a Map, take your pick. Each has its own
advantages and tradeoffs. But when your client wants to iterate over your objects,
are you going to show him your implementation? We certainly hope not! That just
wouldn’t be professional. Don’t worry—in this chapter you’ll see how you can let
your clients iterate through your objects without ever seeing how you store your
objects. You’re also going to learn how to create some super collections of objects
that can leap over some impressive data structures in a single bound. You’re also
going to learn a thing or two about object responsibility.

nu

All Menus
Pa

eM
e

nc
ake us
Ho

Di
ner nu
Me

1

Ca
feMenu

2

3

Café Menu

Pancake Menu

Diner Menu
Me
nuItem

Me
nuItem

1

2

Me
nuItem

Men

3

uItem

4

key

Array

1

key

Me
nuItem

key

Me
nuItem

Me
nuItem

2

Me
nuItem

Me
nuItem

ArrayList

Dessert Menu

key

3
Me
nuItem

4

1
Me
nuItem

2
Me
nuItem

3
Me
nuItem

4
Men

Men

uItem

Men

uItem

Objectville Diner and Pancake House merge

316

Comparing Menu implementations

318

Can we encapsulate the iteration?

323

Meet the Iterator Pattern

325

Adding an Iterator to DinerMenu

326

Looking at the design

331

Cleaning things up with java.util.Iterator

333

What does this get us?

335

Iterator Pattern defined

336

Single Responsibility

339

Iterators and Collections

348

Iterators and Collections in Java 5

349

Just when we thought it was safe...

353

The Composite Pattern defined

356

Designing Menus with Composite

359

Implementing the Composite Menu

362

Flashback to Iterator

368

The Null Iterator

372

The magic of Iterator & Composite together...

374

Tools for your Design Toolbox

380

Exercise Solutions

381

uItem

xix
Download at WoweBook.Com

table of contents

the State Pattern

10

The State of Things
A little known fact: the Strategy and State Patterns were
twins separated at birth. As you know, the Strategy Pattern went on
to create a wildly successful business around interchangeable algorithms. State,
however, took the perhaps more noble path of helping objects learn to control their
behavior by changing their internal state. He’s often overheard telling his object
clients, “just repeat after me, I’m good enough, I’m smart enough, and doggonit...”

Where the Gumball Machine
is Never Half Empty

gumbal

ls = 0

ball

s>

ns

cra

arter

inserts qu

No
r
Quarte
gum

tur

Has r
Quarte

arter

Out obfalls
Gum

0

ejects qu

Mighty Gumball, Inc.

controller needs to
the gumball machine
for us! We
Here’s the way we thinkcan
implement this in Java
work. We’re hoping you
e, so you need to keep
futur
the
in
ior
behav
more
g
may be addin
le!
possib
as
e
ainabl
maint
and
le
the design as flexib
- Mighty Gumball Engineers

dispenslle
gumba

ll
Gumba
Sold

nk

How do we implement state?

387

State Machines 101

388

A ﬁrst attempt at a state machine

390

You knew it was coming... a change request!

394

The messy STATE of things...

396

Defining the State interfaces and classes

399

Implementing our State Classes

401

Reworking the Gumball Machine

402

The State Pattern defined

410

State versus Strategy

411

State sanity check

417

We almost forgot!

420

Tools for your Design Toolbox

423

Exercise Solutions

424

xx
Download at WoweBook.Com

11

the Proxy Pattern
Controlling Object Access
Ever play good cop, bad cop? You’re the good cop and you provide
all your services in a nice and friendly manner, but you don’t want everyone
asking you for services, so you have the bad cop control access to you. That’s
what proxies do: control and manage access. As you’re going to see there are
lots of ways in which proxies stand in for the objects they proxy. Proxies have
been known to haul entire method calls over the Internet for their proxied objects;
they’ve also been known to patiently stand in the place for some pretty lazy
objects.

Not
Hot

<<interface>>

Monitoring the gumball machines

430

The role of the ‘remote proxy’

434

RMI detour

437

GumballMachine remote proxy

450

Remote proxy behind the scenes

458

The Proxy Pattern defined

460

Get Ready for virtual proxy

462

Designing the CD cover virtual proxy

464

Virtual proxy behind the scenes

470

Using the Java API’s proxy

474

Five minute drama: protecting subjects

478

Creating a dynamic proxy

479

The Proxy Zoo

488

Tools for your Design Toolbox

491

Exercise Solutions

492

<<interface>>
InvocationHandler

Subject

request()

invoke()

now consists
The proxy sse
s.
cla
o
of tw
Proxy

RealSubject
request()

request()

InvocationHandler
invoke()

xxi
Download at WoweBook.Com

table of contents

12

Compound Patterns
Patterns of Patterns
Who would have ever guessed that Patterns could work
together? You’ve already witnessed the acrimonious Fireside Chats (and be
thankful you didn’t have to see the Pattern Death Match pages that the publisher
forced us to remove from the book so we could avoid having to use a Parent’s
Advisory warning label), so who would have thought patterns can actually get along
well together? Believe it or not, some of the most powerful OO designs use several
patterns together. Get ready to take your pattern skills to the next level; it’s time for
Compound Patterns. Just be careful—your co-workers might kill you if you’re struck
with Pattern Fever.

The beat is set at 119 BPM and you
would like to increase it to 120.

You click on
the increase
beat button.

View

Which results in the
controller being invoked.

Controller
You see the beatbar
pulse every 1/2 second.

Because the BPM is 120, the view
gets
a beat notification every 1/2 second.

View

The controller asks
the model to update
its BPM by one.

atMod
Be on() el
setBPM() off()
getBPM

The view is updated
to 120 BPM.

BPM
View is notified that theM()
on
changed. It calls getBP
the model state.

()

Compound Patterns

500

Duck reunion

501

Adding an adapter

504

Adding a decorator

506

Adding a factory

508

Adding a composite, and iterator

513

Adding an observer

516

Patterns summary

523

A duck’s eye view: the class diagram

524

Model-View-Controller, the song

526

Design Patterns are your key to the MVC

528

Looking at MVC through patterns-colored glasses

532

Using MVC to control the beat...

534

The Model

537

The View

539

The Controller

542

Exploring strategy

545

Adapting the model

546

Now we’re ready for a HeartController

547

MVC and the Web

549

Design Patterns and Model 2

557

Tools for your Design Toolbox

560

Exercise Solutions

561

xxii
Download at WoweBook.Com

13

Better Living with Patterns
Patterns in the Real World
Ahhhh, now you’re ready for a bright new world filled with
Design Patterns. But, before you go opening all those new doors of opportunity
we need to cover a few details that you’ll encounter out in the real world—things get a
little more complex out there than they are here in Objectville. Come along, we’ve got
a nice guide to help you through the transition...

ide to
The Objectville Gu
ns
h Design Patter
Better Living wit
patterns in the real

g with
& tricks for livin
handy guide of tips
Please accept ourguide you will:
world. In this
the deﬁnition of a
onceptions about
misc
mon
com
all too
b Learn the tern.”
just have to
“Design Pat
s
alog and why you
ign Pattern Cat
r those nifty Des
b Discove
.
get one.
at the wrong time
tern
Pat
ign
using a Des
embarrassment of
b Avoid the
belong.
they
e
wher
ns
catio
in classiﬁ
to keep patterns
quick
b Learn how
the gurus; read our
erns isn’t just for
discovering pattpatt
r too.
b See that
me a erns write
beco
and
wTo
is revealed.
Ho
s Gang of Four
eriou
myst
the
of
tify
when the true iden
patterns user
b Be there
e table books any
coffe
the
–
s
with the neighbor
b Keep up
must own.
a Zen master.
Patterns mind like
train your Design
b Learn to
patterns
by improving your
rs
lope
deve
e
ds and inﬂuenc
b Win frien
vocabulary.

578

Design Pattern defined

579

Looking more closely at the Design Pattern definition

581

May the force be with you

582

Pattern catalogs

583

How to create patterns

586

So you wanna be a Design Patterns writer?

587

Organizing Design Patterns

589

Thinking in patterns

594

Your mind on patterns

597

Don’t forget the power of the shared vocabulary

599

Top ﬁve ways to share your vocabulary

600

Cruisin’ Objectville with the Gang of Four

601

Your journey has just begun...

602

Other Design Pattern resources

603

The Patterns Zoo

604

Annihilating evil with Anti-Patterns

606

Tools for your Design Toolbox

608

Leaving Objectville...

609

lm

rd He

Richa

Your Objectville guide

Ralph
Johnson

Gang of Four

John Vlissides
Erich Gamma

xxiii
Download at WoweBook.Com

table of contents

14

Appendix: Leftover Patterns
Not everyone can be the most popular. A lot has changed in
the last 10 years. Since Design Patterns: Elements of Reusable Object-Oriented
Software ﬁrst came out, developers have applied these patterns thousands of times.
The patterns we summarize in this appendix are full-ﬂedged, card-carrying, ofﬁcial
GoF patterns, but aren’t always used as often as the patterns we’ve explored so
far. But these patterns are awesome in their own right, and if your situation calls for
them, you should apply them with your head held high. Our goal in this appendix is
to give you a high level idea of what these patterns are all about.

The Client asks the
Visitor to get information from the
Composite structure...
New methods can be
added to the Visitor
without affecting the
Composite.

g()
tin
Ra
lth ()
ea ries )
H
t
o
(
l
ge tCa tein
ge tPro bs()
ge tCar
ge

All these composite
classes have to do is add
a getState() method
not worry about
(and
call
to
able
be
to
needs
The Visitor
s, and this is exposing themselves : ).
getState() across classemetho
ds for
where you can add new
the client to use.
te()
getSta

Visitor

to
The Traverser knows how
gh
guide the Visitor throu
the Composite structure.

i

MenuItem

e()
tat
tS
ge

Client /
Traverser

getState()
getS
tate
()
ge
tS
ta
MenuItem
te
()

Menu

Ingredient

Ingredient

Index

Bridge

612

Builder

614

Chain of Responsibility

616

Flyweight

618

Interpreter

620

Mediator

622

Memento

624

Prototype

626

Visitor

628

631

xxiv
Download at WoweBook.Com

how to use this book

Intro
I can’t believe they
put that in a design
patterns book!

estion:
he burning qu
t
er
sw
an
e
tterns book?”
w
pa
n,
In this sectio they put that in a design
“So, why DID

xxv
Download at WoweBook.Com

how to use this book

Who is this book for ?
If you can answer “yes” to all of these:
1

Do you know Java? (You don’t need to be a guru.)

2

Do you want to learn, understand, remember, and
apply design patterns, including the OO design
principles upon which design patterns are based?

3

Do you prefer stimulating dinner party conversation
to dry, dull, academic lectures?

this book is for you.

Who should probably back away from this book?
If you can answer “yes” to any one of these:
1

Are you completely new to Java?
(You don’t need to be advanced, and even if you
don’t know Java, but you know C#, you’ll probably
understand at least 80% of the code examples. You
also might be okay with just a C++ background.)

2

Are you a kick-butt OO designer/developer looking
for a reference book?

3

Are you an architect looking for enterprise design
patterns?

4

Are you afraid to try something different?
Would you rather have a root canal than mix
stripes with plaid? Do you believe that a technical
book can’t be serious if Java components are
anthropomorphized?

this book is not for you.

[note from marketing: this book is
for anyone with a credit car
d.]
xxvi

intro
Download at WoweBook.Com

ay if
You’ll probablyinbesteaokd.
you know C#

the intro

We know what you’re thinking.
“How can this be a serious programming book?”
“What’s with all the graphics?”
“Can I actually learn it this way?”

And we know what your brain is thinking.

your brain
THIS is im thinks
portant.

Your brain craves novelty. It’s always searching, scanning, waiting for
something unusual. It was built that way, and it helps you stay alive.
Today, you’re less likely to be a tiger snack. But your brain’s still looking. You
just never know.
So what does your brain do with all the routine, ordinary, normal things
you encounter? Everything it can to stop them from interfering with the
brain’s real job—recording things that matter. It doesn’t bother saving
the boring things; they never make it past the “this is obviously not
important” ﬁlter.
How does your brain know what’s important? Suppose you’re out for a day
hike and a tiger jumps in front of you, what happens inside your head and
body?

Great. Only
637 more dull, dry,
boring pages.

Neurons ﬁre. Emotions crank up. Chemicals surge.
And that’s how your brain knows...
This must be important! Don’t forget it!
But imagine you’re at home, or in a library. It’s a safe, warm, tiger-free zone.
You’re studying. Getting ready for an exam. Or trying to learn some tough
technical topic your boss thinks will take a week, ten days at the most.

thinks
your branin’t worth
THIinS gis.
sav

Just one problem. Your brain’s trying to do you a big favor. It’s trying
to make sure that this obviously non-important content doesn’t clutter
up scarce resources. Resources that are better spent storing the really
big things. Like tigers. Like the danger of ﬁre. Like how you should
never again snowboard in shorts.
And there’s no simple way to tell your brain, “Hey brain, thank you
very much, but no matter how dull this book is, and how little I’m
registering on the emotional Richter scale right now, I really do want
you to keep this stuff around.”

you are here4 xxvii
Download at WoweBook.Com

how to use this book

t” reader as a learner.

We think of a “Head Firs

ke sure
ve to get it, then ma
thing? First, you ha
me
so
rn
lea
to
the
e
on
tak
d
. Base
So what does it
facts into your head
It’s not about pushing
it.
t
ge
onal psychology,
for
ati
n’t
uc
do
ed
u
d
yo
urobiology, an
ne
,
ce
ien
sc
e
itiv
gn
ns your brain on.
latest research in co
ge. We know what tur
pa
a
on
t
tex
n
tha
more
learning takes a lot
ciples:
First lear ning prin
needs to call a
Some of the Head

method on

RMI remote

the
service
server
than words alone, and
far more memorable
are
s
age
Im
l.
ua
vis
and
recall
Make it
89% improvement in
doCalc()
more effective (up to
the
t
Pu
make learning much
e.
abl
and
rst
kes things more unde
ma
o
als
It
s).
die
on
n
stu
tha
transfer
s they relate to, rather
near the gr aphic
return value
likely
as
ce
words within or
twi
to
up
be
l
r page, and learners wil
the
ano
on
or
m
tto
the bo
ated to the content.
to solve problems rel
dies, students
d style. In recent stu
to
l and personalize
na
tio
sa
er
nv
content spoke directly
co
the
a
if
Use
post-learning tests
on
r
tte
l
be
ma
40%
for
a
to
up
ing
performed
style rather than tak
erson, conversational
t-p
firs
a
lf
ng
rse
usi
you
r,
e
de
the rea
ual language. Don’t tak
an
d of lec turing. Use cas
It really sucks to be
ner par ty
tone. Tell stories instea
ion to: a stimulating din
ent
uld you pay more att
abstract method. You
wo
ich
Wh
.
sly
iou
ser
too
don’t have a body.
e?
companion, or a lec tur
less
ly. In other words, un
think more deep
to
d.
hea
r
Get the learner to
you
in
Does it make sense
ns
s, nothing much happe
om?
ron
hro
neu
Bat
r
-A
you
IS
flex
Tub
ly
say
you active
ious, and inspired to
? Or is
Bathroom IS-A Tub
tivated, engaged, cur
e.
dg
A reader has to be mo
wle
kno
new
S-A relationship?
ate
HA
ner
a
ge
it
and
ns,
sio
conclu
solve problems, draw
and thought-provok ing
challenges, exercises,
d
nee
you
t,
tha
And for
sides of the brain,
ies that involve both
questions, and activit
.
abstract void roam(); and multiple senses
ion. We’ve
he reader’s attent
y ! lon.
Get—and keep—t
d
o
y awake past
b
sta
’t
can
d
I
t
o
tho
mic
nt to learn this bu
No me with a se
all had the “I really wa
ion to things that
Your brain pays attent
End it
page one” experience.
-catching, unexpected.
eresting, strange, eye
int
ry,
ina
ord
the
of
t
will
are ou
be boring. Your brain
topic doesn’t have to
l
ica
hn
tec
,
gh
tou
,
Learning a new
ly if it’s not.
learn much more quick
ething is largely
lity to remember som
now know that your abi
We
s.
ion
ot
remember when
em
You
Touch their
you care about.
t. You remember what
ten
con
al
on
his dog.
oti
and
em
y
its
bo
dependent on
ching stories about a
not talking heart-wren
’re
we
“I Rule!”
,
of
No
.
ing
ling
eth
fee
you feel som
hat the...?” , and the
prise, curiosity, fun, “w
sur
or realize
like
s
d,
on
har
oti
is
em
nks
g
We’re talkin
everybody else thi
zzle, learn something
pu
a
t.
ve
sn’
sol
doe
you
ng
en
eri
wh
ine
that comes
u” Bob from eng
more technical than tho
“I’m
t
tha
ing
eth
som
you know
xxviii

intro
Download at WoweBook.Com

the intro

Metacognition: thinking about thinking
If you really want to learn, and you want to learn more quickly and more deeply,
pay attention to how you pay attention. Think about how you think. Learn how you
learn.
Most of us did not take courses on metacognition or learning theory when we were
growing up. We were expected to learn, but rarely taught to learn.

I wonder how I
can trick my brain
into remembering
this stuff...

But we assume that if you’re holding this book, you really want to learn design
patterns. And you probably don’t want to spend a lot of time. And you want
to remember what you read, and be able to apply it. And for that, you’ve got to
understand it. To get the most from this book, or any book or learning experience, take
responsibility for your brain. Your brain on this content.
The trick is to get your brain to see the new material you’re learning as
Really Important. Crucial to your well-being. As important as a tiger.
Otherwise, you’re in for a constant battle, with your brain doing its best to
keep the new content from sticking.
So how DO you get your brain to think Design
Patterns are as important as a tiger?
There’s the slow, tedious way, or the faster, more effective way. The slow
way is about sheer repetition. You obviously know that you are able
to learn and remember even the dullest of topics, if you keep pounding on the
same thing. With enough repetition, your brain says, “This doesn’t feel important to him,
but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different
types of brain activity. The things on the previous page are a big part of the solution,
and they’re all things that have been proven to help your brain work in your favor. For
example, studies show that putting words within the pictures they describe (as opposed to
somewhere else in the page, like a caption or in the body text) causes your brain to try to
makes sense of how the words and picture relate, and this causes more neurons to ﬁre.
More neurons ﬁring = more chances for your brain to get that this is something worth
paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they
perceive that they’re in a conversation, since they’re expected to follow along and hold up
their end. The amazing thing is, your brain doesn’t necessarily care that the “conversation”
is between you and a book! On the other hand, if the writing style is formal and dry, your
brain perceives it the same way you experience being lectured to while sitting in a roomful
of passive attendees. No need to stay awake.
But pictures and conversational style are just the beginning.

you are here4
Download at WoweBook.Com

xxix

how to use this book

Here’s what WE did:
8

8

Su
bje

int

ct Obje

ct
Dog Obje

8
8
8

Duck Obje

Mo

Automatic update/notification

ct

Cat Object

ec
use Obj

t

Observers

Dependen
t Objects

We used redundancy, saying the same thing in different ways and with different media types,
and multiple senses, to increase the chance that the content gets coded into more than one area of
your brain.

ONE TO MANY RELATIONSHIP
Object that
holds state

ct

We used pictures, because your brain is tuned for visuals, not text. As far as your brain’s
concerned, a picture really is worth 1024 words. And when text and pictures work together, we
embedded the text in the pictures because your brain works more effectively when the text is
within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.

We used concepts and pictures in unexpected ways because your brain is tuned for novelty,
and we used pictures and ideas with at least some emotional content, because your brain is
tuned to pay attention to the biochemistry of emotions. That which causes you to feel something
is more likely to be remembered, even if that feeling is nothing more than a little humor,
surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more
attention when it believes you’re in a conversation than if it thinks you’re passively listening to a
presentation. Your brain does this even when you’re reading.

The Patterns Guru

We included more than 40 activities, because your brain is tuned to learn and remember
more when you do things than when you read about things. And we made the exercises
challenging-yet-do-able, because that’s what most people prefer.
We used multiple learning styles, because you might prefer step-by-step procedures, while
someone else wants to understand the big picture ﬁrst, while someone else just wants to see a
code example. But regardless of your own learning preference, everyone beneﬁts from seeing the
same content represented in multiple ways.
We include content for both sides of your brain, because the more of your brain you
engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of the brain often means giving the other side a chance to rest, you can
be more productive at learning for a longer period of time.
And we included stories and exercises that present more than one point of view, because
your brain is tuned to learn more deeply when it’s forced to make evaluations and judgements.
We included challenges, with exercises, and by asking questions that don’t always have
a straight answer, because your brain is tuned to learn and remember when it has to work at
something. Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things. That
you’re not spending one extra dendrite processing a hard-to-understand example, or
parsing difﬁcult, jargon-laden, or overly terse text.
We used people. In stories, examples, pictures, etc., because, well, because you’re a person. And
your brain pays more attention to people than it does to things.
We used an 80/20 approach. We assume that if you’re going for a PhD in software design, this
won’t be your only book. So we don’t talk about everything. Just the stuff you’ll actually need.

xxx

intro
Download at WoweBook.Com

BULLET POINTS

Puzzles

the intro

Here’s what YOU can do to bend
your brain into submission
So, we did our part. The rest is up to you. These tips are a
starting point; listen to your brain and ﬁgure out what works
for you and what doesn’t. Try new things.

cut this out
on your refriganerdatstick it
or.
1

Slow down. The more you understand,
the less you have to memorize.

7

Speaking activates a different part of the brain.
If you’re trying to understand something, or
increase your chance of remembering it later, say
it out loud. Better still, try to explain it out loud
to someone else. You’ll learn more quickly, and
you might uncover ideas you hadn’t known were
there when you were reading about it.

Don’t just read. Stop and think. When the
book asks you a question, don’t just skip to the
answer. Imagine that someone really is asking
the question. The more deeply you force your
brain to think, the better chance you have of
learning and remembering.
2

Do the exercises. Write your own notes.

We put them in, but if we did them for you,
that would be like having someone else do
your workouts for you. And don’t just look at
the exercises. Use a pencil. There’s plenty of
evidence that physical activity while learning
can increase the learning.
3

Make this the last thing you read before
bed. Or at least the last challenging thing.

Part of the learning (especially the transfer to
long-term memory) happens after you put the
book down. Your brain needs time on its own, to
do more processing. If you put in something new
during that processing-time, some of what you
just learned will be lost.
6

8

Listen to your brain.

Pay attention to whether your brain is getting
overloaded. If you ﬁnd yourself starting to skim the
surface or forget what you just read, it’s time for a
break. Once you go past a certain point, you won’t
learn faster by trying to shove more in, and you
might even hurt the process.

Read the “There are No Dumb Questions”

That means all of them. They’re not optional
side-bars—they’re part of the core content!
Don’t skip them.
5

Talk about it. Out loud.

9

Feel something!

Your brain needs to know that this matters. Get
involved with the stories. Make up your own captions for the photos. Groaning over a bad joke is still
better than feeling nothing at all.
10 Design something!
Apply this to something new you’re designing, or
refactor an older project. Just do something to get
some experience beyond the exercises and activities
in this book. All you need is a pencil and a problem
to solve... a problem that might beneﬁt from one or
more design patterns.

Drink water. Lots of it.

Your brain works best in a nice bath of ﬂuid. Dehydration (which can happen before you ever feel
thirsty) decreases cognitive function.
you are here4
Download at WoweBook.Com

xxxi

how to use this book

Read Me
This is a learning experience, not a reference book. We deliberately stripped out
everything that might get in the way of learning whatever it is we’re working on at that
point in the book. And the ﬁrst time through, you need to begin at the beginning, because
We
the book makes assumptions about what you’ve already seen and learned.

r,
use a simaupxle-UML
modified f

We use simple UML-like diagrams.
Although there’s a good chance you’ve run across UML, it’s not covered in the book, and
it’s not a prerequisite for the book. If you’ve never seen UML before, don’t worry, we’ll
give you a few pointers along the way. So in other words, you won’t have to worry about
Design Patterns and UML at the same time. Our diagrams are “UML-like” -- while we
try to be true to UML there are times we bend the rules a bit, usually for our own selﬁsh
artistic reasons.
We don’t cover every single Design Pattern ever created.
There are a lot of Design Patterns: The original foundational patterns (known as the GoF
patterns), Sun’s J2EE patterns, JSP patterns, architectural patterns, game design patterns
and a lot more. But our goal was to make sure the book weighed less than the person
reading it, so we don’t cover them all here. Our focus is on the core patterns that matter
from the original GoF patterns, and making sure that you really, truly, deeply understand
how and when to use them. You will ﬁnd a brief look at some of the other patterns (the
ones you’re far less likely to use) in the appendix. In any case, once you’re done with Head
First Design Patterns, you’ll be able to pick up any pattern catalog and get up to speed
quickly.
The activities are NOT optional.
The exercises and activities are not add-ons; they’re part of the core content of the book.
Some of them are to help with memory, some for understanding, and some to help you
apply what you’ve learned. Don’t skip the exercises. The crossword puzzles are the
only things you don’t have to do, but they’re good for giving your brain a chance to think
about the words from a different context.
We use the word “composition” in the general OO sense, which is
more ﬂexible than the strict UML use of “composition”.
When we say “one object is composed with another object” we mean that they are related
by a HAS-A relationship. Our use reﬂects the traditional use of the term and is the one
used in the GoF text (you’ll learn what that is later). More recently, UML has reﬁned
this term into several types of composition. If you are an UML expert, you’ll still be able
to read the book and you should be able to easily map the use of composition to more
reﬁned terms as you read.
xxxii

intro
Download at WoweBook.Com

Director
getMovies
getOscars()
getKevinBaconDegrees()

the intro

The redundancy is intentional and important.
One distinct difference in a Head First book is that we want you to really get it. And we want
you to ﬁnish the book remembering what you’ve learned. Most reference books don’t have
retention and recall as a goal, but this book is about learning, so you’ll see some of the same
concepts come up more than once.
The code examples are as lean as possible.
Our readers tell us that it’s frustrating to wade through 200 lines of code looking for the two
lines they need to understand. Most examples in this book are shown within the smallest
possible context, so that the part you’re trying to learn is clear and simple. Don’t expect
all of the code to be robust, or even complete—the examples are written speciﬁcally for
learning, and aren’t always fully-functional.
In some cases, we haven’t included all of the import statements needed, but we assume that
if you’re a Java programmer, you know that ArrayList is in java.util, for example. If the
imports were not part of the normal core J2SE API, we mention it. We’ve also placed all
the source code on the web so you can download it. You’ll ﬁnd it at
http://www.headﬁrstlabs.com/books/hfdp/

Also, for the sake of focusing on the learning side of the code, we did not put our classes
into packages (in other words, they’re all in the Java default package). We don’t recommend
this in the real world, and when you download the code examples from this book, you’ll ﬁnd
that all classes are in packages.
The ‘Brain Power’ exercises don’t have answers.
For some of them, there is no right answer, and for others, part of the learning experience
of the Brain Power activities is for you to decide if and when your answers are right. In
some of the Brain Power exercises you will ﬁnd hints to point you in the right direction.

you are here4 xxxiii
Download at WoweBook.Com

the early review team

Tech Reviewers

Valentin Crettaz

Jef Cumps

Barney Marispini

Ike Van Atta

Fearless leader of
the HFDP Extreme
Review Team.

Johannes deJong

zler

Mark Sprit

Dirk Schreckmann
xxxiv

intro
Download at WoweBook.Com

Jason Menard

the intro

In memory of Philie Maqu
1960-2004
Your amazing technical expertise, relentless enthusiasm, and
deep concern for the learner will inspire us always.
We will never forget you.

Philippe Maquet

Acknowledgments
At O’Reilly:
Our biggest thanks to Mike Loukides at O’Reilly, for starting it all, and helping to shape the Head
First concept into a series. And a big thanks to the driving force behind Head First, Tim O’Reilly.
Thanks to the clever Head First “series mom” Kyle Hart, to rock and roll star Ellie Volkhausen for
her inspired cover design and also to Colleen Gorman for her hardcore copyedit. Finally, thanks to
Mike Hendrickson for championing this Design Patterns book, and building the team.
Our intrepid reviewers:
We are extremely grateful for our technical review director Johannes deJong. You are our hero,
Johannes. And we deeply appreciate the contributions of the co-manager of the Javaranch review
team, the late Philippe Maquet. You have single-handedly brightened the lives of thousands of
developers, and the impact you’ve had on their (and our) lives is forever.
Jef Cumps is scarily good at ﬁnding problems in our draft chapters, and once again made a huge
difference for the book. Thanks Jef ! Valentin Cretaz (AOP guy), who has been with us from the
very ﬁrst Head First book, proved (as always) just how much we really need his technical expertise
and insight. You rock Valentin (but lose the tie).
Two newcomers to the HF review team, Barney Marispini and Ike Van Atta did a kick butt job on
the book—you guys gave us some really crucial feedback. Thanks for joining the team.
We also got some excellent technical help from Javaranch moderators/gurus Mark Spritzler,
Jason Menard, Dirk Schreckmann, Thomas Paul, and Margarita Isaeva. And as always,
thanks especially to the javaranch.com Trail Boss, Paul Wheaton.
Thanks to the ﬁnalists of the Javaranch “Pick the Head First Design Patterns Cover” contest. The
winner, Si Brewster, submitted the winning essay that persuaded us to pick the woman you see on
our cover. Other ﬁnalists include Andrew Esse, Gian Franco Casula, Helen Crosbie, Pho Tek, Helen
Thomas, Sateesh Kommineni, and Jeff Fisher.

you are here4 xxxv
Download at WoweBook.Com

still more acknowledgments

Even more people*
From Eric and Elisabeth
Writing a Head First book is a wild ride with two amazing tour guides: Kathy Sierra and
Bert Bates. With Kathy and Bert you throw out all book writing convention and enter a world
full of storytelling, learning theory, cognitive science, and pop culture, where the reader always
rules. Thanks to both of you for letting us enter your amazing world; we hope we’ve done Head
First justice. Seriously, this has been amazing. Thanks for all your careful guidance, for pushing
us to go forward and most of all, for trusting us (with your baby). You’re both certainly “wickedly
smart” and you’re also the hippest 29 year olds we know. So... what’s next?
A big thank you to Mike Loukides and Mike Hendrickson. Mike L. was with us every
step of the way. Mike, your insightful feedback helped shape the book and your encouragement
kept us moving ahead. Mike H., thanks for your persistence over ﬁve years in trying to get us to
write a patterns book; we ﬁnally did it and we’re glad we waited for Head First.
A very special thanks to Erich Gamma, who went far beyond the call of duty in reviewing
this book (he even took a draft with him on vacation). Erich, your interest in this book inspired
us and your thorough technical review improved it immeasurably. Thanks as well to the entire
Gang of Four for their support & interest, and for making a special appearance in Objectville.
We are also indebted to Ward Cunningham and the patterns community who created the
Portland Pattern Repository – an indespensible resource for us in writing this book.
It takes a village to write a technical book: Bill Pugh and Ken Arnold gave us expert advice
on Singleton. Joshua Marinacci provided rockin’ Swing tips and advice. John Brewer’s
“Why a Duck?” paper inspired SimUDuck (and we’re glad he likes ducks too). Dan Friedman
inspired the Little Singleton example. Daniel Steinberg acted as our “technical liason” and
our emotional support network. And thanks to Apple’s James Dempsey for allowing us to use
his MVC song.
Last, a personal thank you to the Javaranch review team for their top-notch reviews and
warm support. There’s more of you in this book than you know.

From Kathy and Bert
We’d like to thank Mike Hendrickson for ﬁnding Eric and Elisabeth... but we can’t. Because of
these two, we discovered (to our horror) that we aren’t the only ones who can do a Head First
book. ; ) However, if readers want to believe that it’s really Kathy and Bert who did the cool things
in the book, well, who are we to set them straight?

*The large number of acknowledgments is because we’re testing the theory
that everyone mentioned in a book acknowledgment will buy at least one copy,
probably more, what with relatives and everything. If you’d like to be in the
acknowledgment of our next book, and you have a large family, write to us.

xxxvi

intro
Download at WoweBook.Com

1 Intro to Design Patterns

h

Welcome to
g
g
Design Patterns
Now that we’re living
in Objectville, we’ve just got
to get into Design Patterns...
everyone is doing them. Soon
we’ll be the hit of Jim and
Betty’s Wednesday night
patterns group!

Someone has already solved your problems. In this chapter, you’ll learn
why (and how) you can exploit the wisdom and lessons learned by other developers who’ve
been down the same design problem road and survived the trip. Before we’re done, we’ll
look at the use and beneﬁts of design patterns, look at some key OO design principles, and
walk through an example of how one pattern works. The best way to use patterns is to load
your brain with them and then recognize places in your designs and existing applications
where you can apply them. Instead of code reuse, with patterns you get experience reuse.

this is a new chapter
Download at WoweBook.Com

1

SimUDuck

It started with a simple SimUDuck app
Joe works for a company that makes a highly successful duck pond
simulation game, SimUDuck. The game can show a large variety of
duck species swimming and making quacking sounds. The initial
designers of the system used standard OO techniques and created
one Duck superclass from which all other duck types inherit.

Duck

All ducks quack and swim, the
superclass takes care of the
implementation code.

quack()
swim()
display()
// OTHER duck-like methods...

btype
u
s
k
c
du
or
Each ponsible f ts own
s
i
e
is r menting vior
imple ay() beha ks on
displ ow it loo
for h creen.
the s

MallardDuck

RedheadDuck

display() {

display() {

// looks like a mallard }

// looks like a redhead }

In the last year, the company has been under increasing pressure
from competitors. After a week long off-site brainstorming
session over golf, the company executives think it’s time for a big
innovation. They need something really impressive to show at the
upcoming shareholders meeting in Maui next week.

2

Chapter 1
Download at WoweBook.Com

is
The display() method
ck
abstract, since all du
t.
subtypes look differen

cks
types of duss.
r
e
h
t
o
f
o
s
la
Lot
the Duck c
inherit from

intro to Design Patterns

But now we need the ducks to FLY
The executives decided that ﬂying ducks is just what the
simulator needs to blow away the other duck sim competitors.
And of course Joe’s manager told them it’ll be no problem
for Joe to just whip something up in a week. “After all”, said
Joe’s boss, “he’s an OO programmer... how hard can it be?”

I just need to add a ﬂy( )
method in the Duck class and
then all the ducks will inherit it.
Now’s my time to really show my
true OO genius.

Joe

What we want.
Duck
quack()
swim()

s
classe().
b
u
s
l
Al it fly
inher

MallardDuck

ded.

display()

What Joe ad

fly()
// OTHER duck-like methods...

RedheadDuck

Other Duck

display() {

display() {

// looks like a mallard }

// looks like a redhead }

types...

you are here 4
Download at WoweBook.Com

3

something went wrong

But something went horribly wrong...
Joe, I’m at the
shareholder’s meeting.
They just gave a demo and there
were rubber duckies ﬂying around
the screen. Was this your idea of
a joke? You might want to spend
some time on Monster.com...

What happened?
Joe failed to notice that not all
subclasses of Duck should ﬂy. When
Joe added new behavior to the
Duck superclass, he was also adding
behavior that was not appropriate
for some Duck subclasses. He now
has ﬂying inanimate objects in the
SimUDuck program.

OK, so there’s a slight
ﬂaw in my design. I
don’t see why they can’t
just call it a “feature”.
It’s kind of cute...

What he thought
was a great use
of inheritance
for the purpose
of reuse hasn’t
turned out so well
when it comes to
maintenance.

A localized update to the code caused a nonlocal side effect (ﬂying rubber ducks)!
Duck

e
in th ing
)
(
y
l
fly
gf
uttin , he gave ucks,
p
y
B rclass
Ld
supe y to AL se that
abilit ding tho
inclu ldn’t.
shou

4

quack()
swim()
display()

fly()
// OTHER duck-like methods...

MallardDuck

RedheadDuck

RubberDuck

display() {
// looks like a mallard
}

display() {
// looks like a redhead
}

quack() {
// overridden to Squeak
}
display() {
// looks like a rubberduck
}

Chapter 1
Download at WoweBook.Com

don’t quack,
Rubber ducks overrridden
so quack() is
to “Squeak”.

intro to Design Patterns

Joe thinks about inheritance...
I could always just
override the ﬂy() method in
rubber duck, the way I am with
the quack() method...

But then what happens when
we add wooden decoy ducks
to the program? They aren’t
supposed to ﬂy or quack...

RubberDuck
quack() { // squeak}
display() { .// rubber duck }

fly() {
// override to do nothing
}

DecoyDuck

quack() {
// override to do nothing
}
display() { // decoy duck}

in the
ther class
Here’s ano notice that like
hierarchy; ck, it doesn’t fly,
RubberDu o doesn’t quack.
but it als

fly() {
// override to do nothing
}

Sharpen your pencil
Which of the following are disadvantages of using inheritance to
provide Duck behavior? (Choose all that apply.)

❏ A. Code is duplicated across subclasses.
❏ B. Runtime behavior changes are difﬁcult.
❏ C. We can’t make ducks dance.

❏ D. Hard to gain knowledge of all duck behaviors.
❏ E. Ducks can’t ﬂy and quack at the same time.
❏ F. Changes can unintentionally affect other ducks.

you are here 4
Download at WoweBook.Com

5

inheritance is not the answer

How about an interface?
Joe realized that inheritance probably wasn’t the
answer, because he just got a memo that says that
the executives now want to update the product every
six months (in ways they haven’t yet decided on). Joe
knows the spec will keep changing and he’ll be forced
to look at and possibly override ﬂy() and quack() for
every new Duck subclass that’s ever added to the
program... forever.

I could take the ﬂy() out of the
Duck superclass, and make a
Flyable() interface with a ﬂy()
method. That way, only the ducks that
are supposed to ﬂy will implement that
interface and have a ﬂy() method... and
I might as well make a Quackable, too,
since not all ducks can quack.

So, he needs a cleaner way to have only some (but not
all) of the duck types ﬂy or quack.

Duck
swim()
display()

Quackable

Flyable

quack()

fly()

MallardDuck
display()
fly()
quack()

// OTHER duck-like methods...

RedheadDuck
display()
fly()
quack()

RubberDuck
display()
quack()

DecoyDuck
display()

What do YOU think about this design?

6

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

That is, like, the dumbest idea
you’ve come up with. Can you say,
“duplicate code”? If you thought
having to override a few methods was bad,
how are you gonna feel when you need
to make a little change to the ﬂying
behavior... in all 48 of the ﬂying
Duck subclasses?!

What would you do if you were Joe?
We know that not all of the subclasses should have ﬂying or quacking
behavior, so inheritance isn’t the right answer. But while having
the subclasses implement Flyable and/or Quackable solves part of
the problem (no inappropriately ﬂying rubber ducks), it completely
destroys code reuse for those behaviors, so it just creates a different
maintenance nightmare. And of course there might be more than
one kind of ﬂying behavior even among the ducks that do ﬂy...
At this point you might be waiting for a Design Pattern to come
riding in on a white horse and save the day. But what fun would that
be? No, we’re going to ﬁgure out a solution the old-fashioned way—
by applying good OO software design principles.
Wouldn’t it be dreamy if
only there were a way to build
software so that when we need to
change it, we could do so with the least
possible impact on the existing code?
We could spend less time reworking
code and more making the program
do cooler things...

you are here 4
Download at WoweBook.Com

7

change is constant

The one constant in soft ware development
Okay, what’s the one thing you can always count on in software development?
No matter where you work, what you’re building, or what language you are programming in, what’s
the one true constant that will be with you always?

EGNAHC
(use a mirror to see the answer)
No matter how well you design an application, over time an
application must grow and change or it will die.

Sharpen your pencil

Lots of things can drive change. List some reasons
you’ve had to change code in your applications (we put
in a couple of our own to get you started).

My customers or users decide they want something else, or they want new functionality.
My company decided it is going with another database vendor and it is also purchasing
its data from another supplier that uses a different data format. Argh!

8

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

Zeroing in on the problem...
So we know using inheritance hasn’t worked out very well, since
the duck behavior keeps changing across the subclasses, and it’s
not appropriate for all subclasses to have those behaviors. The
Flyable and Quackable interface sounded promising at ﬁrst—only
ducks that really do ﬂy will be Flyable, etc.—except Java interfaces
have no implementation code, so no code reuse. And that means
that whenever you need to modify a behavior, you’re forced to
track down and change it in all the different subclasses where that
behavior is deﬁned, probably introducing new bugs along the way!
Luckily, there’s a design principle for just this situation.
Design Principle
Identify the aspects of your
application that vary and separate
them from what stays the same.

Our first of many design
principles. We’ll spend more time
on these thruoghout the book.
In other words, if you’ve got some aspect of your code that is
changing, say with every new requirement, then you know you’ve
got a behavior that needs to be pulled out and separated from all
the stuff that doesn’t change.

Take what varies and
“encapsulate” it so it won’t
affect the rest of your code.
The result? Fewer
unintended consequences
from code changes and more
f lexibility in your systems!

Here’s another way to think about this principle: take the parts
that vary and encapsulate them, so that later you can
alter or extend the parts that vary without affecting
those that don’t.
As simple as this concept is, it forms the basis for almost every
design pattern. All patterns provide a way to let some part of a system
vary independently of all other parts.
Okay, time to pull the duck behavior out of the Duck classes!

you are here 4
Download at WoweBook.Com

9

pull out what varies

Separating what changes from what stays the same
Where do we start? As far as we can tell, other than the problems with ﬂy() and quack(), the Duck
class is working well and there are no other parts of it that appear to vary or change frequently.
So, other than a few slight changes, we’re going to pretty much leave the Duck class alone.
Now, to separate the “parts that change from those that stay the same”, we are going to create two
sets of classes (totally apart from Duck), one for ﬂy and one for quack. Each set of classes will hold
all the implementations of their respective behavior. For instance, we might have one class that
implements quacking, another that implements squeaking, and another that implements silence.

We know that ﬂy() and quack() are the parts of the
Duck class that vary across ducks.
To separate these behaviors from the Duck class, we’ll
pull both methods out of the Duck class and create a
new set of classes to represent each behavior.

the superclass
The Duck class is still e pulling out
ar
of all ducks, but we viors and
the fly and quack beha her class
putting them into anot
structure.

each get
Now flying and quacking
s.
sse
their own set of cla

Various behavior
implementations are going
to live here.

Pull out what varies

D uc

k class

Fly

rs
ing Behavio

Qu

or
acking Behavi

Duck Behaviors

10

Chapter 1
Download at WoweBook.Com

s

intro to Design Patterns

Designing the Duck Behaviors
So how are we going to design the set of classes that
implement the ﬂy and quack behaviors?
We’d like to keep things ﬂexible; after all, it was the inﬂexibility in
the duck behaviors that got us into trouble in the ﬁrst place. And we
know that we want to assign behaviors to the instances of Duck. For
example, we might want to instantiate a new MallardDuck instance
and initialize it with a speciﬁc type of ﬂying behavior. And while
we’re there, why not make sure that we can change the behavior of
a duck dynamically? In other words, we should include behavior
setter methods in the Duck classes so that we can, say, change the
MallardDuck’s ﬂying behavior at runtime.
Given these goals, let’s look at our second design principle:

Design Principle
Program to an interface, not an
implementation.

We’ll use an interface to represent each behavior – for instance,
FlyBehavior and QuackBehavior – and each implementation of a
behavior will implement one of those interfaces.
So this time it won’t be the Duck classes that will implement the
ﬂying and quacking interfaces. Instead, we’ll make a set of classes
whose entire reason for living is to represent a behavior (for example,
“squeaking”), and it’s the behavior class, rather than the Duck class,
that will implement the behavior interface.

From now on, the Duck
behaviors will live in a
separate class—a class that
implements a particular
behavior interface.
That way, the Duck classes
won’t need to know any of
the implementation details
for their own behaviors.

This is in contrast to the way we were doing things before, where
a behavior either came from a concrete implementation in the
superclass Duck, or by providing a specialized implementation in the
subclass itself. In both cases we were relying on an implementation. We
were locked into using that speciﬁc implementation and there was no
room for changing out the behavior (other than writing more code).
With our new design, the Duck subclasses will use a behavior
represented by an interface (FlyBehavior and QuackBehavior), so that
the actual implementation of the behavior (in other words, the speciﬁc
concrete behavior coded in the class that implements the FlyBehavior
or QuackBehavior) won’t be locked into the Duck subclass.

<<interface>>

FlyBehavior
fly()

FlyWithWings
fly() {

FlyNoWay
fly() {

// implements duck flying
}

// do nothing - can’t fly!
}

you are here 4
Download at WoweBook.Com

11

program to an interface

I don’t see why you have to
use an interface for FlyBehavior.
You can do the same thing with an
abstract superclass. Isn’t the
whole point to use polymorphism?

“Program to an interface” really means
“Program to a supertype.”
The word interface is overloaded here. There’s the concept of
interface, but there’s also the Java construct interface. You
can program to an interface, without having to actually use a
Java interface. The point is to exploit polymorphism by
programming to a supertype so that the actual runtime object
isn’t locked into the code. And we could rephrase “program to
a supertype” as “the declared type of the variables should be a
supertype, usually an abstract class or interface, so that the objects
assigned to those variables can be of any concrete implementation
of the supertype, which means the class declaring them doesn’t
have to know about the actual object types!”
This is probably old news to you, but just to make sure we’re
all saying the same thing, here’s a simple example of using a
polymorphic type – imagine an abstract class Animal, with two
concrete implementations, Dog and Cat.
Programming to an implementation would be:

abstra
be an acbt supertype (co
interfac stract class ORuld
e)

Dog d = new Dog();
d.bark();

Animal

Declaring the variable “d”
e Dog
(a concrete implementation asoftyp
Ani
forces us to code to a concrete mal)
implementation.

But programming to an interface/supertype would be:

makeSound()

We know it’s

Animal animal = new Dog(); we can now a Dog, but
use the animal
animal.makeSound();
reference polymorphically

.

concrete
ions
implementat
Dog
makeSound() {
bark();
}
bark() { // bark sound }

12

Even better, rather than hard-coding the instantiation of the
subtype (like new Dog()) into the code, assign the concrete
implementation object at runtime:
Cat
makeSound() {
meow();
}
meow() { // meow sound }

a = getAnimal();
a.makeSound();

Chapter 1
Download at WoweBook.Com

We don’t know WHAT the ual
animal subtype is... all we caract
e about
is that it knows how to respond
to
makeSound().

intro to Design Patterns

Implementing the Duck Behaviors
Here we have the two interfaces, FlyBehavior and QuackBehavior along with
the corresponding classes that implement each concrete behavior:

r the quack
Same thing here foan interface
behavior; we have a quack()
that just includes s to be
method that need
implemented.

at
face th ll
r
e
t
in
A
an
avior is
lement.
FlyBeh g classes imp st need to
all flyinying classes ju ethod.
new fl nt the fly m
impleme

<<interface>>

<<interface>>

QuackBehavior

FlyBehavior

quack()

fly()

FlyWithWings
fly() {

FlyNoWay
fly() {

// implements duck flying
}

Quack
quack() {

// do nothing - can’t fly!
}

Squeak

// implements duck quacking
}

Quac
really ks that
And here
quack
all ducks ’s the implementa
.
Here’s t
t
t
io
h
a
n
t
f
c
o
h
a
r
n
e
’t
im
f
ly.
plement
of flyin
that ha g for all duc ation
ks
ve wings
.

MuteQuack

quack() {

quack() {

// rubber duckie squeak
}

Quacks that squeak.

With this design, other types of objects can
reuse our ﬂy and quack behaviors because
these behaviors are no longer hidden away
in our Duck classes!
And we can add new behaviors without
modifying any of our existing behavior
classes or touching any of the Duck classes
that use ﬂying behaviors.

// do nothing - can’t quack!
}

Quacks that make
no sound at all.

of
benefit
e
h
t
t
e
e
So we g without all th ng
REUSE that comes alo
baggage eritance.
with inh

you are here 4
Download at WoweBook.Com

13

behavior in a class

there are no

Dumb Questions

Q:

Q:

Do I always have to implement my application first, see
where things are changing, and then go back and separate &
encapsulate those things?

It feels a little weird to have a class that’s just a
behavior. Aren’t classes supposed to represent things? Aren’t
classes supposed to have both state AND behavior?

A:

A:

Not always; often when you are designing an application,
you anticipate those areas that are going to vary and then go ahead
and build the flexibility to deal with it into your code. You’ll find
that the principles and patterns can be applied at any stage of the
development lifecycle.

Q:
A:

In an OO system, yes, classes represent things that
generally have both state (instance variables) and methods. And in
this case, the thing happens to be a behavior. But even a behavior
can still have state and methods; a flying behavior might have
instance variables representing the attributes for the flying (wing
beats per minute, max altitude and speed, etc.) behavior.

Should we make Duck an interface too?

Not in this case. As you’ll see once we’ve got everything
hooked together, we do benefit by having Duck not be an interface
and having specific ducks, like MallardDuck, inherit common
properties and methods. Now that we’ve removed what varies from
the Duck inheritance, we get the benefits of this structure without
the problems.

Sharpen your pencil
Using our new design, what would you do if you needed to
add rocket-powered ﬂying to the SimUDuck app?

2

Can you think of a class that might want to use the Quack
behavior that isn’t a duck?

2) One example, a duck call (a
device that makes duck sounds).

1

1) Create a FlyRocketPowered class
that implements the FlyBehavior
interface.
Answers:

14

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

Integrating the Duck Behavior
The key is that a Duck will now delegate its ﬂying
and quacking behavior, instead of using quacking and
ﬂying methods deﬁned in the Duck class (or subclass).
Here’s how:
1

First we’ll add two instance variables to the Duck class called ﬂyBehavior and
quackBehavior, that are declared as the interface type (not a concrete class implementation
type). Each duck object will set these variables polymorphically to reference the speciﬁc
behavior type it would like at runtime (FlyWithWings, Squeak, etc.).
We’ll also remove the ﬂy() and quack() methods from the Duck class (and any subclasses)
because we’ve moved this behavior out into the FlyBehavior and QuackBehavior classes.
We’ll replace ﬂy() and quack() in the Duck class with two similar methods, called
performFly() and performQuack(); you’ll see how they work next.

The behavior variables are
declared as the behavior
INTERFACE type.

These methods replace
fly( ) and quack().

2

Instance variables hold a reference to
a specific behavior at runtime.
Duck
FlyBehavior flyBehavior
QuackBehavior quackBehavior

Now we implement performQuack():
public class Duck {
QuackBehavior quackBehavior;
// more

}

Fly

performQuack()
swim()
display()
performFly()
// OTHER duck-like methods...

public void performQuack() {
quackBehavior.quack();
}

rs
ing Behavio

Qu

acking Behavi

or s

Duck Behaviors

hing that
erence to sometface.
f
re
a
s
ha
k
uc
inter
Each D
QuackBehavior
implements the
vior
the quack beha t
g
lin
nd
ha
n
ha
t
es tha
Rather
k object delegat
itself, the Duc object referenced by
behavior to the
quackBehavior.

Pretty simple, huh? To perform the quack, a Duck just allows the object that
is referenced by quackBehavior to quack for it.
In this part of the code we don’t care what kind of object it is, all we care
about is that it knows how to quack()!
you are here 4
Download at WoweBook.Com

15

integrating duck behavior

More Integration...
3

Okay, time to worry about how the ﬂyBehavior and
quackBehavior instance variables are set. Let’s take a look at
the MallardDuck class:
public class MallardDuck extends Duck {
public MallardDuck() {
quackBehavior = new Quack();
ﬂyBehavior = new FlyWithWings();
}

Remember, MallardDuck inherits the quackBehavior and flyBehavior instance variables
from class Duck.

class to
uses the Quack mQuack
k
uc
D
rd
la
al
M
or
A
k, so when perf
handle its quac sponsibility for the
is called, the re ed to the Quack object
quack is delegat al quack.
and we get a re
its
lyWithWings as
And it uses F e.
FlyBehavior typ

public void display() {
System.out.println(“I’m a real Mallard duck”);
}
}

So MallardDuck’s quack is a real live duck quack, not a squeak and
not a mute quack. So what happens here? When a MallardDuck
is instantiated, its constructor initializes the MallardDuck’s inherited
quackBehavior instance variable to a new instance of type Quack (a
QuackBehavior concrete implementation class).
And the same is true for the duck’s ﬂying behavior—the MallardDuck’s
constructor initializes the ﬂyBehavior instance variable with an instance
of type FlyWithWings (a FlyBehavior concrete implementation class).

16

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

Wait a second, didn’t you
say we should NOT program to an
implementation? But what are we doing
in that constructor? We’re making a
new instance of a concrete Quack
implementation class!

Good catch, that’s exactly what we’re doing...
for now.
Later in the book we’ll have more patterns in
our toolbox that can help us ﬁx it.
Still, notice that while we are setting the
behaviors to concrete classes (by instantiating
a behavior class like Quack or FlyWithWings
and assigning it to our behavior reference
variable), we could easily change that at
runtime.
So, we still have a lot of ﬂexibility here,
but we’re doing a poor job of initializing
the instance variables in a ﬂexible way. But
think about it, since the quackBehavior
instance variable is an interface type, we
could (through the magic of polymorphism)
dynamically assign a different QuackBehavior
implementation class at runtime.
Take a moment and think about how you
would implement a duck so that its behavior
could change at runtime. (You’ll see the code
that does this a few pages from now.)

you are here 4
Download at WoweBook.Com

17

testing duck behaviors

Testing the Duck code
1 Type and compile the Duck class below (Duck.java), and the

MallardDuck class from two pages back (MallardDuck.java).
public abstract class Duck {
FlyBehavior ﬂyBehavior;
QuackBehavior quackBehavior;
public Duck() {
}

variables
Declare two reference
face types.
for the behavior inter same
the
All duck subclasses (in
.
ese
th
package) inherit

public abstract void display();
public void performFly() {
ﬂyBehavior.ﬂy();
}

Delegate to the behavior class.

public void performQuack() {
quackBehavior.quack();
}
public void swim() {
System.out.println(“All ducks ﬂoat, even decoys!”);
}
}
2 Type and compile the FlyBehavior interface (FlyBehavior.java) and

the two behavior implementation classes (FlyWithWings.java and
FlyNoWay.java).
public interface FlyBehavior {
public void ﬂy();
}

The interface that all flying
behavior classes implement.

public class FlyWithWings implements FlyBehavior {
public void ﬂy() {
System.out.println(“I’m ﬂying!!”);
}
}

public class FlyNoWay implements FlyBehavior {
public void ﬂy() {
System.out.println(“I can’t ﬂy”);
}
}

18

Chapter 1
Download at WoweBook.Com

implementation
Flying behavior DO fly...
for ducks that

Flying behavior
for ducks that implementation
rubber ducks an do NOT fly (like
d decoy ducks).

intro to Design Patterns

Testing the Duck code continued...
3 Type and compile the QuackBehavior interface

(QuackBehavior.java) and the three behavior implementation
classes (Quack.java, MuteQuack.java, and Sqeak.java).
public interface QuackBehavior {
public void quack();
}
public class Quack implements QuackBehavior {
public void quack() {
System.out.println(“Quack”);
}
}
public class MuteQuack implements QuackBehavior {
public void quack() {
System.out.println(“<< Silence >>”);
}
}
public class Squeak implements QuackBehavior {
public void quack() {
System.out.println(“Squeak”);
}
}
4 Type and compile the test class

(MiniDuckSimulator.java).
public class MiniDuckSimulator {
public static void main(String[] args) {
Duck mallard = new MallardDuck();
uck’s inherited
This calls the MallardD ich then delegates to
mallard.performQuack();
, wh
performQuack() method (i.e. calls quack() on the
mallard.performFly();
ior
av
eh
}
the object’s QuackB
avior reference).
eh
}
ck’s inherited quackB

5

Run the code!
File Edit Window Help Yadayadayada

du
ing with MallardDuck’s
Then we do the same th thod.
me
inherited performFly()

%java MiniDuckSimulator
Quack
I’m ﬂying!!
you are here 4
Download at WoweBook.Com

19

ducks with dynamic behavior

Setting behavior dynamically
What a shame to have all this dynamic talent built into our ducks and not be using
it! Imagine you want to set the duck’s behavior type through a setter method on the
duck subclass, rather than by instantiating it in the duck’s constructor.
1

Add two new methods to the Duck class:
public void setFlyBehavior(FlyBehavior fb) {
ﬂyBehavior = fb;
}

Duck
FlyBehavior flyBehavior;

public void setQuackBehavior(QuackBehavior qb) {
quackBehavior = qb;
}

QuackBehavior quackBehavior;
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()

We can call these methods anytime we want to change the
behavior of a duck on the ﬂy.

// OTHER duck-like methods...

editor note: gratuitous pun
- ﬁx

2

Make a new Duck type (ModelDuck.java).
public class ModelDuck extends Duck {
public ModelDuck() {
ﬂyBehavior = new FlyNoWay();
quackBehavior = new Quack();
}

...

ounded
k begins life gr
Our model duc fly.
to
without a way

public void display() {
System.out.println(“I’m a model duck”);
}
}

3

That’s okay, we’re creating a
rocket powered flying behavior.

Make a new FlyBehavior type
(FlyRocketPowered.java).

public class FlyRocketPowered implements FlyBehavior {
public void ﬂy() {
System.out.println(“I’m ﬂying with a rocket!”);
}
}

20

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

4

Change the test class (MiniDuckSimulator.java), add the
ModelDuck, and make the ModelDuck rocket-enabled.

public class MiniDuckSimulator {
public static void main(String[] args) {
Duck mallard = new MallardDuck();
mallard.performQuack();
mallard.performFly();

mFly() delegates
or
rf
pe
to
ll
ca
the
The first
ior object set in
to the flyBehavnstructor, which is a
ModelDuck’s co ce.
FlyNoWay instan

Duck model = new ModelDuck();
model.performFly();
model.setFlyBehavior(new FlyRocketPowered());
model.performFly();
}
}

5

Run it!

before

If it worked, the model duck
changed its flying behavior! dynamically
THAT if the implementationYou can’t do
lives inside the
duck class.

This invokes the model’s inh
eri
behavior setter method, and ted
model suddenly has rocket-p...voila! The
owered
flying capability!

File Edit Window Help Yabadabadoo

%java MiniDuckSimulator
Quack
I’m ﬂying!!

after

I can’t ﬂy
I’m ﬂying with a rocket

To change a duck’s
behavior at runtime, just
call the duck’s setter
method for that behavior.
you are here 4
Download at WoweBook.Com

21

the big picture

The Big Picture on encapsulated behaviors
Okay, now that we’ve done the deep dive on the
duck simulator design, it’s time to come back up
for air and take a look at the big picture.
Below is the entire reworked class structure. We have everything you’d expect:
ducks extending Duck, ﬂy behaviors implementing FlyBehavior and quack
behaviors implementing QuackBehavior.
Notice also that we’ve started to describe things a little differently. Instead
of thinking of the duck behaviors as a set of behaviors, we’ll start thinking of
them as a family of algorithms. Think about it: in the SimUDuck design, the
algorithms represent things a duck would do (different ways of quacking or
ﬂying), but we could just as easily use the same techniques for a set of classes
that implement the ways to compute state sales tax by different states.
Pay careful attention to the relationships between the classes. In fact, grab
your pen and write the appropriate relationship (IS-A, HAS-A and
IMPLEMENTS) on each arrow in the class diagram.

Client makes use of an
encapsulated family of algorithms
for both flying and quacking.
Client

Encapsulated ﬂy behavior
<<interface>>

FlyBehavior

h
of eac
Think behaviors
set of amily of
as a f hms.
algorit

fly()

Duck
FlyWithWings

FlyBehavior flyBehavior
QuackBehavior quackBehavior

FlyNoWay

fly() {

fly() {

// implements duck flying

swim()

}

display()

// do nothing - can’t fly!
}

performQuack()
performFly()

Encapsulated quack behavior

setFlyBehavior()
setQuackBehavior()

<<interface>>

// OTHER duck-like methods...

QuackBehavior
quack()

MallardDuck

RedheadDuck

RubberDuck

DecoyDuck

display() {

display() {

display() {

display() {

// looks like a mallard }

// looks like a redhead }

// looks like a rubberduck }

// looks like a decoy duck }

Quack
quack) {

Squeak
quack() {

// implements duck quacking
}

MuteQuack
quack() {

// rubber duckie squeak
}

// do nothing - can’t quack!
}

s
avior e
h
e
b
e
ar
Thes rithms” able.
“algo erchange
int
22

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

HAS-A can be better than IS-A
The HAS-A relationship is an interesting one: each duck
has a FlyBehavior and a QuackBehavior to which it
delegates ﬂying and quacking.
When you put two classes together like this you’re using
composition. Instead of inheriting their behavior, the
ducks get their behavior by being composed with the right
behavior object.
This is an important technique; in fact, we’ve been using
our third design principle:

Master and Student...
Master: Grasshopper,
tell me what you have
learned of the ObjectOriented ways.
Student: Master, I have learned that
the promise of the object-oriented way
is reuse.

Design Principle

Master: Grasshopper, continue...

Favor composition over inheritance.

Student: Master, through inheritance
all good things may be reused and
so we will come to drastically cut
development time like we swiftly cut
bamboo in the woods.

As you’ve seen, creating systems using composition gives you
a lot more ﬂexibility. Not only does it let you encapsulate
a family of algorithms into their own set of classes, but it
also lets you change behavior at runtime as long as
the object you’re composing with implements the correct
behavior interface.
Composition is used in many design patterns and you’ll
see a lot more about its advantages and disadvantages
throughout the book.

Master: Grasshopper, is more
time spent on code before or after
development is complete?
Student: The answer is after,
Master. We always spend more time
maintaining and changing software
than initial development.
Master: So Grasshopper, should effort
go into reuse above maintaintability
and extensibility?
Student: Master, I believe that there is
truth in this.

A

brain
power

A duck call is a device that hunters use to mimic the
calls (quacks) of ducks. How would you implement your
own duck call that does not inherit from the Duck class?

Master: I can see that you still have
much to learn. I would like for you to
go and meditate on inheritance further.
As you’ve seen, inheritance has its
problems, and there are other ways of
achieving reuse.

you are here 4
Download at WoweBook.Com

23

the strategy pattern

Speaking of Design Patterns...

Congratulations on
your first pattern!

You just applied your ﬁrst design pattern—the
STRATEGY pattern. That’s right, you used the
Strategy Pattern to rework the SimUDuck app.
Thanks to this pattern, the simulator is ready for any
changes those execs might cook up on their next
business trip to Vegas.
Now that we’ve made you take the long road to apply it,
here’s the formal deﬁnition of this pattern:

The Strategy Pattern deﬁnes a family of algorithms,
encapsulates each one, and makes them interchangeable.
Strategy lets the algorithm vary independently from
clients that use it.

24

Chapter 1
Download at WoweBook.Com

ou
when yd
n
o
i
t
i
fin iends an
HIS de
r
Use T o impress f utives.
t
e
d
x
nee ce key e c
influen

intro to Design Patterns

Design Puzzle
Below you’ll ﬁnd a mess of classes and interfaces for an action adventure game. You’ll
ﬁnd classes for game characters along with classes for weapon behaviors the characters
can use in the game. Each character can make use of one weapon at a time, but can
change weapons at any time during the game. Your job is to sort it all out...
(Answers are at the end of the chapter.)

Your task:
1 Arrange the classes.
1.

2
2. Identify one abstract class, one interface and eight classes.

3
3. Draw arrows between classes.

a. Draw this kind of arrow for inheritance (“extends”).
b. Draw this kind of arrow for interface (“implements”).
c. Draw this kind of arrow for “HAS-A”.
4 Put the method setWeapon() into the right class.
4.

Character
WeaponBehavior weapon;
fight();

BowAndArrowBehavior

KnifeBehavior
useWeapon() { // implements cutting
with a knife }
<<interface>>

Queen

useWeapon() { // implements shooting an arrow with a bow }

WeaponBehavior

fight() { ... }

useWeapon();

King
fight() { ... }

Troll
fight() { ... }

Knight
fight() { ... }

AxeBehavior
useWeapon() { // implements chopping with an axe }

SwordBehavior
useWeapon() { // implements swinging a sword }

setWeapon(WeaponBehavior w) {
this.weapon = w;
}

you are here 4
Download at WoweBook.Com

25

diner talk

Overheard at the local diner...
Alice
I need a Cream cheese
with jelly on white bread, a
chocolate soda with vanilla ice cream, a
grilled cheese sandwich with bacon, a tuna
ﬁsh salad on toast, a banana split with
ice cream & sliced bananas and a coffee
with a cream and two sugars, ... oh,
and put a hamburger on the grill!

Flo
Give me a C.J.
White, a black & white, a
Jack Benny, a radio, a house
boat, a coffee regular and
burn one!

What’s the difference between these two orders? Not a thing! They’re both
the same order, except Alice is using twice the number of words and trying the
patience of a grumpy short order cook.
What’s Flo got that Alice doesn’t? A shared vocabulary with the short order
cook. Not only is it easier to communicate with the cook, but it gives the cook less
to remember because he’s got all the diner patterns in his head.
Design Patterns give you a shared vocabulary with other developers. Once you’ve
got the vocabulary you can more easily communicate with other developers and
inspire those who don’t know patterns to start learning them. It also elevates your
thinking about architectures by letting you think at the pattern level, not the
nitty gritty object level.
26

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

Overheard in the next cubicle...
So I created this broadcast
class. It keeps track of all
the objects listening to it and anytime
a new piece of data comes along it sends a
message to each listener. What’s cool is that
the listeners can join the broadcast at any
time or they can even remove themselves.
It is really dynamic and loosely-coupled!

Rick

A

brain
power

Can you think of other shared vocabularies
that are used beyond OO design and diner
talk? (Hint: how about auto mechanics,
carpenters, gourmet chefs, air trafﬁc control)
What qualities are communicated along with
the lingo?

Can you think of aspects of OO design
that get communicated along with pattern
names? What qualities get communicated
along with the name “Strategy Pattern”?

Exactly. If you
communicate in patterns,
then other developers know
immediately and precisely the
design you’re describing. Just don’t
get Pattern Fever... you’ll know
you have it when you start using
patterns for Hello
World...

Rick, why
didn’t you just say
you were using the
Observer Pattern?

you are here 4
Download at WoweBook.Com

27

shared vocabulary

The power of a shared pattern vocabulary
When you communicate using patterns you
are doing more than just sharing LINGO.

Shared pattern vocabularies are POWERFUL.
When you communicate with another developer or your
team using patterns, you are communicating not just a
pattern name but a whole set of qualities, characteristics
and constraints that the pattern represents.

leern to imp.”
t
t
a
p
y
g
e
t
cks
g the stra
of our du
“We’re usin various behaviors avior has been
ment the you the duck beh t of classes
This tells ed into its own se and changed,
encapsulatbe easily expanded
that can untime if needed.
Patterns allow you to say more with less. When
even at r
you use a pattern in a description, other developers quickly
know precisely the design you have in mind.
Talking at the pattern level allows you to stay “in
the design” longer. Talking about software systems using
patterns allows you to keep the discussion at the design
level, without having to dive down to the nitty gritty details
of implementing objects and classes.
Shared vocabularies can turbo charge your
development team. A team well versed in design
patterns can move more quickly with less room for
misunderstanding.
Shared vocabularies encourage more junior
developers to get up to speed. Junior developers look
up to experienced developers. When senior developers
make use of design patterns, junior developers also become
motivated to learn them. Build a community of pattern
users at your organization.

28

u
ave yo
h
s
g
n
i
eet
into
esign m ly degrade
d
y
n
a
k
How m n that quic tails?
been i entation de
implem

share design
As your team begins toin terms of
ideas and experience a community
patterns, you will build
of patterns users.
Think about starting a patterns study
group at your organization, maybe you
can even get paid while you’re learning... ; )

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

How do I use Design Patterns?
We’ve all used off-the-shelf libraries and frameworks. We take them, write some code against their APIs,
compile them into our programs, and beneﬁt from a lot of code someone else has written. Think about
the Java APIs and all the functionality they give you: network, GUI, IO, etc. Libraries and frameworks go
a long way towards a development model where we can just pick and choose components and plug them
right in. But... they don’t help us structure our own applications in ways that are easier to understand, more
maintainable and ﬂexible. That’s where Design Patterns come in.
Design patterns don’t go directly into your code, they ﬁrst go into your BRAIN. Once you’ve loaded your
brain with a good working knowledge of patterns, you can then start to apply them to your new designs,
and rework your old code when you ﬁnd it’s degrading into an inﬂexible mess of jungle spaghetti code.

AIN

vior

y beha
lated ﬂ

Encapsu

Your BR

>
<<interface> r
havio

FlyBe

fly()

FlyNoWay

gs

FlyWithWin

fly() {
fly!
g - can’t
// do nothin

fly() {
flying
ents duck
// implem

Duck

>

<<interface>

vior

QuackBeha

()

performQuack
performFly()

quack()

r()
setFlyBehavio
avior()
setQuackBeh
methods...
duck-like
// OTHER

MuteQuack
Squeak
Quack
Decoy Duck

Rubber
Duck

Redhead

Duck

{
display()
d}
a redhea
// looks like

int

{
display()
}
a rubberduck
// looks like

quack() {
k
duckie squea
// rubber

quack() {
quack!
g - can’t
// do nothin
}

}

}

OBSERVER

8

8

Su
bje

quack) {
quacking
ents duck
// implem

{
display()
duck }
a decoy
// looks like

ct Obje

ct
Dog Obje

8
8
8

c
Duck Obje

Mo

Automatic update/notification

t

Cat Object

e
use Obj

ct
Observers

r
trolle

Con

Objects

Mallard

{
display()
}
a mallard
// looks like

Duck

MVC

Dependent

Object that
holds state

ct

A Bunch of Patterns

havior

ack be

lated qu

Encapsu

swim()
display()

}

}

flyBehavior;
FlyBehavior
Behavior;
ior quack
QuackBehav

Client

el

Mod

est
Requ

View

new
Your Code, now ith
and improved w !
design patterns

there are no

Dumb Questions

Q:

Q:

Aren’t libraries and frameworks
also design patterns?

understand APIs that are structured
around design patterns.

A:

A:

Q:

If design patterns are so great,
why can’t someone build a library of
them so I don’t have to?

Design patterns are higher level
than libraries. Design patterns tell us
how to structure classes and objects to
solve certain problems and it is our job to
adapt those designs to fit our particular
application.

Frameworks and libraries are not
design patterns; they provide specific
implementations that we link into our
code. Sometimes, however, libraries and
frameworks make use of design patterns
in their implementations. That’s great,
because once you understand design
patterns, you’ll more quickly

So, there are no libraries of
design patterns?

A:

No, but you will learn later about
pattern catalogs with lists of patterns that
you can apply to your applications.

you are here 4
Download at WoweBook.Com

29

why design patterns?

Patterns are
nothing more than using
OO design principles...
A common misconception,
Grasshopper, but it’s more
subtle than that. You have
much to learn...

Friendly
Patterns Guru

Skeptical Developer

Developer: Okay, hmm, but isn’t this all just good object-oriented design; I mean
as long as I follow encapsulation and I know about abstraction, inheritance, and
polymorphism, do I really need to think about Design Patterns? Isn’t it pretty
straightforward? Isn’t this why I took all those OO courses? I think Design
Patterns are useful for people who don’t know good OO design.
Guru: Ah, this is one of the true misunderstandings of object-oriented
development: that by knowing the OO basics we are automatically going to be good at
building ﬂexible, reusable, and maintainable systems.
Developer: No?
Guru: No. As it turns out, constructing OO systems that have these properties is
not always obvious and has been discovered only through hard work.
Developer: I think I’m starting to get it. These, sometimes non-obvious, ways of
constructing object-oriented systems have been collected...
Guru: ...yes, into a set of patterns called Design Patterns.
Developer: So, by knowing patterns, I can skip the hard work and jump straight to
designs that always work?
Guru: Yes, to an extent, but remember, design is an art. There will always be
tradeoffs. But, if you follow well thought-out and time-tested design patterns, you’ll
be way ahead.
Developer: What do I do if I can’t ﬁnd a pattern?

30

Chapter 1
Download at WoweBook.Com

intro to Design Patterns

Remember, knowing
concepts like abstraction,
inheritance, and polymorphism do
not make you a good object oriented
designer. A design guru thinks about
how to create ﬂexible designs that
are maintainable and that can
cope with change.

Guru: There are some object oriented-principles that
underlie the patterns, and knowing these will help you
to cope when you can’t ﬁnd a pattern that matches your
problem.
Developer: Principles? You mean beyond abstraction,
encapsulation, and...
Guru: Yes, one of the secrets to creating maintainable
OO systems is thinking about how they might change in the
future and these principles address those issues.

you are here 4
Download at WoweBook.Com

31

your design toolbox

Tools for your Design Toolbox
You’ve nearly made it through the ﬁrst
chapter! You’ve already put a few tools
in your OO toolbox; let’s make a list of
them before we move on to Chapter 2.

OO Basics

Abstraction
n
Encapsulatio
m
Polymorphis
Inheritance

s
OO Principle

asics
the OO b y,
w
o
n
k
u
e yo
icall
We assum classes polymorph sign by
e
of using ritance is like d ulation
how inhe , and how encaps rusty
contract you are a little ad First
works. If, pull out your He this
on these review, then skim
Java and again.
chapter

ß Knowing the OO basics
does not make you a good
OO designer.

ß Good OO designs are
reusable, extensible and
maintainable.

ß Patterns show you how to
build systems with good
OO design qualities.

ß Patterns are proven objectoriented experience.

ß Patterns don’t give you

.
what varies
e
t
la
u
s
p
a
c
n
E
osition over
Favor comp
inheritence.
faces, not
r
e
t
in
o
t
m
Progra
ions.
implementat

at
g a closer looklso
in
k
a
t
e
b
ll
e’
W
e road and a
these down th more to the list
adding a few

code, they give you
general solutions to design
problems. You apply them
to your specific application.

ß Patterns aren’t invented,
they are discovered.

ß Most patterns and

OO Patterns amily of algorithms,

Throughout the
book think about
how patterns rely
on OO basics and
principles.

f
- defines ,a and makes them ithm
y
g
e
t
a
r
t
S
each one
the algor
encapsulatgeesable. Strategy lettss that use it.
interchan endently from clien
vary indep

One down, many to go !

32

BULLET POINTS

Chapter 1
Download at WoweBook.Com

principles address issues of
change in software.

ß Most patterns allow some
part of a system to vary
independently of all other
parts.

ß We often try to take what
varies in a system and
encapsulate it.

ß Patterns provide a
shared language that can
maximize the value of your
communication with other
developers.

intro to Design Patterns

�

Let’s give your right brain something to do.
�

�

It’s your standard crossword; all of the solution words
are from this chapter.
�
�
�

�

�

�
�

��

��

��
�

�

��

�
�

�

�

�
�
��

��

��

��

��

��

��
��

��

��

��

��

��

��
��

��

��
��

Across

2. _______ what varies
4. Design patterns _____
6. Java
IO, varies
Networking, Sound
2. _______
what
9. Rubberducks
make a
4. Design13.
patterns
Bartender_____
thought they were called
15.
Program
to
this,
not
an implementation
6. Java IO,17.Networking,
Sound
Patterns go into your _______
9. Rubberducks
18. Learn make
from theaother guy's
19. Development
13. Bartender
thoughtconstant
they were called
20. Patterns
givenot
us a an
shared
_______
15. Program
to this,
implementation

Across

17. Patterns go into your _______
18. Learn from the other guy's
19. Development constant
20. Patterns give us a shared _______

Down

1. Patterns ____ in many applications
3. Favor over inheritance
5. Dan was
with ____
this pattern
1. thrilled
Patterns
many applications
7. Most patterns
follow from
OOin_______
3. Favor
over inheritance
8. Not your
own
10. High5.
level
libraries
Dan was thrilled with this pattern
11. Joe's favorite drink
7. that
Most
patterns
follow from OO _______
12. Pattern
fixed
the simulator
13. Duck8.
that
can'tyour
quackown
Not
14. Grilled
cheese
with
bacon
High
level libraries
16. Duck10.
demo
was located
where

Down

11.
12.
13.
14.
16.

Joe's favorite drink
Pattern that fixed the simulator
Duck that can't quack
Grilled cheese with bacon
Duck demo was located where

you are here 4
Download at WoweBook.Com

33

design puzzle solution

Design Puzzle Solution
Character is the abstract class for all the other characters (King, Queen,
Knight and Troll) while Weapon is an interface that all weapons
implement. So all actual characters and weapons are concrete classes.
To switch weapons, each character calls the setWeapon() method, which
is deﬁned in the Character superclass. During a ﬁght the useWeapon()
method is called on the current weapon set for a given character to inﬂict
great bodily damage on another character.

abstract
Character
WeaponBehavior weapon;
fight();
setWeapon(WeaponBehavior w) {
this.weapon = w;
}

King
fight() { ... }

A Character HAS-A
WeaponBehavior.

Knight
fight() { ... }

Troll

Queen
fight() { ... }

fight() { ... }

<<interface>>
WeaponBehavior
useWeapon();

BowAndArrowBehavior

SwordBehavior
useWeapon() { // implements swinging a sword }

useWeapon() { // implements shooting an arrow with a bow }

KnifeBehavior

ment
could impleay, a
t
c
je
b
o
Y
S
AN
e.
Note that nBehavior interfacste or a
o
a
p
p
a
the We a tube of tooth
paperclip, ea bass.
mutated s

34

Chapter 1
Download at WoweBook.Com

useWeapon() { // implements cutting
with a knife }

AxeBehavior

useWeapon() { // implements chopping with an axe }

intro to Design Patterns

Solutions
Sharpen your pencil
Which of the following are disadvantages of using subclassing to provide speciﬁc
Duck behavior? (Choose all that apply.)

❏ C. Hard to gain knowledge of all duck behaviors.
❏ D. Ducks can’t ﬂy and quack at the same time.
❏ E. Changes can unintentionally affect other ducks.

❏ A. Code is duplicated across subclasses.
❏ B. Runtime behavior changes are difﬁcult.
❏ C. We can’t make duck’s dance.

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

� �

�
��

�

�

�

�
�

�

�
�

�
��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

��

��

�

�

�

� � �

�

��

�

�
�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

��

�

�

� �

�
�

�
��

�

�

������

�

�

�

�

�

�

�

�

����

�� ������� ���� ������ �������������
����������������������������������������������
What are some factors
that drive change in your applications? You might
Sharpen
your pencil
��������������������������������
�����
�������������
have a very different ��
list,
but ����
here’s�����������
a few of ours.
Look familiar?
�� ���� ��� ����������� ����� ������
��������������������������������
���������������������������������������
������������������
�������������������������������������������
�����������
������������������������������������������
�������������������������������������������
����������������������������������
��������������������������������������
������������

�������������������������������������������������
����������������������������������������
������������
�� ��� ���� ��� ����������
��� ���� ����� ��������� ������������
�����������������������������������
������������������������������������������������
��������������������������������������
������������������������������������������
���������������������������������������

My customers or users decide they want something else, or they want new functionality.
My company decided it is going with another database vendor and it is also purchasing its data
from another supplier that uses a different data format. Argh!
Well, technology changes and we’ve got to update our code to make use of protocols.
We’ve learned enough building our system that we’d like to go back and do things a little better.
you are here 4
Download at WoweBook.Com

35

Download at WoweBook.Com

2 the Observer Pattern

h

Keeping your
g
g
Objects in the know
Hey Jerry, I’m
notifying everyone that the
Patterns Group meeting moved to
Saturday night. We’re going to be
talking about the Observer Pattern.
That pattern is the best! It’s the
BEST, Jerry!

Don’t miss out when something interesting happens! We’ve got a
pattern that keeps your objects in the know when something they might care about happens.
Objects can even decide at runtime whether they want to be kept informed. The Observer
Pattern is one of the most heavily used patterns in the JDK, and it’s incredibly useful. Before
we’re done, we’ll also look at one to many relationships and loose coupling (yeah, that’s right,
we said coupling). With Observer, you’ll be the life of the Patterns Party.

this is a new chapter
Download at WoweBook.Com

37

weather monitoring station

Congratulations!
Your team has just won the contract to build
Weather-O-Rama, Inc.’s next generation,
Internet-based Weather Monitoring Station.

Inc.
-O-Rama,
Weather
Street
100 Main
45021
Alley, OK
Tornado

St ate m e

rk
nt of Wo

tion
xt genera
e
n
r
u
o
d
to buil
g selected tation!
in
e
b
n
o
s
lation
itoring S
Congratu
ther Mon
a
e
W
t pending
d
e
s
a
our paten
n
o
itions
d
Internet-b
e
s
a
ther cond
l be b
a
il
e
w
w
t
n
n
o
e
ti
r
er sta
ʼd like
ks cur
The weath object, which trac etric pressure). We ee
thr
ata
om
provides
WeatherD , humidity, and bar
y
ll
ia
it
in
t
and a
re
tha
statistics
r
(temperatu ate an application
e
th
a
e
w
cre
ditions,
therData
for you to
urrent con al time as the Wea
c
:
ts
n
e
m
e
display ele st, all updated in r asurements.
a
c
e
me
r
t
o
f
n
e
simple
er-Oe most rec
th
s
e
ir
on. Weath an
u
ti
q
c
ta
s
a
t
r
c
e
je
th
ob
ble wea
lopers c
n expanda I so that other deve ht in. Weʼd
a
is
is
th
an AP
Further,
them rig
to release
and plug
ts
s
n
y
a
la
w
p
a
is
m
d
Ra
er
own weath at API!
once
write their
ly
ss model:
supp th
e
in
to
s
u
u
o
b
y
t
a
r
e a gre
like fo
for each
ks we hav
rge them
a
in
h
th
c
a
to
m
d
a
n
-R
te
to pay
Weather-O s are hooked, we in part: we are going
er
est
the custom use. Now for the b
y
e
tion.
display th options.
ha applica
lp
a
k
d
c
n
to
a
s
n
you in
ur desig
seeing yo
to
d
r
a
w
r
o
We look f
,
Sincerely
s to
source ﬁle
ne, CEO
ta
a
a
ic
D
r
r
r
e
u
th
H
Johnny
the Wea
ernighting
v
o
e
r
a
e
P.S. W

38

Chapter 2
Download at WoweBook.Com

you.

the observer pattern

The Weather Monitoring application over view
The three players in the system are the weather station (the physical device that
acquires the actual weather data), the WeatherData object (that tracks the data coming
from the Weather Station and updates the displays), and the display that shows users
the current weather conditions.

ions is one of
Current Conditt displays. The
three differen t weather stats
user can also ge.
and a forecast

Humidity
sensor device

displays

pulls data

Current
Conditions
Temp: 72°
Humidity: 60
Pressure:

Temperature
sensor device

Weather Station

WeatherData
object
Display device

Pressure
sensor device

Weather-O-Rama provides

What we implement

The WeatherData object knows how to talk to the physical Weather Station, to get
updated data. The WeatherData object then updates its displays for the three different
display elements: Current Conditions (shows temperature, humidity, and pressure),
Weather Statistics, and a simple forecast.

Our job, if we choose to accept it, is to create an app that
uses the WeatherData object to update three displays for
current conditions, weather stats, and a forecast.

you are here 4
Download at WoweBook.Com

39

weather data class

Unpacking the WeatherData class
As promised, the next morning the WeatherData source ﬁles arrive.
Peeking inside the code, things look pretty straightforward:

WeatherData

getTemperature()
getHumidity()
getPressure()
measurementsChanged()
// other methods

t
ost recenmidity
m
e
h
t
n
e, hu
retur
methods s for temperatur
e
e
r
h
t
e
Thes measurement respectively.
e
weather metric pressure
e set; th d
r
a
s
o
le
r
b
a
b
ia
e
and
pdat
se var
HOW the ows how to get u
e
r
a
c
’t
n
n
We do Data object k tation.
Weather the Weather S
info from

rData
of the Weathe
The developers a clue about what we
object left us
need to add...
Remember, this Current Co
ONE of three different disnditions is just
play screens.

Current
Conditions
Temp: 72°
Humidity: 60
Pressure:

/*
* This method gets called
* whenever the weather measurements
* have been updated
*
*/
public void measurementsChanged() {
// Your code goes here
}

WeatherData.java

Our job is to implement measurementsChanged()
so that it updates the three displays for current
conditions, weather stats, and forecast.

Display device

40

Chapter 2
Download at WoweBook.Com

the observer pattern

What do we know so far ?
The spec from Weather-O-Rama wasn’t all that clear, but we have to
ﬁgure out what we need to do. So, what do we know so far?

R

The WeatherData class has getter methods for three
measurement values: temperature, humidity and
barometric pressure.

R

The measurementsChanged() method is called any
time new weather measurement data is available. (We
don’t know or care how this method is called; we just
know that it is.)

getTemperature()
getHumidity()
getPressure()
measurementsChanged()

Weather
Stats
Avg. temp: 62°
Min. temp: 50°
Max. temp: 78°

R

We need to implement three display elements that
use the weather data: a current conditions display, a
statistics display and a forecast display. These displays
must be updated each time WeatherData has new
measurements.

Current
Conditions
Temp: 72°
Humidity: 60
Pressure:

Display Two

Forecast

Display One

TT
T

Display Three

R

The system must be expandable—other developers
can create new custom display elements and users
can add or remove as many display elements as they
want to the application. Currently, we know about
only the initial three display types (current conditions,
statistics and forecast).

?
Future displays

you are here 4
Download at WoweBook.Com

41

ﬁrst try with the weather station

Taking a first, misguided SWAG at
the Weather Station
Here’s a ﬁrst implementation possibility—we’ll take the hint from the Weather-ORama developers and add our code to the measurementsChanged() method:
public class WeatherData {
// instance variable declarations
public void measurementsChanged() {
ﬂoat temp = getTemperature();
ﬂoat humidity = getHumidity();
ﬂoat pressure = getPressure();

}
}

Grab the most recent measuremets
by calling the WeatherData’s getter
methods (already implemented).

currentConditionsDisplay.update(temp, humidity, pressure);
statisticsDisplay.update(temp, humidity, pressure);
forecastDisplay.update(temp, humidity, pressure);

Now update
the displays...

Call each display element
update its display, passing to
most recent measurements.it the

// other WeatherData methods here

Sharpen your pencil
Based on our ﬁrst implementation, which of the following apply?
(Choose all that apply.)

❏ D. The display elements don’t implement a

❏ A. We are coding to concrete

common interface.

implementations, not interfaces.

❏ B. For every new display element we need
❏ C. We have no way to add (or remove)
display elements at run time.

❏ E. We haven’t encapsulated the part that
changes.

to alter code.

❏ F. We are violating encapsulation of the
WeatherData class.

Definition of SWAG: Scientific Wild A** Guess

42

Chapter 2
Download at WoweBook.Com

the observer pattern

What’s wrong with our implementation?
Think back to all those Chapter 1 concepts and principles...

public void measurementsChanged() {
ﬂoat temp = getTemperature();
ﬂoat humidity = getHumidity();
ﬂoat pressure = getPressure();

}

Area of change, we need
to encapsulate this.

currentConditionsDisplay.update(temp, humidity, pressure);
statisticsDisplay.update(temp, humidity, pressure);
forecastDisplay.update(temp, humidity, pressure);

By coding to concrete implementations
we have no way to add or remove
other display elements without making
changes to the program.

At least we seem to be using a
common interface to talk to the
display elements... they all have an
update() method takes the temp,
humidity, and pressure values.

Umm, I know I’m new
here, but given that we are in
the Observer Pattern chapter,
maybe we should start using it?

We’ll take a look at
Observer, then come
back and ﬁgure out how
to apply it to the weather
monitoring app.

you are here 4
Download at WoweBook.Com

43

meet the observer pattern

Meet the Obser ver Pattern
You know how newspaper or magazine
subscriptions work:
1

A newspaper publisher goes into business and begins
publishing newspapers.

2

You subscribe to a particular publisher, and every time
there’s a new edition it gets delivered to you. As long as
you remain a subscriber, you get new newspapers.

3

You unsubscribe when you don’t want papers anymore,
and they stop being delivered.

4

While the publisher remains in business, people, hotels,
airlines and other businesses constantly subscribe and
unsubscribe to the newspaper.

Miss what’s going on
in Objectville? No way, of
course we subscribe!

44

Chapter 2
Download at WoweBook.Com

the observer pattern

Publishers + Subscribers = Observer Pattern
If you understand newspaper subscriptions, you pretty much
understand the Observer Pattern, only we call the publisher
the SUBJECT and the subscribers the OBSERVERS.
Let’s take a closer look:

The observers have subscribed to
(registered with) the Subject
to receive updates when the
Subject’s data changes.

bject changes,
When data in the Su
fied.
the observers are noti

Su
bje

ct
Dog Obje

2
2
int

2

New data values are
communicated to the
observers in some form
when they change.

Duck Obje

ct

Cat Object

2

ct Obje

ct

t manages
Subject objecdata.
some bit of

Mo

ec
use Obj

t

Observer Objects

an
This object isn’tdoesn’t
it
so
observer,
the
get notified whechnanges.
Subject’s data

you are here 4
Download at WoweBook.Com

45

a day in the life of the observer pattern

A day in the life of the Obser ver Pattern

Duck really wants in on the
action; those ints Subject is
sending out whenever its state
changes look pretty interesting...

The Duck object is now an
ofﬁcial observer.
Duck is psyched... he’s on the
list and is waiting with great
anticipation for the next
notiﬁcation so he can get an int.

Duck Obj

ct
Dog Obje

2
int

ct Obje

ct

Su
bje

Cat Object

Mo

t
ec

ec
use Obj

t

Observers

2

Su
bje

int

ct
Dog Obje

ct Obje

ct

A Duck object comes along
and tells the Subject that
it wants to become an
observer.

e
rib
sc
b
u
/s
er
t
is
eg
“r

”
me

Duck Obje

Mo

ct

Cat Object

ec
use Obj

t

Observers

Su
bje

int

ct Obje

ct

The Subject gets a new
data value!

8

8

Now Duck and all the rest of the
observers get a notiﬁcation that
the Subject has changed.

ct
Dog Obje

8
8
8

Duck Obje

Mo

ct

Cat Object

ec
use Obj

t

Observers

46

Chapter 2
Download at WoweBook.Com

the observer pattern

8

Su
bje

ct
Dog Obje

ct Obje

ct

The Mouse object asks to be
removed as an observer.

int

The Mouse object has been
getting ints for ages and is tired
of it, so it decides it’s time to
stop being an observer.

“re
mo
ve
ct
/u
Duck Obje
ns
ub
sc
rib
em
e”
Mo

Cat Object

ec
use Obj

t

Observers

8

ct
Dog Obje

int

ct Obje

ct

Mouse is outta here!

Su
bje

The Subject acknowledges the
Mouse’s request and removes it
from the set of observers.

Duck Obje

Mo

ec
use Obj

ct

Cat Object

t
Observers

All the observers get another
notiﬁcation, except for the
Mouse who is no longer included.
Don’t tell anyone, but the Mouse
secretly misses those ints...
maybe it’ll ask to be an observer
again some day.

14

14

Su
bje

int

ct Obje

ct

The Subject has another
new int.

14
14

ct
Dog Obje

Duck Obje

Mo

ec
use Obj

ct

Cat Object

t
Observers

you are here 4
Download at WoweBook.Com

47

ﬁve minute drama

Five minute drama: a subject for observation
In today’s skit, two post-bubble software developers
encounter a real live head hunter...
This is
Ron, I’m looking for a
Java development position, I’ve
got ﬁve years experience and...

Uh, yeah,
you and everybody
else, baby. I’m putting
you on my list of Java
developers, don’t call me,
I’ll call you!

2
Headhunter/Subject

1
I’ll add you to the list,
you’ll know along with
everyone else.

Software
Developer #1
Hi, I’m Jill, I’ve
written a lot of EJB
systems, I’m interested
in any job you’ve got with
Java development.

4

3
Software
Developer #2

48

Subject

Chapter 2
Download at WoweBook.Com

the observer pattern
Meanwhile for Ron and Jill life goes
on; if a Java job comes along, they’ll
get notiﬁed, after all, they are observers.

5

Thanks, I’ll
send my resume
right over.
This guy is a real jerk,
who needs him. I’m
looking for my own job.

Hey
observers, there’s
a Java opening down at
JavaBeans-R-Us, jump
on it! Don’t blow it!
Bwahaha, money
in the bank, baby!

7
Observer
Observer

6
Subject
Arghhh!!! Mark my
words Jill, you’ll never work
in this town again if I have
anything to do with it. You’re
off my call list!!!

Jill lands her own job!

You can take me
off your call list, I
found my own job!

8

9

Observer

Subject
you are here 4

Download at WoweBook.Com

49

the observer pattern deﬁned

Two weeks later...

Jill’s loving life, and no longer an observer.
She’s also enjoying the nice fat signing
bonus that she got because the company
didn’t have to pay a headhunter.

But what has become of our dear Ron? We hear
he’s beating the headhunter at his own game.
He’s not only still an observer, he’s got his own
call list now, and he is notifying his own observers.
Ron’s a subject and an observer all in one.

50

Chapter 2
Download at WoweBook.Com

the observer pattern

The Obser ver Pattern defined
When you’re trying to picture the Observer Pattern, a newspaper
subscription service with its publisher and subscribers is a good
way to visualize the pattern.
In the real world however, you’ll typically see the Observer Pattern
defined like this:

The Observer Pattern deﬁnes a one-to-many
dependency between objects so that when one
object changes state, all of its dependents are
notiﬁed and updated automatically.

The Observer Pattern
defines a one-to-many
relationship between a set
of objects.

Let’s relate this definition to how we’ve been talking about the
pattern:

ONE TO MANY RELATIONSHIP

When the state of one
object changes, all of its
dependents are notified.

Object that
holds state

8
Duck Obje

Automatic update/notification

Mo

ct

Cat Object

ec
use Obj

t

Observers

t Object

ct Obje

ct
Dog Obje

8
8

Dependen

int

ct

Su
bje

s

8

8

The subject and observers define the one-to-many relationship.
The observers are dependent on the subject such that when the
subject’s state changes, the observers get notified. Depending on
the style of notification, the observer may also be updated with
new values.
As you’ll discover, there are a few different ways to implement
the Observer Pattern but most revolve around a class design that
includes Subject and Observer interfaces.
Let’s take a look...
you are here 4
Download at WoweBook.Com

51

loose coupling

The Obser ver Pattern defined:
the class diagram
erface.o register
t
n
i
t
c
e
t
he Subj
erface
Here’s tts use this intlso to removers.
Objec ervers and a eing observe
as obs elves from b
thems

rvers need
All potential obsee Observer
to implement ths interface
interface. Thi hod, update(),
just has one metd when the
that gets callee changes.
Subject’s stat

Each subject
can have many
observers.
observers

<<interface>>

<<interface>>

Subject

Observer

registerObserver()

update()

removeObserver()
notifyObservers()

ConcreteSubject

ways
A concrete subjectbjalect
Su
implements the tion to
interface. In addiremove
the register and rete subject
methods, the concfyObservers()
implements a noti ed to update
method that is us servers
all the current ob anges.
whenever state ch

subject

ConcreteObserver

registerObserver() {...}

update()

removeObserver() {...}

// other Observer specific

notifyObservers() {...}

methods

getState()
setState()

ect may
The concrete subj
s for
also have methottd ing its state
setting and ge is later).
(more about th

Concrete observers can be
any class that implements the
Observer interface. Each
observer registers with a concrete
subject to receive updates.

there are no

Q:

Dumb Questions

What does this have to do
with one-to-many relationships?

A:

With the Observer pattern, the
Subject is the object that contains the
state and controls it. So, there is ONE
subject with state. The observers, on
the other hand, use the state, even
if they don’t own it. There are many
observers and they rely on the Subject
to tell them when its state changes.
So there is a relationship between the
ONE Subject to the MANY Observers.

52

Q:

How does dependence come
into this?

A:

Because the subject is the sole
owner of that data, the observers are
dependent on the subject to update
them when the data changes. This
leads to a cleaner OO design than
allowing many objects to control the
same data.

Chapter 2
Download at WoweBook.Com

the observer pattern

The power of Loose Coupling
When two objects are loosely coupled, they can interact,
but have very little knowledge of each other.
The Observer Pattern provides an object design where
subjects and observers are loosely coupled.
Why?
The only thing the subject knows about an observer is that it
implements a certain interface (the Observer interface). It doesn’t need to
know the concrete class of the observer, what it does, or anything else about it.
We can add new observers at any time. Because the only thing the subject
depends on is a list of objects that implement the Observer interface, we can add new
observers whenever we want. In fact, we can replace any observer at runtime with
another observer and the subject will keep purring along. Likewise, we can remove
observers at any time.
We never need to modify the subject to add new types of observers. Let’s
say we have a new concrete class come along that needs to be an observer. We don’t
need to make any changes to the subject to accommodate the new class type, all
we have to do is implement the Observer interface in the new class and register as
an observer. The subject doesn’t care; it will deliver notiﬁcations to any object that
implements the Observer interface.

How many
different kindsyou
of change can
identify here?

We can reuse subjects or observers independently of each other. If we
have another use for a subject or an observer, we can easily reuse them because the
two aren’t tightly coupled.
Changes to either the subject or an observer will not affect the other.
Because the two are loosely coupled, we are free to make changes to either, as long as
the objects still meet their obligations to implement the subject or observer interfaces.

Design Principle
Strive for loosely coupled designs
between objects that interact.

Loosely coupled designs allow us to build ﬂexible OO
systems that can handle change because they minimize
the interdependency between objects.

you are here 4
Download at WoweBook.Com

53

planning the weather station

Sharpen your pencil
Before moving on, try sketching out the classes you’ll need to implement the
Weather Station, including the WeatherData class and its display elements.
Make sure your diagram shows how all the pieces ﬁt together and also how
another developer might implement her own display element.
If you need a little help, read the next page; your teammates are already
talking about how to design the Weather Station.

54

Chapter 2
Download at WoweBook.Com

the observer pattern

Cubicle conversation
Back to the Weather Station project, your teammates have
already started thinking through the problem...

Sue

So, how are we
going to build this thing?

Mary: Well, it helps to know we’re using the Observer Pattern.
Sue: Right... but how do we apply it?
Mary: Hmm. Let’s look at the deﬁnition again:
The Observer Pattern defines a one-to-many dependency between objects so that when one
object changes state, all its dependents are notified and updated automatically.

Mary: That actually makes some sense when you think about it. Our WeatherData
class is the “one” and our “many” is the various display elements that use the weather
measurements.
Sue: That’s right. The WeatherData class certainly has state... that’s the temperature,
humidity and barometric pressure, and those deﬁnitely change.
Mary: Yup, and when those measurements change, we have to notify all the display
elements so they can do whatever it is they are going to do with the measurements.
Sue: Cool, I now think I see how the Observer Pattern can be applied to our Weather
Station problem.
Mary: There are still a few things to consider that I’m not sure I understand yet.
Sue: Like what?
Mary: For one thing, how do we get the weather measurements to the display elements?
Sue: Well, looking back at the picture of the Observer Pattern, if we make the
WeatherData object the subject, and the display elements the observers, then the
displays will register themselves with the WeatherData object in order to get the
information they want, right?
Mary: Yes... and once the Weather Station knows about a display element, then it can
just call a method to tell it about the measurements.
Sue: We gotta remember that every display element can be different... so I think that’s
where having a common interface comes in. Even though every component has a
different type, they should all implement the same interface so that the WeatherData
object will know how to send them the measurements.
Mary: I see what you mean. So every display will have, say, an update() method that
WeatherData will call.
Sue: And update() is deﬁned in a common interface that all the elements implement…
you are here 4
Download at WoweBook.Com

55

designing the weather station

Designing the Weather Station
How does this diagram compare with yours?

erface,
t
n
i
t
c
e
iliar.
ur subj
Here’s oould look fam
this sh

Let’s also create an
interface for all display
elements to implement. The
display elements just need to
implement a display() method.

mponents
All our weatherOco
erver
implement the s bs
gives the
interface. Thi on
interface
Subject a commn it comes time
to talk to whe observers.
to update the
observers

<<interface>>

<<interface>>

<<interface>>

DisplayElement

Observer

Subject

registerObserver()

display()

update()

removeObserver()
notifyObservers()

CurrentConditionsDisplay
sub

jec t

WeatherData

update()

ThirdPartyDisplay

display() { // display current

update()

measurements }

registerObserver()

display() { // display

removeObserver()

something else based on

notifyObservers()
getTemperature()
getHumidity()
getPressure()
measurementsChanged()

WeatherData now
implements the
Subject interface.

This display element
shows the current
measurements from th
WeatherData object. e

measurements }

StatisticsDisplay
update()
display() { // display the average, min and max measurements }

This one keeps track
of the min/avg/max
measurements and
displays them.

ForecastDisplay
update()
display() { // display the
forecast }

Developers
can implement
the Observer
and Display
interfaces to
create their own
display element.

her
This display shows the weat
meter.
ro
ba
e
th
on
forecast based

These three display elements should have a pointer to
WeatherData labeled “subject” too, but boy would
this diagram start to look like spaghetti if they did.
56

Chapter 2
Download at WoweBook.Com

the observer pattern

Implementing the Weather Station
We’re going to start our implementation using the class diagram and following Mary
and Sue’s lead (from a few pages back). You’ll see later in this chapter that Java
provides some built-in support for the Observer pattern, however, we’re going to get
our hands dirty and roll our own for now. While in some cases you can make use of
Java’s built-in support, in a lot of cases it’s more ﬂexible to build your own (and it’s
not all that hard). So, let’s get started with the interfaces:

public interface Subject {
public void registerObserver(Observer o);
public void removeObserver(Observer o);
public void notifyObservers();
This method is
}

Both of these methods take an
Observer as an argument; that is, the
Observer to be registered or removed.

called to notify all observers
when the Subject’s state has changed.

public interface Observer {
public void update(ﬂoat temp, ﬂoat humidity, ﬂoat pressure);
}

These are the state values the Observers get from
the Subject when a weather measurement changes

public interface DisplayElement {
public void display();
}

The Observer interface is
implemented by all observers,
so they all have to implement
the update() method. Here
we’re following Mary and
Sue’s lead and passing the
measurements to the observers.

The DisplayElement interface just includes
one method, display(), that we will call when
the display element needs to be displayed.

A

brain
power

Mary and Sue thought that passing the measurements directly to the
observers was the most straightforward method of updating state. Do
you think this is wise? Hint: is this an area of the application that
might change in the future? If it did change, would the change be well
encapsulated, or would it require changes in many parts of the code?
Can you think of other ways to approach the problem of passing the
updated state to the observers?
Don’t worry, we’ll come back to this design decision after we ﬁnish the
initial implementation.
you are here 4
Download at WoweBook.Com

57

implementing the weather station

Implementing the Subject interface in
WeatherData
Remember our ﬁrst attempt at implementing the WeatherData class at the
beginning of the chapter? You might want to refresh your memory. Now
it’s time to go back and do things with the Observer Pattern in mind...

WeatherData now implements
the Subject interface.

public class WeatherData implements Subject {
private ArrayList observers;
private ﬂoat temperature;
private ﬂoat humidity;
private ﬂoat pressure;

to
We’ve added an ArrayList
we
and
s,
ver
ser
hold the Ob
or.
create it in the construct

public WeatherData() {
observers = new ArrayList();
}

Here we implement the Subject Interface.

public void registerObserver(Observer o) {
observers.add(o);
}
public void removeObserver(Observer o) {
int i = observers.indexOf(o);
if (i >= 0) {
observers.remove(i);
}
}

REMEMBER: we don’t provide
import and package statements
in the code listings. Get the
complete source code from the
headfirstlabs web site. You’ll
find the URL on page xxxiii in
the Intro.

When an observer registers, we just
add it to the end of the list.

Likewise, when an observer wants to un-register,
we just take it off the list.
Here’s the fun part; this is where we
tell all the observers about the state.
Because they are all Observers, we
know they all implement update(), so
we know how to notify them.

public void notifyObservers() {
for (int i = 0; i < observers.size(); i++) {
Observer observer = (Observer)observers.get(i);
observer.update(temperature, humidity, pressure);
}
}
ify the
public void measurementsChanged() {
notifyObservers();
}

Observers whtens
We not
measuremen
we get updateaedther Station.
from the W

public void setMeasurements(ﬂoat temperature, ﬂoat humidity, ﬂoat pressure) {
this.temperature = temperature;
this.humidity = humidity;
Okay, while we wanted to ship a nice little
this.pressure = pressure;
weather station with each book, the publisher
measurementsChanged();
wouldn’t go for it. So, rather than reading
}
// other WeatherData methods here
}

58

actual weather data off a device, we’re
going to use this method to test our display
elements. Or, for fun, you could write code
to grab measurements off the web.

Chapter 2
Download at WoweBook.Com

the observer pattern

Now, let’s build those display elements
Now that we’ve got our WeatherData class straightened out, it’s time to build the
Display Elements. Weather-O-Rama ordered three: the current conditions display, the
statistics display and the forecast display. Let’s take a look at the current conditions
display; once you have a good feel for this display element, check out the statistics and
forecast displays in the head ﬁrst code directory. You’ll see they are very similar.

er
ts Observhe
n
e
m
le
p
im
t
y
This dispnlaget changes from
a
c
so it Data object.
Weather

It also imp
because ourleAments DisplayElement,
require all d PI is going to
implement thisplay elements to
is interface.

public class CurrentConditionsDisplay implements Observer, DisplayElement {
private ﬂoat temperature;
private ﬂoat humidity;
private Subject weatherData;
tor is passed
public CurrentConditionsDisplay(Subject weatherData) {
this.weatherData = weatherData;
weatherData.registerObserver(this);
}

the
The construc
weatherData object (the Subject)
and we use it to register the
display as an observer.

public void update(ﬂoat temperature, ﬂoat humidity, ﬂoat pressure) {
this.temperature = temperature;
this.humidity = humidity;
When update() is called, we
display();
save the temp and humidity
}

and call display().

public void display() {
System.out.println(“Current conditions: “ + temperature
+ “F degrees and “ + humidity + “% humidity”);
The
}

display() method
just prints out the mostty.
recent temp and humidi

}

there are no

Dumb Questions

Q:

Is update() the best place to
call display?

the way the data gets displayed. We
are going to see this when we get to
the model-view-controller pattern.

A:

Q:

In this simple example it made
sense to call display() when the values
changed. However, you are right,
there are much better ways to design

Why did you store a reference
to the Subject? It doesn’t look
like you use it again after the
constructor?

A:

True, but in the future we
may want to un-register ourselves as
an observer and it would be handy
to already have a reference to the
subject.

you are here 4
Download at WoweBook.Com

59

testing the weather station

Power up the Weather Station
1

First, let’s create a test harness
The Weather Station is ready to go, all we need is some code to glue
everything together. Here’s our ﬁrst attempt. We’ll come back later in
the book and make sure all the components are easily pluggable via a
conﬁguration ﬁle. For now here’s how it all works:
public class WeatherStation {
public static void main(String[] args) {
WeatherData weatherData = new WeatherData();

If you don’t
want to
download the
code, you can
comment out
these two lines
and run it.

CurrentConditionsDisplay currentDisplay =
new CurrentConditionsDisplay(weatherData);
StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);
weatherData.setMeasurements(80, 65, 30.4f);
weatherData.setMeasurements(82, 70, 29.2f);
weatherData.setMeasurements(78, 90, 29.2f);

}

Simulate new weather
measurements.

}

2

the
First, creaattea
WeatherD
object.

Run the code and let the Observer Pattern do its magic
File Edit Window Help StormyWeather

%java WeatherStation
Current conditions: 80.0F degrees and 65.0% humidity
Avg/Max/Min temperature = 80.0/80.0/80.0
Forecast: Improving weather on the way!
Current conditions: 82.0F degrees and 70.0% humidity
Avg/Max/Min temperature = 81.0/82.0/80.0
Forecast: Watch out for cooler, rainy weather
Current conditions: 78.0F degrees and 90.0% humidity
Avg/Max/Min temperature = 80.0/82.0/78.0
Forecast: More of the same
%

60

Chapter 2
Download at WoweBook.Com

Create the three
displays and
pass them the
WeatherData object.

the observer pattern

Sharpen your pencil
Johnny Hurricane, Weather-O-Rama’s CEO just called, they can’t possibly ship without a Heat Index
display element. Here are the details:
The heat index is an index that combines temperature and humidity to determine the apparent
temperature (how hot it actually feels). To compute the heat index, you take the temperature, T, and the
relative humidity, RH, and use this formula:

heatindex =
16.923 + 1.85212 * 10-1 * T + 5.37941 * RH - 1.00254 * 10-1 * T
* RH + 9.41695 * 10-3 * T2 + 7.28898 * 10-3 * RH2 + 3.45372 * 10-4
* T2 * RH - 8.14971 * 10-4 * T * RH2 + 1.02102 * 10-5 * T2 * RH2 3.8646 * 10-5 * T3 + 2.91583 * 10-5 * RH3 + 1.42721 * 10-6 * T3 * RH
+ 1.97483 * 10-7 * T * RH3 - 2.18429 * 10-8 * T3 * RH2 + 8.43296 *
10-10 * T2 * RH3 - 4.81975 * 10-11 * T3 * RH3
So get typing!
Just kidding. Don’t worry, you won’t have to type that formula in; just create your own HeatIndexDisplay.
java ﬁle and copy the formula from heatindex.txt into it.

You can get heatindex.txt from headfirstlabs.com

How does it work? You’d have to refer to Head First Meteorology, or try asking someone at the National
Weather Service (or try a Google search).
When you ﬁnish, your output should look like this:
File Edit Window Help OverdaRainbow

han
at c t.
h
w
’s
pu
Here his out
in t

ged

%java WeatherStation
Current conditions: 80.0F degrees and 65.0% humidity
Avg/Max/Min temperature = 80.0/80.0/80.0
Forecast: Improving weather on the way!
Heat index is 82.95535
Current conditions: 82.0F degrees and 70.0% humidity
Avg/Max/Min temperature = 81.0/82.0/80.0
Forecast: Watch out for cooler, rainy weather
Heat index is 86.90124
Current conditions: 78.0F degrees and 90.0% humidity
Avg/Max/Min temperature = 80.0/82.0/78.0
Forecast: More of the same
Heat index is 83.64967
%

you are here 4
Download at WoweBook.Com

61

ﬁreside chat: subject and observer

Tonight’s talk: A Subject and Observer spar over the right
way to get state information to the Observer.

Subject

Observer

I’m glad we’re ﬁnally getting a chance to chat in
person.
Well, I do my job, don’t I? I always tell you what’s
going on... Just because I don’t really know who
you are doesn’t mean I don’t care. And besides, I
do know the most important thing about you—
you implement the Observer interface.

Really? I thought you didn’t care much about
us Observers.

Well yeah, but that’s just a small part of who I
am. Anyway, I know a lot more about you...

Oh yeah, like what?
Well, you’re always passing your state around
to us Observers so we can see what’s going
on inside you. Which gets a little annoying at
times...
Well excuuuse me. I have to send my state with my
notiﬁcations so all you lazy Observers will know
what happened!
Ok, wait just a minute here; ﬁrst, we’re not lazy,
we just have other stuff to do in between your
oh-so-important notiﬁcations, Mr. Subject, and
second, why don’t you let us come to you for
the state we want rather than pushing it out to
just everyone?
Well... I guess that might work. I’d have to open
myself up even more though to let all you Observers
come in and get the state that you need. That might
be kind of dangerous. I can’t let you come in and
just snoop around looking at everything I’ve got.

62

Chapter 2
Download at WoweBook.Com

the observer pattern

Subject

Observer

Yes, I could let you pull my state. But won’t that be
less convenient for you? If you have to come to me
every time you want something, you might have to
make multiple method calls to get all the state you
want. That’s why I like push better... then you have
everything you need in one notiﬁcation.

Well, I can see the advantages to doing it both ways.
I have noticed that there is a built-in Java Observer
Pattern that allows you to use either push or pull.

Great... maybe I’ll get to see a good example of
pull and change my mind.

Why don’t you just write some public getter
methods that will let us pull out the state we
need?

Don’t be so pushy! There’s so many different
kinds of us Observers, there’s no way you can
anticipate everything we need. Just let us come
to you to get the state we need. That way, if
some of us only need a little bit of state, we
aren’t forced to get it all. It also makes things
easier to modify later. Say, for example, you
expand yourself and add some more state, well
if you use pull, you don’t have to go around
and change the update calls on every observer,
you just need to change yourself to allow more
getter methods to access our additional state.

Oh really? I think we’re going to look at that
next....

What, us agree on something? I guess there’s
always hope.

you are here 4
Download at WoweBook.Com

63

java’s built-in observer pattern

Using Java’s built-in
Observer Pattern

With Java’s built-in
support, all you have to do is
extend Observable and tell it
when to notify the Observers.
The API does the rest for you.

So far we’ve rolled our own code for the
Observer Pattern, but Java has built-in support
in several of its APIs. The most general is the
Observer interface and the Observable class in
the java.util package. These are quite similar
to our Subject and Observer interface, but give
you a lot of functionality out of the box. You
can also implement either a push or pull style of
update to your observers, as you will see.
To get a high level feel for java.util.Observer and
java.util.Observable, check out this reworked
OO design for the WeatherStation:

le class keeps
The Observallbyour observers
track of a s them for you.
and notifie
Observable

Observable is a addObserver()
CLASS not an deleteObserver()
notifyObservers()
interface, so
setChanged()
WeatherData
extends Observable.

familiar. In s
This should loaok
ly the same a
fact, it’s ex clctass diagram !
our previous
<<interface>>

observers

Observer

update()

sub

jec

t

WeatherData

’t look
n
s
e
o
d
This liar! Hold to
fami , we’ll get
tight n a sec...
ich we can
this i
Here’s our Subject,Obwh
able. We
rv
now also call the gistseer(), remove()
don’t need the reers() methods
and notifyObserv t that behavior
anymore; we inheriss.
from the supercla
getTemperature()
getHumidity()
getPressure()

64

GeneralDisplay

StatisticsDisplay
update()
display()

update()
display()

We left out the
DisplayElement
interface, but all
the displays still
implement it too.
ForecastDisplay
update()
display()

to make to the update()
There will be a few changesser
s, but basically it’s
method in the concrete Obcomver
mon Observer interface,
the same idea... we have a t’s
called by the Subject.
with an update() method tha

Chapter 2
Download at WoweBook.Com

the observer pattern

How Java’s built-in Obser ver Pattern works
The built in Observer Pattern works a bit differently than the implementation that we used
on the Weather Station. The most obvious difference is that WeatherData (our subject)
now extends the Observable class and inherits the add, delete and notify Observer methods
(among a few others). Here’s how we use Java’s version:

For an Object to become an observer...
As usual, implement the Observer interface (this time the java.util.Observer
interface) and call addObserver() on any Observable object. Likewise, to remove
yourself as an observer just call deleteObserver().

For the Observable to send notiﬁcations...
First of all you need to be Observable by extending the java.util.Observable
superclass. From there it is a two step process:
1 You ﬁrst must call the setChanged() method to signify

that the state has changed in your object
2 Then, call one of two notifyObservers() methods:

either notifyObservers()

or

notifyObservers(Object arg)

akes an
This versiondatta object
arbitrary assed to
that gets pver when it
each Obser
is notified.

For an Observer to receive notiﬁcations...
It implements the update method, as before, but the signature of the
method is a bit different:

data object

update(Observable o, Object arg)

The Subject that sent
the notification is passed
in as this argument.

This will be the data object that was
passed to notifyObservers(), or null if
a data object wasn’t specified.

If you want to “push” data to the observers you can pass the data as a data object
to the notifyObserver(arg) method. If not, then the Observer has to “pull” the data
it wants from the Observable object passed to it. How? Let’s rework the Weather
Station and you’ll see.
you are here 4
Download at WoweBook.Com

65

behind the scenes

Wait, before we get
to that, why do we need this
setChanged() method? We didn’t
need that before.

The setChanged() method is used to signify that the state has changed and that notifyObservers(),
when it is called, should update its observers. If notifyObservers() is called without ﬁrst calling
setChanged(), the observers will NOT be notiﬁed. Let’s take a look behind the scenes of
Observable to see how this works:

Behind
the Scenes
setChanged() {
changed = true
}

r the
o
f
e
ocod lass.
Pseudervable C
Obs

notifyObservers(Object arg) {
if (changed) {
for every observer on the list {
call update (this, arg)
}
changed = false
}
}

The setChanged() method
ue.
sets a changed flag to tr
notifyObservers() onlyif
notifies its observers UE.
the changed flag is TR

And after it notifies
the observers, it sets the
changed flag back to false.

notifyObservers() {
notifyObservers(null)
}

Why is this necessary? The setChanged() method is meant to give you more ﬂexibility in how
you update observers by allowing you to optimize the notiﬁcations. For example, in our weather
station, imagine if our measurements were so sensitive that the temperature readings were
constantly ﬂuctuating by a few tenths of a degree. That might cause the WeatherData object
to send out notiﬁcations constantly. Instead, we might want to send out notiﬁcations only if the
temperature changes more than half a degree and we could call setChanged() only after that
happened.
You might not use this functionality very often, but it’s there if you need it. In either case, you
need to call setChanged() for notiﬁcations to work. If this functionality is something that is useful
to you, you may also want to use the clearChanged() method, which sets the changed state back to
false, and the hasChanged() method, which tells you the current state of the changed ﬂag.
66

Chapter 2
Download at WoweBook.Com

the observer pattern

Reworking the Weather Station with the built-in support
First, let’s rework WeatherData to use
java.util.Observable

1

Make sure we are importing the
right Observer/Observable.

2

We are now
subclassing Observable.

We don’t need to keep track of
our observers anymore, or manage
their registration and removal,
(the superclass will handle that)
so we’ve removed the code for
register, add and notify.

3

import java.util.Observable;
import java.util.Observer;
public class WeatherData extends Observable {
private ﬂoat temperature;
private ﬂoat humidity;
private ﬂoat pressure;

4

Our constructor no longer
needs to create a data
structure to hold Observers.

* Notice we aren’t sending a data object with

public WeatherData() { }

the notifyObservers() call. That means
we’re using the PULL model.

public void measurementsChanged() {
setChanged();
notifyObservers();
}

*

public void setMeasurements(ﬂoat temperature, ﬂoat humidity, ﬂoat pressure) {
this.temperature = temperature;
this.humidity = humidity;
this.pressure = pressure;
5 We now first call setChanged() to
measurementsChanged();
indicate the state has changed
}
before calling notifyObservers().
public ﬂoat getTemperature() {
return temperature;
}
public ﬂoat getHumidity() {
return humidity;
}
public ﬂoat getPressure() {
return pressure;
}
}

6

These methods aren’t new, but
because we are going to use “pull”
we thought we’d remind you
they are here. The Observers
will use them to get at the
WeatherData object’s state.
you are here 4

Download at WoweBook.Com

67

current conditions rework

Now, let’s rework the CurrentConditionsDisplay

1

Again, make sure we are importing
the right Observer/Observable.
2

We now are implementing the Observer interface from java.util.

import java.util.Observable;
import java.util.Observer;
public class CurrentConditionsDisplay implements Observer, DisplayElement {
Observable observable;
private ﬂoat temperature;
3 Our constructor now takes an
private ﬂoat humidity;
Observable and we use this to
public CurrentConditionsDisplay(Observable observable) {
this.observable = observable;
observable.addObserver(this);
}

add the current conditions
object as an Observer.
4

public void update(Observable obs, Object arg) {
if (obs instanceof WeatherData) {
WeatherData weatherData = (WeatherData)obs;
this.temperature = weatherData.getTemperature();
this.humidity = weatherData.getHumidity();
display();
}
}
public void display() {
System.out.println(“Current conditions: “ + temperature
+ “F degrees and “ + humidity + “% humidity”);
}
}

68

Chapter 2
Download at WoweBook.Com

5

We’ve changed the
update() method
to take both an
Observable and the
optional data argument.

In update(), we first
make sure the observable
is of type WeatherData
and then we use its
getter methods to
obtain the temperature
and humidity
measurements. After
that we call display().

the observer pattern

Code Magnets
Exercise

The ForecastDisplay class is all scrambled up on the fridge. Can you
reconstruct the code snippets to make it work? Some of the curly
braces fell on the floor and they were too small to pick up, so feel
free to add as many of those as you need!

ble
rva
e
s
Ob
ay(
spl
i
D
t
cas
ore {
F
)
lic
display();
pub rvable
e
s
ob

observable.add
Observer(this)
;

if (observable instanceof WeatherData) {

implements
public class ForecastDisplay
{
nt
leme
layE
Disp
Observer,

{
display()
public void y code here
// displa
}
e();
ssur
e;
e
r
r
u
P
s
t
s
a.ge
tPre
rren therDat
u
c
wea
e =
ssur sure =
e
r
P
last entPres
curr
private ﬂoa
t currentPre
ssure = 29.9
private ﬂoa
2f;
t lastPressu
re;
WeatherData we
atherData =
(WeatherData)o
bservable;
le,
ble observab
date(Observa
up
id
vo
ic
publ
{
Object arg)

servable;
import java.util.Ob
server;
Ob
l.
ti
import java.u
you are here 4
Download at WoweBook.Com

69

test drive

Running the new code
Just to be sure, let’s run the new code...
File Edit Window Help TryTihisAtHome

%java WeatherStation
Forecast: Improving weather on the way!
Avg/Max/Min temperature = 80.0/80.0/80.0
Current conditions: 80.0F degrees and 65.0% humidity
Forecast: Watch out for cooler, rainy weather
Avg/Max/Min temperature = 81.0/82.0/80.0
Current conditions: 82.0F degrees and 70.0% humidity
Forecast: More of the same
Avg/Max/Min temperature = 80.0/82.0/78.0
Current conditions: 78.0F degrees and 90.0% humidity
%

Hmm, do you notice anything different? Look again...
You’ll see all the same calculations, but mysteriously, the order of the text output is
different. Why might this happen? Think for a minute before reading on...

Never depend on order of evaluation of the
Observer notiﬁcations
The java.util.Observable has implemented its notifyObservers() method such that the
Observers are notiﬁed in a different order than our own implementation. Who’s right?
Neither; we just chose to implement things in different ways.
What would be incorrect, however, is if we wrote our code to depend on a speciﬁc
notiﬁcation order. Why? Because if you need to change Observable/Observer
implementations, the order of notiﬁcation could change and your application would
produce incorrect results. Now that’s deﬁnitely not what we’d consider loosely coupled.

70

Chapter 2
Download at WoweBook.Com

the observer pattern

Doesn’t
java.util.Observable
violate our OO design principle
of programming to interfaces
not implementations?

The dark side of java.util.Obser vable
Yes, good catch. As you’ve noticed, Observable is a class, not an interface, and worse,
it doesn’t even implement an interface. Unfortunately, the java.util.Observable
implementation has a number of problems that limit its usefulness and reuse. That’s not
to say it doesn’t provide some utility, but there are some large potholes to watch out for.

Observable is a class
You already know from our principles this is a bad idea, but what harm does it really
cause?
First, because Observable is a class, you have to subclass it. That means you can’t add
on the Observable behavior to an existing class that already extends another superclass.
This limits its reuse potential (and isn’t that why we are using patterns in the ﬁrst place?).
Second, because there isn’t an Observable interface, you can’t even create your own
implementation that plays well with Java’s built-in Observer API. Nor do you have
the option of swapping out the java.util implementation for another (say, a new, multithreaded implementation).

Observable protects crucial methods
If you look at the Observable API, the setChanged() method is protected. So what? Well,
this means you can’t call setChanged() unless you’ve subclassed Observable. This means
you can’t even create an instance of the Observable class and compose it with your own
objects, you have to subclass. The design violates a second design principle here…favor
composition over inheritance.

What to do?
Observable may serve your needs if you can extend java.util.Observable. On the other
hand, you may need to roll your own implementation as we did at the beginning of the
chapter. In either case, you know the Observer Pattern well and you’re in a good position
to work with any API that makes use of the pattern.

you are here 4
Download at WoweBook.Com

71

observer and swing

Other places you’ll find the Obser ver Pattern
in the JDK
The java.util implementation of Observer/Observable is not the only place you’ll
ﬁnd the Observer Pattern in the JDK; both JavaBeans and Swing also provide their
own implementations of the pattern. At this point you understand enough about
observer to explore these APIs on your own; however, let’s do a quick, simple Swing
example just for the fun of it.

A little background...

out
If you’re curious aber
n in
tt
Pa
er
the Observ
the
t
ou
k
ec
ch
JavaBeans
ener
PropertyChangeList
interface.

Let’s take a look at a simple part of the Swing API, the JButton. If you look under
the hood at JButton’s superclass, AbstractButton, you’ll see that it has a lot of add/
remove listener methods. These methods allow you to add and remove observers,
or as they are called in Swing, listeners, to listen for various types of events that
occur on the Swing component. For instance, an ActionListener lets you “listen in”
on any types of actions that might occur on a button, like a button press. You’ll ﬁnd
various types of listeners all over the Swing API.

A little life-changing application
Okay, our application is pretty simple. You’ve got a button that says “Should I do
it?” and when you click on that button the listeners (observers) get to answer the
question in any way they want. We’re implementing two such listeners, called the
AngelListener and the DevilListener. Here’s how the application behaves:

rface.

Here’s our fancy inte

ut when
And here’s the outp
on.
we click on the butt
File Edit Window Help HeMadeMeDoIt

Devil answer
Angel answer
72

%java SwingObserverExample
Come on, do it!
Don’t do it, you might regret it!
%

Chapter 2
Download at WoweBook.Com

the observer pattern

And the code...
This life-changing application requires very little code. All we need to do is
create a JButton object, add it to a JFrame and set up our listeners. We’re going
to use inner classes for the listeners, which is a common technique in Swing
programming. If you aren’t up on inner classes or Swing you might want to
review the “Getting GUI” chapter of Head First Java.

public class SwingObserverExample {
JFrame frame;

ication that
Simple Swing apfplrame and
just creates a on in it.
throws a butt

public static void main(String[] args) {
SwingObserverExample example = new SwingObserverExample();
example.go();
}
public void go() {
Makes the devil and
frame = new JFrame();
JButton button = new JButton(“Should I do it?”);
angel objects listeners
button.addActionListener(new AngelListener());
(observers) of the button.
button.addActionListener(new DevilListener());
frame.getContentPane().add(BorderLayout.CENTER, button);
// Set frame properties here
}
class AngelListener implements ActionListener {
public void actionPerformed(ActionEvent event) {
System.out.println(“Don’t do it, you might regret it!”);
}
Here are t
}
class DevilListener implements ActionListener {
public void actionPerformed(ActionEvent event) {
System.out.println(“Come on, do it!”);
}
}
}

the observehre class definitions for
classes (but s, defined as inner
they don’t h
ave to be).

Rather than update(), the
actionPerformed() method
gets called when the state
in the subject (in this case
the button) changes.

you are here 4
Download at WoweBook.Com

73

your design toolbox

Tools for your Design Toolbox
Welcome to the end of Chapter 2.
You’ve added a few new things to your
OO toolbox...

BULLET POINTS

ß The Observer Pattern defines
a one-to-many relationship
between objects.

ß Subjects, or as we also know
them, Observables, update
Observers using a common
interface.

OO Basics
s

OO Principle

ß Observers are loosely coupled

Abstraction
n
Encapsulatio
m
Polymorphis
Inheritence

hat varies.
w
e
t
la
u
s
p
a
c
En
osition over
p
m
o
c
r
o
v
a
F
inheritance.
not
interfaces,
o
t
m
a
r
g
o
r
P
ions.
implementat
d
osely couple that
lo
r
o
f
e
iv
r
St
een objects
designs betw
interact.

in that the Observable knows
nothing about them, other
than that they implement the
Observer Interface.

ß You can push or pull data from

est
Here’s your newember,
principle. Remd designs are
loosely couplelexible and
much more fchange.
resilient to

OO Patterns

ß Don’t depend on a specific
order of notification for your
Observers.

ß Java has several
implementations of the
Observer Pattern, including
the general purpose java.util.
Observable.

ß Watch out for issues with

s,
of algorithm many
y
il
m
a
f
a
s
-todefine
Strategy - eeacrhvoenre, -andemfainkess taheomnetorsitshomthat
tebs s
bejealgc
encapsulaO
tbeegtywleetesn toh sutseatite., all its
a
r
y
t
c
S
n
e
.
d
le
n
b
e
a
interchandgep otnlye forbojemcctliecnhtas ntgheast
nd updated
a
nednen
d
ie
if
t
o
n
vary indewphe
ents are

depend lly
automatica

A new pattern for communicating state to a
set of objects in a loosely coupled manner. We
haven’t seen the last of the Observer Pattern
- just wait until we talk about MVC!
74

the Observable when using
the pattern (pull is considered
more “correct”).

Chapter 2
Download at WoweBook.Com

the java.util.Observable
implementation.

ß Don’t be afraid to create
your own Observable
implementation if needed.

ß Swing makes heavy use of the
Observer Pattern, as do many
GUI frameworks.

ß You’ll also find the pattern in
many other places, including
JavaBeans and RMI.

the observer pattern

Exercise

Design Principle Challenge
For each design principle, describe how the Observer Pattern
makes use of the principle.

Design Principle
Identify the aspects of your application that vary
and separate them from what stays the same.

Design Principle
Program to an interface, not an implementation.

This is a hard one, hint: think about how observers
and subjects work together.
Design Principle
Favor composition over inheritance.

you are here 4
Download at WoweBook.Com

75

crossword puzzle

Time to give your right brain something to do again!
This time all of the solution words are from chapter 2.

�

�

�

�
�

�

�

�

�
�

�
�

�

��

�

�
�

��

��

��

�

�

��

��

��

��
��

��

��

��

��
����

��

��

��

��
��

��
��

��

��

��

��

������

�������� � ������ ��� �� ���������
�� ����������
�� ����������
� ������
���������
�� �����
��� ����� ������������
�� ���
��� ��
������
�� ����� ���
�������
�� ���������
���� �����
���������
�� ���
���������� ��� ������
���������
�� ���������
��� �� �������
��������� �� ��� ��������
�� ���� ��� ��� �� ��� ���
�� ������������������������
���������� ����
�� ������������������������ ���������� ����
���������
���������
�� ���
�� ��� �������� ��� ��� �������� ����
�� ���
�� ����
��� ��������
��� ���
��������
��� ���
������
�� ������ ���
�������
������������
����
��� ���
��� �����
��� ������
������ ����
�� �� ������ ��� ������� ��������
����
��� �����
�� ���������
��� ���
�������
����� �����
����������
�� �����
��� ���
�� ���� �� ����� ���������
��� �����
������������
�� ���� �����
��� ������������
��� ����� �����
�� �������
����������
������������
��� ������������
��������
��� ������������
��������
�������
��� ���������
��� ��������
�� ������
�������
��� ���������
��� ��������
��� �������
��� �������
�� �� �������
��� �� ��
��������������
�������
�� �����������
��� ��
��� ����
�������
�� �������
� ����������
��������������
��� � ������� �� ������� �� � ����������

76

����

������
��� ��� ���� �� �������� ��� � ����������
���
���������
��������
��� � ����������
�������
����
���� ��
����
�������� ��������
�� ����
���������
��������
��� ������
�� ����
��� �� �������� ��������
�� ����
������
��� �� ��� ���
���������
��� ���
������
������
���������
�� ����
�����
��� ������
���������
���
���������
���� ����
���� ��
������������ ���
�������������������
���� ��������� ����
���� �� �����
���������
���
��� �����
���� ���� ��
��� ���������������� ��� ����� ����� ����
�����
����
�� �����
���
���������
���� �� �� ��������� ���� ���������
����������
��������� ���� �� �� ��������� ����
���
���������
��� �������
���
��� �����������
����� ��������� ��� �������
��� ��� ����������� ����� ��������� ���
���������
�������
���������
���
�� ������
���� ��� ���� ����� �� �� �������
��� �� ������ ���� ��� ���� ����� �� �� �������
�������
�������
���
��� ������ ������ ��� ������ ����� �������
����������
��� ������
�������
���
��������� ������
���������
�� ������
���� ��� �����
��� ����
��
��������
��� ������� ��������� ������ �� ���� ��� ��� ����
�� ��������

Chapter 2
Download at WoweBook.Com

the observer pattern

Exercise
solutions

Sharpen your pencil
Based on our ﬁrst implementation, which of the following apply?
(Choose all that apply.)

❏ A. We are coding to concrete

❏ D. The display elements don’t implement a
common interface.

implementations, not interfaces.

❏ B. For every new display element we need

❏ E. We haven’t encapsulated what changes.

to alter code.

❏ C. We have no way to add display

❏ F. We are violating encapsulation of the

elements at run time.

WeatherData class.

Design
Principle
Challenge
Design Principle
Identify the aspects of your application that
vary and separate them from what stays the
same.

Design Principle
Program to an interface, not an implementation.

Design Principle
Favor composition over inheritance.

The thing that varies in the Observer Pattern
is the state of the Subject and the number and
types of Observers. With this pattern, you can
vary the objects that are dependent on the state
of the Subject, without having to change that
Subject. That’s called planning ahead!

Both the Subject and Observer use interfaces.
The Subject keeps track of objects implementing the Observer interface, while the observers
register with, and get notified by, the Subject
interface. As we’ve seen, this keeps things nice
and loosely coupled.

The Observer Pattern uses composition to compose
any number of Observers with their Subjects.
These relationships aren’t set up by some kind of
inheritance hierarchy. No, they are set up at
runtime by composition!

you are here 4
Download at WoweBook.Com

77

exercise solutions

Code Magnets

Exercise
solutions

servable;
import java.util.Ob
server;
import java.util.Ob

implements
public class ForecastDisplay
Observer, DisplayElement {

private ﬂoa
t currentPre
ssure = 29.9
private ﬂoa
2f;
t lastPressu
re;
rvable
public ForecastDisplay(Obse
observable) {
observable.addO
bserver(this);
}

able,
vable observ
update(Obser
public void
{
g)
ar
ct
Obje

if (observable instanceof WeatherData) {
WeatherData wea
therData =
(WeatherData)ob
servable;

lastPressure = currentPressure;
currentPressure = weatherData.getPressure();
}

}

display();

{
display()
public void y code here
la
sp
di
//
}

�

�

�

�

�

�
�

}
�
�
�

�

��

��

�

�

�

�
�

�

�

�

�

�

�

78

Chapter 2

�

�

�

�

�
�

�

�

�

�
��

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

��

�

�
�

�
��

�
��

�
��

�

�

�

��

�

�

�

�

�

�
�

�

�

�

�

�

�

�
�

�

�

�
�

�

�
��

�

�

�

�

�

�

�

�

�

������

����

�� ���������� �� � ������ ��� �� ��������� �������
�� ����� ��� ����� ��� ������� �� ��� ������
�����������
Download at WoweBook.Com
�� ��������� ���� ������ �� ��� �������� ��������
�� ���� ��� ��� �� ��� ��� �����

�� ��� ��� ���� �� �������� ��� � ����������
���������
�� ��� ���� �� ���� ���� �������� �������� �������
�� �� ���� ��� ������ �� ��� �� ���������������
�� ����� ��� ������ ���� ��������� ��� ���

3 the DecoratorPattern

g Decorating

h

Objects g

I used to think real men
subclassed everything. That was
until I learned the power of
extension at runtime, rather than
at compile time. Now look at me!

Just call this chapter “Design Eye for the Inheritance Guy.”
We’ll re-examine the typical overuse of inheritance and you’ll learn how to decorate
your classes at runtime using a form of object composition. Why? Once you know the
techniques of decorating, you’ll be able to give your (or someone else’s) objects new
responsibilities without making any code changes to the underlying classes.

this is a new chapter
Download at WoweBook.Com

79

the starbuzz story

Welcome to Starbuzz Coffee
Starbuzz Coffee has made a name for itself as the
fastest growing coffee shop around. If you’ve seen one
on your local corner, look across the street; you’ll see
another one.
Because they’ve grown so quickly, they’re scrambling
to update their ordering systems to match their
beverage offerings.
When they ﬁrst went into business they designed their
classes like this...

stract class,
Beverage is an abbe
verages
subclassed by all ff
ee shop.
co
offered in the

The description instance variable
is set in each subclass and holds a
description of the beverage, like
“Most Excellent Dark Roast”.
The getDescription() method
returns the description.

Beverage
description

The cost() method is
abstract; subclassses
need to define their
own implementation.

getDescription()
cost()
// Other useful methods...

HouseBlend
cost()

DarkRoast
cost()

Decaf
cost()

Espresso
cost()

Each subclass implements cost() to return the cost of the beverage.

80

Chapter 3
Download at WoweBook.Com

the decorator pattern

In addition to your coffee, you can also ask for several condiments like
steamed milk, soy, and mocha (otherwise known as chocolate), and have
it all topped off with whipped milk. Starbuzz charges a bit for each of
these, so they really need to get them built into their order system.
Here’s their ﬁrst attempt...
Beverage
description
getDescription()
cost()
// Other useful methods...

DarkRoastWithSteamedMilk
andMocha

HouseBlendWithSteamedMilk
andMocha
HouseBlendWithSteamedMilk
cost()
andCaramel
HouseBlendWithWhipandMocha

cost()

cost()

cost()

DecafWithSteamedMilk
andCaramel

DarkRoastWithSteamedMilk
andCaramel

cost()

HouseBlendWithMocha
cost()
HouseBlendWithSoyandMocha

EspressoWithSteamedMilk
andMocha

DecafWithSteamedMilk
andMocha

cost()
DarkRoastWithWhipandMocha

cost()

EspressoWithSteamedMilk
andCaramel
EspressoWithWhipandMocha

cost()

DecafWithWhipandMocha
cost()

cost()

HouseBlendWithSteamedMilk
andSoycost()
cost()

DarkRoastWithSteamedMilk
andSoy

HouseBlendWithWhip

cost()

cost()

HouseBlendWithSoy
cost()

HouseBlendWithSteamedMilk
cost()
cost()

cost()
DarkRoastWithSteamedMilk

cost()
HouseBlendWithSteamedMilk

andWhip

cost()

EspressoWithSteamedMilk
DecafWithSoy
andSoy
DecafWithSteamedMilk
cost()
andSoy EspressoWithSteamedMilk
cost()

DarkRoastWithSoy
cost()
DecafWithSteamedMilk
cost()
DecafWithSoyandMocha
DarkRoastWithSoy
DarkRoastWithSoyandMocha
cost()
DecafWithSoy
cost()
DecafWithSoyandMocha
cost()
EspressoWhip
cost()
cost()

cost()

cost()
HouseBlendWithWhipandSoy

DecafWithWhip
cost()

DarkRoastWithWhip

cost()

cost()

EspressoWithSteamedMilk
andWhip
DecafWithSteamedMilk
DarkRoastWithSteamedMilk
cost()
andWhip
andWhip
EspressoWithWhipandSoy
DecafWithWhipandSoy
cost()
DarkRoastWithWhipandSoy
cost()
cost()

cost()

EspressoWithMocha

cost()
DecafWithMocha

cost()

DarkRoastWithMocha

cost()
cost()

cost()

Whoa!
Can you say
“class explosion?”

mputes the
Each cost method coalo
ng with the
cost of the coffee the order.
other condiments in

you are here 4
Download at WoweBook.Com

81

violating design principles

A

brain
power

It’s pretty obvious that Starbuzz has created a maintenance nightmare for
themselves. What happens when the price of milk goes up? What do they do
when they add a new caramel topping?
Thinking beyond the maintenance problem, which of the design principles that
we’ve covered so far are they violating?
Hint: they’re violating two of them in a big way!
This is stupid; why do we need
all these classes? Can’t we just use
instance variables and inheritance in
the superclass to keep track of the
condiments?

Well, let’s give it a try. Let’s start with the Beverage base
class and add instance variables to represent whether or
not each beverage has milk, soy, mocha and whip...

Beverage

New boolean values for
each condiment.

description
milk
soy
mocha
whip

Now we’ll implement cost() in Beverage (instead of
keeping it abstract), so that it can calculate the
costs associated with the condiments for a particular
beverage instance. Subclasses will still override
cost(), but they will also invoke the super version so
that they can calculate the total cost of the basic
beverage plus the costs of the added condiments.

getDescription()
cost()
hasMilk()
setMilk()
hasSoy()
setSoy()
hasMocha()
setMocha()
hasWhip()
setWhip()

e boolean
These get and setndthiments.
values for the co

// Other useful methods..

82

Chapter 3
Download at WoweBook.Com

the decorator pattern
Beverage

Now let’s add in the subclasses, one
for each beverage on the menu:

e
st() will calculate th
The superclass coth
ile
condiments, wh
costs for all of ste() in the subclasses
the overridden cofunctionality to
will extend that that specific
include costs for
beverage type.
needs to compute
Each cost() methobedverage and then
the cost of the ents by calling the
add in the condim tation of cost().
superclass implemen

getDescription()
cost()
hasMilk()
setMilk()
hasSoy()
setSoy()
hasMocha()
setMocha()
hasWhip()
setWhip()
// Other useful methods..

HouseBlend
cost()

description
milk
soy
mocha
whip

DarkRoast

Decaf

cost()

Sharpen your pencil

cost()

Espresso
cost()

Write the cost( ) methods for the following classes (pseudo-Java is okay):

public class Beverage {
public double cost() {

public class DarkRoast extends Beverage {
public DarkRoast() {
description = “Most Excellent Dark Roast”;
}
public double cost() {

}

}

}

}

you are here 4
Download at WoweBook.Com

83

impact of change

See, ﬁve
classes total. This is
deﬁnitely the way to go.

I’m not so sure; I can
see some potential problems
with this approach by thinking
about how the design might need
to change in the future.

Sharpen your pencil
What requirements or other factors might change that will impact this design?

Price changes for condiments will force us to alter existing code.
New condiments will force us to add new methods and alter the cost method in the superclass.
We may have new beverages. For some of these beverages (iced tea?), the condiments
may not be appropriate, yet the Tea subclass will still inherit methods like hasWhip().
What if a customer wants a double mocha?
rn:

Your tu

84

Chapter 3
Download at WoweBook.Com

in
saw , this is
e
w
1
As pter idea!
Cha ery bad
av

the decorator pattern

Master and Student...
Master: Grasshopper, it has been some time since our last
meeting. Have you been deep in meditation on inheritance?
Student: Yes, Master. While inheritance is powerful, I have
learned that it doesn’t always lead to the most ﬂexible or
maintainable designs.
Master: Ah yes, you have made some progress. So, tell me my student, how
then will you achieve reuse if not through inheritance?
Student: Master, I have learned there are ways of “inheriting” behavior at
runtime through composition and delegation.
Master: Please, go on...
Student: When I inherit behavior by subclassing, that behavior is set statically
at compile time. In addition, all subclasses must inherit the same behavior. If
however, I can extend an object’s behavior through composition, then I can do
this dynamically at runtime.
Master: Very good, Grasshopper, you are beginning to see the power of
composition.
Student: Yes, it is possible for me to add multiple new responsibilities to objects
through this technique, including responsibilities that were not even thought of
by the designer of the superclass. And, I don’t have to touch their code!
Master: What have you learned about the effect of composition on maintaining
your code?
Student: Well, that is what I was getting at. By dynamically composing objects,
I can add new functionality by writing new code rather than altering existing
code. Because I’m not changing existing code, the chances of introducing bugs
or causing unintended side effects in pre-existing code are much reduced.
Master: Very good. Enough for today, Grasshopper. I would like for you to
go and meditate further on this topic... Remember, code should be closed (to
change) like the lotus ﬂower in the evening, yet open (to extension) like the
lotus ﬂower in the morning.

you are here 4
Download at WoweBook.Com

85

the open-closed principle

The Open-Closed Principle
Grasshopper is on to one of the most important design principles:

Design Principle
Classes should be open
for extension, but closed for
modiﬁcation.

Come on in; we’re
open. Feel free to extend
our classes with any new behavior you
like. If your needs or requirements change (and we
know they will), just go ahead and make your own
extensions.
Sorry, we’re closed.
That’s right, we spent
a lot of time getting this code correct and
bug free, so we can’t let you alter the existing code.
It must remain closed to modiﬁcation. If you don’t
like it, you can speak to the manager.

Our goal is to allow classes to be easily extended to
incorporate new behavior without modifying existing code.
What do we get if we accomplish this? Designs that are
resilient to change and ﬂexible enough to take on new
functionality to meet changing requirements.

86

Chapter 3
Download at WoweBook.Com

the decorator pattern

there are no

Dumb Questions

Q:

Open for extension and closed
for modiﬁcation? That sounds very
contradictory. How can a design be
both?

A:

That’s a very good question. It
certainly sounds contradictory at first.
After all, the less modifiable something
is, the harder it is to extend, right?
As it turns out, though, there are some
clever OO techniques for allowing
systems to be extended, even if we can’t
change the underlying code. Think
about the Observer Pattern (in Chapter
2)... by adding new Observers, we can
extend the Subject at any time, without
adding code to the Subject. You’ll see
quite a few more ways of extending
behavior with other OO design
techniques.

Q:

Okay, I understand Observable,
but how do I generally design
something to be extensible, yet closed
for modiﬁcation?

A:

Usually, you can’t. Making OO
design flexible and open to extension
without the modification of existing
code takes time and effort. In general,
we don’t have the luxury of tying down
every part of our designs (and it would
probably be wasteful). Following
the Open-Closed Principle usually
introduces new levels of abstraction,
which adds complexity to our code.
You want to concentrate on those areas
that are most likely to change in your
designs and apply the principles there.

Q:

How do I know which areas of
change are more important?

A:

That is partly a matter of
experience in designing OO systems and
also a matter of knowing the domain
you are working in. Looking at other
examples will help you learn to identify
areas of change in your own designs.

A:

While it may seem like a contradiction,
there are techniques for allowing code to be
extended without direct modification.

Q:

Be careful when choosing the areas of code
that need to be extended; applying the
Open-Closed Principle EVERYWHERE
is wasteful, unnecessary, and can lead to
complex, hard to understand code.

Many of the patterns give us
time tested designs that protect your
code from being modified by supplying
a means of extension. In this chapter
you’ll see a good example of using the
Decorator pattern to follow the OpenClosed principle.

How can I make every part of
my design follow the Open-Closed
Principle?

you are here 4
Download at WoweBook.Com

87

meet the decorator pattern

Meet the Decorator Pattern

Okay, enough of the “Object
Oriented Design Club.” We have real
problems here! Remember us? Starbuzz
Coffee? Do you think you could use
some of those design principles to
actually help us?

Okay, we’ve seen that representing our beverage plus condiment pricing
scheme with inheritance has not worked out very well – we get class
explosions, rigid designs, or we add functionality to the base class that isn’t
appropriate for some of the subclasses.
So, here’s what we’ll do instead: we’ll start with a beverage and “decorate”
it with the condiments at runtime. For example, if the customer wants a
Dark Roast with Mocha and Whip, then we’ll:

1

Take a DarkRoast object

2

Decorate it with a Mocha object

3

Decorate it with a Whip object

4

Call the cost() method and rely on
delegation to add on the condiment costs

Okay, but how do you “decorate” an object, and how does delegation
come into this? A hint: think of decorator objects as “wrappers.” Let’s
see how this works...

88

Chapter 3
Download at WoweBook.Com

the decorator pattern

Constructing a drink order with Decorators
1

We start with our DarkRoast object.

cost()

DarkRoast

2

t
DarkRoaasnd has
t
a
h
t
r
e
Rememb from Beverage mputes
inherits method that co
a cost() of the drink.
the cost

The customer wants Mocha, so we create a Mocha
object and wrap it around the DarkRoast.

. Its
ct is a decoratdor
je
ob
ha
oc
ating,
M
ec
he
T
object it is irorror”,
e
th
rs
ro
ir
m
pe
ty
Beverage. (By “m
in this case, a th
e same type..)
we mean it is

cost()

cost()

DarkRo

a st

Mocha

3

,
() method tootreat
st
co
a
s
a
h
a
ch
e can
So, Mo
olymorphism w
and through p wrapped in Mocha as
any Beveragetoo (because Mocha is a
a Beverage, Beverage).
subtype of

The customer also wants Whip, so we create a
Whip decorator and wrap Mocha with it.

cost()

cost()

Whip

cost()

DarkRoast

Mocha

Whip is a decorator, so it also
mirrors DarkRoast’s type and
includes a cost() method.

So, a DarkRoast wrapped in Mocha and Whip is still
a Beverage and we can do anything with it we can do
with a DarkRoast, including call its cost() method.
you are here 4
Download at WoweBook.Com

89

decorator characteristics

4

Now it’s time to compute the cost for the customer. We do this
by calling cost() on the outermost decorator, Whip, and Whip is
going to delegate computing the cost to the objects it decorates.
Once it gets a cost, it will add on the cost of the Whip.

in
(You’ll see how
)
s.
a few page

Mocha.
2 Whip calls cost() on
t() on the
1 First, we call cos
, Whip.
tor
ora
dec
outmost

$1.29

.10

3

cost()

.20

cost()

Whip
5

Whip adds its total, 10 cents,
to the result from Mocha, and
returns the ﬁnal result—$1.29.

5

Mocha calls cost() on
DarkRoast.

cost()

t
.99 D
ar k Ro as

Mocha

4

Dar kRoast
returns its cost,
99 cents.

Mocha adds its cost, 20
cents, to the result from
Dar kRoast, and returns
the new total, $1.19.

Okay, here’s what we know so far...
ß Decorators have the same supertype as the objects they decorate.
ß You can use one or more decorators to wrap an object.
ß Given that the decorator has the same supertype as the object it decorates, we can pass
around a decorated object in place of the original (wrapped) object.

ß The decorator adds its own behavior either before and/or after delegating to the object it
decorates to do the rest of the job.

ß Objects can be decorated at any time, so we can decorate objects dynamically at runtime
with as many decorators as we like.

Now let’s see how this all really works by looking at the
Decorator Pattern definition and writing some code.
90

Chapter 3
Download at WoweBook.Com

t!

Key Poin

the decorator pattern

The Decorator Pattern defined
Let’s ﬁrst take a look at the Decorator Pattern description:
The Decorator Pattern attaches additional
responsibilities to an object dynamically.
Decorators provide a ﬂexible alternative to
subclassing for extending functionality.

While that describes the role of the Decorator Pattern, it doesn’t give us a lot
of insight into how we’d apply the pattern to our own implementation. Let’s
take a look at the class diagram, which is a little more revealing (on the next
page we’ll look at the same structure applied to the beverage problem).

Each component can be used on its
own, or wrapped by a decorator.

Component

component

methodA()
methodB()

The ConcreteComponent
is the object we’re going
to dynamically add new
behavior to. It extends
Component.

// other methods

Decorator

ConcreteComponent
methodA()

methodA()

methodB()

methodB()

// other methods

// other methods

ConcereteDecoratorA
Component wrappedObj

s an
The ConcreteDecoratorehathing
th
r
fo
instance variable
t the
it decorate (the Componen
Decorator wraps).

Each decorator HAS-A
(wraps) a component, which
means the decorator has an
instance variable that holds
a reference to a component.

ent the
Decorators implem
abstract
same interfacemorponent they
class as the co corate.
are going to de
ConcereteDecoratorB
Component wrappedObj
Object newState

methodA()
methodB()
newBehavior()
// other methods

methodA()
methodB()
// other methods

e
Decorators can extendt.th
en
on
state of the comp

Decorators can add new methods; however, new
behavior is typically added by doing computation
before or after an existing method in the component.
you are here 4
Download at WoweBook.Com

91

decorating beverages

Decorating our Beverages
Okay, let’s work our Starbuzz beverages into this framework...

r
Beverage acts asneou
class.
nt
po
abstract com

component

Beverage
description
getDescription()
cost()
// other useful methods

HouseBlend

CondimentDecorator

DarkRoast

cost()

cost()

getDescription()

Decaf

Espresso
cost()

cost()

e
concretper
r
u
o
f
The nents, one
compo e type.
coffe

Milk

Soy

Mocha

Beverage beverage

Beverage beverage

Beverage beverage

Whip
Beverage beverage

cost()

cost()

cost()

cost()

getDescription()

getDescription()

getDescription()

getDescription()

And here are our condiment decorators; notice
they need to implement not only cost() but also
getDescription(). We’ll see why in a moment...

A

brain
power

Before going further, think about how you’d implement the cost() method of
the coffees and the condiments. Also think about how you’d implement the
getDescription() method of the condiments.

92

Chapter 3
Download at WoweBook.Com

the decorator pattern

Cubicle Conversation
Some confusion over Inheritance versus Composition

ry

Ma

Okay, I’m a little
confused...I thought we weren’t
going to use inheritance in this
pattern, but rather we were going
to rely on composition instead.

Sue: What do you mean?
Mary: Look at the class diagram. The CondimentDecorator is extending the Beverage class.
That’s inheritance, right?
Sue: True. I think the point is that it’s vital that the decorators have the same type as the
objects they are going to decorate. So here we’re using inheritance to achieve the type matching,
but we aren’t using inheritance to get behavior.
Mary: Okay, I can see how decorators need the same “interface” as the components they wrap
because they need to stand in place of the component. But where does the behavior come in?
Sue: When we compose a decorator with a component, we are adding new behavior. We
are acquiring new behavior not by inheriting it from a superclass, but by composing objects
together.
Mary: Okay, so we’re subclassing the abstract class Beverage in order to have the correct type,
not to inherit its behavior. The behavior comes in through the composition of decorators with
the base components as well as other decorators.
Sue: That’s right.
Mary: Ooooh, I see. And because we are using object composition, we get a whole lot more
ﬂexibility about how to mix and match condiments and beverages. Very smooth.
Sue: Yes, if we rely on inheritance, then our behavior can only be determined statically at
compile time. In other words, we get only whatever behavior the superclass gives us or that we
override. With composition, we can mix and match decorators any way we like... at runtime.
Mary: And as I understand it, we can implement new decorators at any time to add new
behavior. If we relied on inheritance, we’d have to go in and change existing code any time we
wanted new behavior.
Sue: Exactly.
Mary: I just have one more question. If all we need to inherit is the type of the component,
how come we didn’t use an interface instead of an abstract class for the Beverage class?
Sue: Well, remember, when we got this code, Starbuzz already had an abstract Beverage class.
Traditionally the Decorator Pattern does specify an abstract component, but in Java, obviously,
we could use an interface. But we always try to avoid altering existing code, so don’t “ﬁx” it if
the abstract class will work just ﬁne.
you are here 4
Download at WoweBook.Com

93

decorator training

New barista training

Okay, I need for you to
make me a double mocha,
soy latte with whip.

Make a picture for what happens when the order is for a
“double mocha soy latte with whip” beverage. Use the menu
to get the correct prices, and draw your picture using the
same format we used earlier (from a few pages back):
Mocha.
2 Whip calls cost() on

3

) on the
1 First, we call cost(
outmost decorator, Whip.

$1.29

.10

cost()

.20

cost()

Whip
5

Whip adds its total, 10 cents,
to the result from Mocha, and
returns the ﬁnal result—$1.29.

5

Mocha calls cost() on
DarkRoast.

cost()

t
.99 D
ar k Ro as

Mocha

4

was for
This picturoeast mocha
a “dark r rage.
whip” beve

DarkRoast
returns its cost,
99 cents.

Mocha adds its cost, 20
cents, to the result from
DarkRoast, and returns
the new total, $1.19.

Sharpen your pencil

Draw your picture here.

Starbuzz Coffee

Coffees
House Blend
.89
Dark Roast
.99
Decaf
1.05
Espresso
1.99
Condiments
Steamed Milk
.10
Mocha
.20
Soy
.15
Whip
.10

bu
tar zz

u
tarb zz

ffee S
Co

fe
Cof e S

e
doubl
e a “ hip”
k
a
m
w
h
can
oy,
: you te wit nd, S !
HINTha soy lat HouseBle and Whip
moc ombining Mocha
by c shots of
two

94

Chapter 3
Download at WoweBook.Com

the decorator pattern

Writing the Starbuzz code
It’s time to whip this design into some real code.
Let’s start with the Beverage class, which doesn’t need to
change from Starbuzz’s original design. Let’s take a look:

public abstract class Beverage {
String description = “Unknown Beverage”;
public String getDescription() {
return description;
}
public abstract double cost();
}

abstract
Beverage is an two methods
class with the n() and cost().
getDescriptio

getDescription is already
implemented for us, but we
need to implement cost()
in the subclasses.

Beverage is simple enough. Let’s implement the abstract
class for the Condiments (Decorator) as well:

to be
First, we needle with a Beverage,
interchangeab the Beverage class.
so we extend
public abstract class CondimentDecorator extends Beverage {
public abstract String getDescription();
}

We’re also going to require
that the condiment
decorators all reimplement the
getDescription() method. Again,
we’ll see why in a sec...

you are here 4
Download at WoweBook.Com

95

implementing the beverages

Coding beverages
Now that we’ve got our base classes out of the way, let’s
implement some beverages. We’ll start with Espresso.
Remember, we need to set a description for the speciﬁc
beverage and also implement the cost() method.

public class Espresso extends Beverage {
public Espresso() {
description = “Espresso”;
}
public double cost() {
return 1.99;
}
}

public double cost() {
return .89;
}

Okay, here’s another Beverage. All we
do is set the appropriate description,
“House Blend Coffee,” and then return
the correct cost: 89¢.
You can create the other two Beverage classses
(DarkRoast and Decaf) in exactly the same way.

96

we
To take care of the description,the
for
or
uct
str
set this in the con
instance
class. Remember the description ge.
era
Bev
m
fro
d
variable is inherite

resso. We don’t
sp
E
an
of
st
co
to compute the
this class, we just
Finally, we needabout adding in condiments in.99.
need to worry the price of an Espresso: $1
need to return

public class HouseBlend extends Beverage {
public HouseBlend() {
description = “House Blend Coffee”;
}

}

d the Beverage.e
en
t
ex
e
w
st
ir
F
is a beverag
class, since this

Chapter 3
Download at WoweBook.Com

Coffee
Starbuzz
s
Coffee
Blend
e
s
u
o
H
oast
R
Dark
f
a
Dec
so
Espres

.89
.99
1.05
1.99

ents
Condim
d Milk
Steame
Mocha
Soy
Whip

.10
.20
.15
.10

the decorator pattern

Coding condiments
If you look back at the Decorator Pattern class diagram, you’ll
see we’ve now written our abstract component (Beverage), we
have our concrete components (HouseBlend), and we have our
abstract decorator (CondimentDecorator). Now it’s time to
implement the concrete decorators. Here’s Mocha:

or
Decorat
t
n
e
im
d
on
with
Mocha is a decorator, so we
ember, eCverage.
instantiate Mocg:ha
m
to
e
g
in
R
go
re
ator.
e’
ntDecor
W
Condime
extend
B
Beverage usin
extends
a reference to a
e
riable to hold th
va
ce
an
st
in
n
A
(1)
pping.
public class Mocha extends CondimentDecorator {
verage we are wra
be
Beverage beverage;
t this instance
(2) A way to seject we are
public Mocha(Beverage beverage) {
variable to thee,obwe’re going to to pass
this.beverage = beverage;
wrapping. Her e’re wrapping to the
}
the beverage wnstructor.
decorator’s co
public String getDescription() {
return beverage.getDescription() + “, Mocha”;
}
public double cost() {
return .20 + beverage.cost();
}
}

beverage
e the cost of our to
ut
mp
co
to
ed
e
ne
we
Now
delegate the call mpth
we
t,
rs
Fi
.
ha
e the
oc
ut
M
with
, so that it can co the result.
ng
ti
ra
co
de
’re
we
ct
obje
e cost of Mocha to
cost; then, we add th

We want our description to not only
include the beverage - say “Dark
Roast” - but also to include each
item decorating the beverage, for
instance, “Dark Roast, Mocha”. So
we first delegate to the object we are
decorating to get its description, then
append “, Mocha” to that description.

On the next page we’ll actually instantiate the beverage and
wrap it with all its condiments (decorators), but first...
Sharpen your pencil

Write and compile the code for the other Soy and Whip
condiments. You’ll need them to finish and test the application.

you are here 4
Download at WoweBook.Com

97

testing the beverages

Serving some coffees
Congratulations. It’s time to sit back, order a few coffees and marvel at
the ﬂexible design you created with the Decorator Pattern.

Here’s some test code to make orders:
public class StarbuzzCoffee {
public static void main(String args[]) {
Beverage beverage = new Espresso();
System.out.println(beverage.getDescription()
+ “ $” + beverage.cost());

ondiment.s
c
o
n
,
o
s
s
nd cost
an espre
Order upt its description a
and prin

oast object.
Make a DarkR
Beverage beverage2 = new DarkRoast();
Wrap it with a Mocha.
beverage2 = new Mocha(beverage2);
Wrap it in a second Mocha.
beverage2 = new Mocha(beverage2);
beverage2 = new Whip(beverage2);
Wrap it in a Whip.
System.out.println(beverage2.getDescription()
+ “ $” + beverage2.cost());
Beverage beverage3 = new HouseBlend();
beverage3 = new Soy(beverage3);
beverage3 = new Mocha(beverage3);
beverage3 = new Whip(beverage3);
System.out.println(beverage3.getDescription()
+ “ $” + beverage3.cost());

}
}

Now, let’s get those orders in:

We’re going to see a much better way of
creating decorated objects when we cover the
Factory Pattern (and the Builder Pattern,
which is covered in the appendix).

File Edit Window Help CloudsInMyCoffee

% java StarbuzzCoffee
Espresso $1.99
Dark Roast Coffee, Mocha, Mocha, Whip $1.49
File Edit Window Help CloudsInMyCoffee
House Blend Coffee, Soy, Mocha, Whip $1.34
%

98

Finally, give us a HouseBlend
with Soy, Mocha, and Whip.

Chapter 3
Download at WoweBook.Com

the decorator pattern

there are no

Dumb Questions

Q:

I’m a little worried about code
that might test for a specfic concrete
component – say, HouseBlend – and
do something, like issue a discount.
Once I’ve wrapped the HouseBlend
with decorators, this isn’t going to work
anymore.

A:

That is exactly right. If you have
code that relies on the concrete component’s
type, decorators will break that code.
As long as you only write code against
the abstract component type, the use of
decorators will remain transparent to your
code. However, once you start writing code
against concrete components, you’ll want to
rethink your application design and your use
of decorators.

Q:

Wouldn’t it be easy for some
client of a beverage to end up with
a decorator that isn’t the outermost
decorator? Like if I had a DarkRoast with
Mocha, Soy, and Whip, it would be easy
to write code that somehow ended up
with a reference to Soy instead of Whip,
which means it would not include Whip in
the order.

A:

You could certainly argue that
you have to manage more objects with
the Decorator Pattern and so there is
an increased chance that coding errors
will introduce the kinds of problems you
suggest. However, decorators are typically
created by using other patterns like Factory
and Builder. Once we’ve covered these
patterns, you’ll see that the creation of the
concrete component with its decorator is
“well encapsulated” and doesn’t lead to
these kinds of problems.

Q:

Can decorators know about the
other decorations in the chain? Say, I
wanted my getDecription() method to
print “Whip, Double Mocha” instead of
“Mocha, Whip, Mocha”? That would
require that my outermost decorator
know all the decorators it is wrapping.

A:

Decorators are meant to add
behavior to the object they wrap. When
you need to peek at multiple layers into
the decorator chain, you are starting to
push the decorator beyond its true intent.
Nevertheless, such things are possible.
Imagine a CondimentPrettyPrint decorator
that parses the final decription and can print
“Mocha, Whip, Mocha” as “Whip, Double
Mocha.” Note that getDecription() could
return an ArrayList of descriptions to make
this easier.

Sharpen your pencil
Our friends at Starbuzz have introduced sizes to their menu. You can now order
a coffee in tall, grande, and venti sizes (translation: small, medium, and large).
Starbuzz saw this as an intrinsic part of the coffee class, so they’ve added two
methods to the Beverage class: setSize() and getSize(). They’d also like for the
condiments to be charged according to size, so for instance, Soy costs 10¢, 15¢
and 20¢ respectively for tall, grande, and venti coffees.
How would you alter the decorator classes to handle this change in requirements?

you are here 4
Download at WoweBook.Com

99

decorators in java i/o

Real World Decorators: Java I/O
The large number of classes in the java.io package is... overwhelming. Don’t feel alone
if you said “whoa” the ﬁrst (and second and third) time you looked at this API. But
now that you know the Decorator Pattern, the I/O classes should make more sense
since the java.io package is largely based on Decorator. Here’s a typical set of
objects that use decorators to add functionality to reading data from a ﬁle:

A text file for reading.

ered

e
InputStr

a

ff

m

ne
Nu
mberInputStrea

LineNumberInputStream is
also a concrete decorator.
It adds the ability to
count the line numbers as
it reads data.

m

Li

Bu

FileInputStream

BufferedInputStream
is a concrete decorator.
BufferedInputStream adds
behavior in two ways: it
buffers input to improve
performance, and also augments
the interface with a new
method readLine() for reading
character-based input, a line
at a time.

at’s
omponent th y
c
e
h
t
is
m
a
e
ar
FileInputStr ted The Java I/O libr g
a
in
r
d
o
c
lu
being de ral components, inc tStream,
supplies seveream, StringBufferInpu others.
FileInputSt putStream and a fewent from
ByteArrayIn give us a base compon
All of thesead bytes.
which to re

BufferedInputStream and LineNumberInputStream both extend
FilterInputStream, which acts as the abstract decorator class.

100

Chapter 3
Download at WoweBook.Com

the decorator pattern

Decorating the java.io classes
.

t component

bstrac
Here’s our a

FilterInputStream
is an abstract
decorator.

InputStream

FileInputStream

StringBufferInputStream

PushbackInputStream

These InputStreams act as
the concrete components that
we will wrap with decorators.
There are a few more we didn’t
show, like ObjectInputStream.

ByteArrayInputStream

BufferedInputStream

FilterInputStream

DataInputStream

LineNumberInputStream

crete decorators.

And finally, here are all our con

You can see that this isn’t so different from the Starbuzz design. You should
now be in a good position to look over the java.io API docs and compose
decorators on the various input streams.
And you’ll see that the output streams have the same design. And you’ve
probably already found that the Reader/Writer streams (for character-based
data) closely mirror the design of the streams classes (with a few differences
and inconsistencies, but close enough to ﬁgure out what’s going on).
But Java I/O also points out one of the downsides of the Decorator Pattern:
designs using this pattern often result in a large number of small classes
that can be overwhelming to a developer trying to use the Decorator-based
API. But now that you know how Decorator works, you can keep things in
perspective and when you’re using someone else’s Decorator-heavy API, you
can work through how their classes are organized so that you can easily use
wrapping to get the behavior you’re after.

you are here 4
Download at WoweBook.Com

101

write your own i/o decorator

Writing your own Java I/O Decorator
Okay, you know the Decorator Pattern, you’ve
seen the I/O class diagram. You should be ready to
write your own input decorator.
How about this: write a decorator that converts
all uppercase characters to lowercase in the
input stream. In other words, if we read in “I
know the Decorator Pattern therefore I RULE!”
then your decorator converts this to “i know the
decorator pattern therefore i rule!”

t to import
e
g
r
o
f
’t
n
o
D
t shown)
java.io... (no

No problem. I just have to
extend the FilterInputStream class
and override the read() methods.

First, extend the FilterInputStream, the
abstract decorator for all InputStreams.

public class LowerCaseInputStream extends FilterInputStream {
public LowerCaseInputStream(InputStream in) {
super(in);
}
public int read() throws IOException {
int c = super.read();
return (c == -1 ? c : Character.toLowerCase((char)c));
}

}

public int read(byte[] b, int offset, int len) throws IOException {
int result = super.read(b, offset, len);
for (int i = offset; i < offset+result; i++) {
b[i] = (byte)Character.toLowerCase((char)b[i]);
Now we need to implement two
}
read methods. They take a
return result;
byte (or an array of bytes)
}
convert each byte (that

REMEMBER: we don’t provide import and package
statements in the code listings. Get the complete
source code from the headfirstlabs web site. You’ll
find the URL on page xxxiii in the Intro.
102

Chapter 3
Download at WoweBook.Com

and
represents a character) to
lowercase if it’s an uppercase
character.

the decorator pattern

Test out your new Java I/O Decorator
Write some quick code to test the I/O decorator:
public class InputTest {
public static void main(String[] args) throws IOException {
int c;
try {
m
InputStream in =
ileInputStrea
new LowerCaseInputStream(
Set up the tFe it, first with
new BufferedInputStream(
and decoradInputStream
new FileInputStream(“test.txt”)));
Buffere

a
brand new
and then ouInr putStream filter.
LowerCase

while((c = in.read()) >= 0) {
System.out.print((char)c);
}
in.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}

I know the Decorator Pattern therefore I RULE!

Just use the stream to read
characters until the end of
file and print as we go.

test.txt ﬁle

You need tfoile.
make this

Give it a spin:
File Edit Window Help DecoratorsRule

% java InputTest
i know the decorator pattern therefore i rule!
%

you are here 4
Download at WoweBook.Com

103

decorator interview

Patterns Exposed
This week’s interview:

Confessions of a Decorator
HeadFirst: Welcome Decorator Pattern. We’ve heard that you’ve been a bit
down on yourself lately?
Decorator: Yes, I know the world sees me as the glamorous design pattern, but
you know, I’ve got my share of problems just like everyone.
HeadFirst: Can you perhaps share some of your troubles with us?
Decorator: Sure. Well, you know I’ve got the power to add ﬂexibility to
designs, that much is for sure, but I also have a dark side. You see, I can sometimes
add a lot of small classes to a design and this occasionally results in a design
that’s less than straightforward for others to understand.
HeadFirst: Can you give us an example?
Decorator: Take the Java I/O libraries. These are notoriously difﬁcult for
people to understand at ﬁrst. But if they just saw the classes as a set of wrappers
around an InputStream, life would be much easier.
HeadFirst: That doesn’t sound so bad. You’re still a great pattern, and
improving this is just a matter of public education, right?
Decorator: There’s more, I’m afraid. I’ve got typing problems: you see,
people sometimes take a piece of client code that relies on speciﬁc types and
introduce decorators without thinking through everything. Now, one great thing
about me is that you can usually insert decorators transparently and
the client never has to know it’s dealing with a decorator. But like I
said, some code is dependent on speciﬁc types and when you start introducing
decorators, boom! Bad things happen.
HeadFirst: Well, I think everyone understands that you have to be careful
when inserting decorators, I don’t think this is a reason to be too down on
yourself.
Decorator: I know, I try not to be. I also have the problem that introducing
decorators can increase the complexity of the code needed to instantiate the
component. Once you’ve got decorators, you’ve got to not only instantiate the
component, but also wrap it with who knows how many decorators.
HeadFirst: I’ll be interviewing the Factory and Builder patterns next week – I
hear they can be very helpful with this?
Decorator: That’s true; I should talk to those guys more often.
HeadFirst: Well, we all think you’re a great pattern for creating ﬂexible designs
and staying true to the Open-Closed Principle, so keep your chin up and think
positively!
Decorator: I’ll do my best, thank you.
104

Chapter 3
Download at WoweBook.Com

the decorator pattern

Tools for your Design Toolbox

BULLET POINTS

You’ve got another chapter under
your belt and a new principle and
pattern in the toolbox.

ß Inheritance is one form of
extension, but not necessarily
the best way to achieve flexibility
in our designs.

ß In our designs we should allow
behavior to be extended without
the need to modify existing code.

OO Basincs
Abstractio
n
O Principles Encapsulatio

ß Composition and delegation
can often be used to add new
behaviors at runtime.

O

m
Polymorphis
s.
ie
r
a
v
t
a
h
w
Encapsulate
nchee. ritance
r inheritaIn
e
v
o
n
io
t
si
o
Favor comp
not
interfaces,
o
t
m
a
r
g
o
r
P
ions.
implementat
ns
oupled desig
c
ly
se
o
lo
r
ct.
Strive fo
that intera
s
t
c
je
b
o
n
e
betwe
We now have the Open-Closed
open for

ld be
Classes shouut closed for
extension b n.
modificatio

Principle to guide us. We’re going
to strive to design our system
so that the closed parts are .
isolated from our new extensions

OO Patterr-ndsefineysofa aolgneor-itthom-s,tmhaanty

bys-erdvefeinyesbaetfwameilenkeosbjethcetms soddaitllioitnsal
O
g
e
t
a
Str depenedaecnhcone, andrm-aanAgtets ascthaotareit, hm
o ch
lg pddaytneadmically.
encapsuwlahteensDoenc.e oSortbrajeattcetgy slettsoietahdne aaonbdjecutit
able
arilroitme ienclioetniftsidtehaat fulesexib. le
interchdanegpeernedseptnolytnsib
f
n
tending
s prov
nde
vary indaeupteoDmeactoicralltyor o subclassing for ex
t
alternative y.
functionalit
igns
for creating dreswas it
n
er
t
t
pa
st
ir
f
O
And here’s ourthe Open-Closed Principle. ern we’ve
that satisfy st? Is there another patt
really the fir lows this principle as well?
used that fol
Download at WoweBook.Com

ß The Decorator Pattern provides
an alternative to subclassing for
extending behavior.

ß The Decorator Pattern involves
a set of decorator classes that
are used to wrap concrete
components.

ß Decorator classes mirror the
type of the components they
decorate. (In fact, they are the
same type as the components
they decorate, either through
inheritance or interface
implementation.)

ß Decorators change the behavior
of their components by adding
new functionality before and/or
after (or even in place of) method
calls to the component.

ß You can wrap a component with
any number of decorators.

ß Decorators are typically
transparent to the client of the
component; that is, unless
the client is relying on the
component’s concrete type.

ß Decorators can result in many
small objects in our design, and
overuse can be complex.
you are here 4

105

H[HUFLVHVROXWLRQV

([HUFLVHVROXWLRQV
SXEOLFFODVV%HYHUDJH^
GHFODUHLQVWDQFHYDULDEOHVIRUPLON&RVW
VR\&RVWPRFKD&RVWDQGZKLS&RVWDQG
JHWWHUVDQGVHWWHUVIRUPLONVR\PRFKD
DQGZKLS

SXEOLFFODVV'DUN5RDVWH[WHQGV%HYHUDJH^

SXEOLFGRXEOHFRVW ^

SXEOLF'DUN5RDVW ^
GHVFULSWLRQ ´0RVW([FHOOHQW'DUN5RDVWµ
`

GRXEOHFRQGLPHQW&RVW 
LI KDV0LON ^
FRQGLPHQW&RVW PLON&RVW
`
LI KDV6R\ ^
FRQGLPHQW&RVW VR\&RVW
`
LI KDV0RFKD ^
FRQGLPHQW&RVW PRFKD&RVW
`
LI KDV:KLS ^
FRQGLPHQW&RVW ZKLS&RVW
`
UHWXUQFRQGLPHQW&RVW
`
`

6M_JIZQ[\I\ZIQVQVO

SXEOLFGRXEOHFRVW ^
UHWXUQVXSHUFRVW 
`
`

´GRXEOHPRFKDVR\ODWWHZLWKZKLSµ
0RFKD
 :KLSFDOOVFRVW RQ
DQRWKHU0RFKD
 0RFKDFDOOVFRVW RQ
WKH
RFKDFDOOVFRVW RQ6R\
)LUVWZHFDOOFRVW RQ
 1H[W0
 RXWPRVWGHFRUDWRU: KLS
6R\FDOOV
 /DVWWRSSLQJ
FRVW RQ+RXVH%OHQG



QHHGG



VCTDW

\\%





FRVW

FRVW



FRVW



5




0

:



0

KLS

RFK

FRVW




RF


6R

\

KD

:KLS·VFRVW ZKLFKDGGVDQG
ZHKDYHDÀQDOFRVWRI

&KDSWHU
Download at WoweBook.Com



6R\·VFRVW PHWKRG
DGGVDQGUHWXUQV
WKHUHVXOWDQGSRSV
RIIWKHVWDFN

7KHVHFRQG0RFKD·V
FRVW PHWKRGDGGV
DQGUHWXUQVWKHUHVXOW
DQGSRSVRIIWKHVWDFN

D

 )LQDOO\WKHUHVXOWUHWXUQVWR



FRVW


QG
+
RXVH%OH

+RXVH%OHQG·VFRVW 
PHWKRGUHWXUQV
FHQWVDQGSRSVRII
WKHVWDFN

!

WKRG
7KHÀUVW0RFKD·VFRVW PH
VXOW
DGGVDQGUHWXUQVWKHUH
DQGSRSVRIIWKHVWDFN

the decorator pattern

Exercise solutions
Our friends at Starbuzz have introduced sizes to their menu. You can now order a coffee in
tall, grande, and venti sizes (for us normal folk: small, medium, and large). Starbuzz saw this
as an intrinsic part of the coffee class, so they’ve added two methods to the Beverage class:
setSize() and getSize(). They’d also like for the condiments to be charged according to size, so
for instance, Soy costs 10¢, 15¢, and 20¢ respectively for tall, grande, and venti coffees.
How would you alter the decorator classes to handle this change in requirements?

public class Soy extends CondimentDecorator {
Beverage beverage;
public Soy(Beverage beverage) {
this.beverage = beverage;
}
public int getSize() {
return beverage.getSize();
}

propagate the
Now we need thoo d to the wrapped
getSize() mete should also move this
beverage. W he abstract class since
method to t l condiment decorators.
it’s used in al

public String getDescription() {
return beverage.getDescription() + “, Soy”;
}
public double cost() {
double cost = beverage.cost();
if (getSize() == Beverage.TALL) {
cost += .10;
} else if (getSize() == Beverage.GRANDE) {
cost += .15;
} else if (getSize() == Beverage.VENTI) {
cost += .20;
}
return cost;
}

Here we get the size (which
propagates all the way to the
concrete beverage) and then
add the appropriate cost.

}

you are here 4
Download at WoweBook.Com

107

Download at WoweBook.Com

4 the Factory Pattern

g

h

Baking with OO Goodness

g

Get ready to bake some loosely coupled OO designs. There is more to
making objects than just using the new operator. You’ll learn that instantiation is an activity that
shouldn’t always be done in public and can often lead to coupling problems. And you don’t want
that, do you? Find out how Factory Patterns can help save you from embarrasing dependencies.

this is a new chapter
Download at WoweBook.Com

109

thinking about “new”

Okay, it’s been three chapters
and you still haven’t answered my
question about new. We aren’t supposed
to program to an implementation but
every time I use new, that’s exactly
what I’m doing, right?

When you see “new”, think “concrete”.
Yes, when you use new you are certainly instantiating a concrete
class, so that’s deﬁnitely an implementation, not an interface. And
it’s a good question; you’ve learned that tying your code to a
concrete class can make it more fragile and less ﬂexible.
Duck duck = new MallardDuck();

We want to use inter
to keep code flexible. faces

an
But we have to create class!
te
re
nc
co
a
instance of

When you have a whole set of related concrete classes, often you’re
forced to write code like this:
Duck duck;
if (picnic) {
duck = new MallardDuck();
} else if (hunting) {
duck = new DecoyDuck();
} else if (inBathTub) {
duck = new RubberDuck();
}

fferent
We have a bunch of didon’t know
duck classes, and we e we need
until runtime which on
to instantiate.

Here we’ve got several concrete classes being instantiated, and the
decision of which to instantiate is made at runtime depending on
some set of conditions.
When you see code like this, you know that when it comes time for
changes or extensions, you’ll have to reopen this code and examine
what needs to be added (or deleted). Often this kind of code ends
up in several parts of the application making maintenance and
updates more difﬁcult and error-prone.
110

Chapter 4
Download at WoweBook.Com

the factory pattern

But you have to create
an object at some point and
Java only gives us one way to
create an object, right? So
what gives?

What’s wrong with “new”?
Technically there’s nothing wrong with new, after all, it’s a
fundamental part of Java. The real culprit is our old friend
CHANGE and how change impacts our use of new.
By coding to an interface, you know you can insulate yourself
from a lot of changes that might happen to a system down
the road. Why? If your code is written to an interface, then
it will work with any new classes implementing that interface
through polymorphism. However, when you have code
that makes use of lots of concrete classes, you’re looking for
trouble because that code may have to be changed as new
concrete classes are added. So, in other words, your code
will not be “closed for modiﬁcation.” To extend it with new
concrete types, you’ll have to reopen it.
So what can you do? It’s times like these that you can fall back
on OO Design Principles to look for clues. Remember, our
ﬁrst principle deals with change and guides us to identify the
aspects that vary and separate them from what stays the same.

A

Remember tha
be “open for ext designs should
closed for mod tension but
see Chapter 3 ification” for a review.

brain
power

How might you take all the parts of your application that instantiate concrete classes and
separate or encapsulate them from the rest of your application?

you are here 4
Download at WoweBook.Com

111

identify what varies

Identifying the aspects that vary
Let’s say you have a pizza shop, and as a cutting-edge pizza store
owner in Objectville you might end up writing some code like this:
Pizza orderPizza() {
Pizza pizza = new Pizza();

For flexibility, we really want
this to be an abstract class or
interface, but we can’t directly
instantiate either of those.

pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}

But you need more than one type of pizza...

So then you’d add some code that determines the appropriate type of pizza
and then goes about making the pizza:

We’re now passing in
the type of pizza to
orderPizza.

Pizza orderPizza(String type) {
Pizza pizza;
if (type.equals(“cheese”)) {
pizza = new CheesePizza();
} else if (type.equals(“greek”) {
pizza = new GreekPizza();
} else if (type.equals(“pepperoni”) {
pizza = new PepperoniPizza();
}
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}

112

Based on the type of pizza, we
instantiate the correct concre
te class
and assign it to the pizza instanc
variable. Note that each pizza e
has to implement the Pizza int here
erface.

Once we have a Pizza, we prepare it
(you know, roll the dough, put on the
sauce and add the toppings & cheese),
then we bake it, cut it and box it!
Each Pizza subtype (CheesePizza,
VeggiePizza, etc.) knows how to
prepare itself.

Chapter 4
Download at WoweBook.Com

the factory pattern

But the pressure is on to add more pizza types
You realize that all of your competitors have added a couple of trendy pizzas to
their menus: the Clam Pizza and the Veggie Pizza. Obviously you need to keep
up with the competition, so you’ll add these items to your menu. And you haven’t
been selling many Greek Pizzas lately, so you decide to take that off the menu:

Pizza orderPizza(String type) {

ed
OT clos
N
is
e
d
This co dification. If es
for mo za Shop chang e
the Piz a offerings, w
its pizz get into this
have to d modify it.
code an

Pizza pizza;
if (type.equals(“cheese”)) {

ries.
This is what va
a
As the pizz s
selection change
over time, you’ll this
have to modify er.
code over and ov

pizza = new CheesePizza();
} else if (type.equals(“greek”) {
pizza = new GreekPizza();
} else if (type.equals(“pepperoni”) {
pizza = new PepperoniPizza();
} else if (type.equals(“clam”) {
pizza = new ClamPizza();
} else if (type.equals(“veggie”) {
pizza = new VeggiePizza();
}
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}

This is what we expect to stay
the same. For the most part,
preparing, cooking, and packaging
a pizza has remained the same
for years and years. So, we
don’t expect this code to change,
just the pizzas it operates on.

Clearly, dealing with which concrete class is instantiated is really messing up our
orderPizza() method and preventing it from being closed for modiﬁcation. But now
that we know what is varying and what isn’t, it’s probably time to encapsulate it.

you are here 4
Download at WoweBook.Com

113

encapsulate object creation

Encapsulating object creation
So now we know we’d be better off moving the object creation
out of the orderPizza() method. But how? Well, what
we’re going to do is take the creation code and move it out
into another object that is only going to be concerned with
creating pizzas.

if (type.equals(“cheese”)) {
pizza = new CheesePizza();
} else if (type.equals(“pepperoni”) {
pizza = new PepperoniPizza();
} else if (type.equals(“clam”) {
pizza = new ClamPizza();
} else if (type.equals(“veggie”) {
pizza = new VeggiePizza();
}

Pizza orderPizza(String type) {
Pizza pizza;

t
First we pull the objecthe
of
t
creation code ou
orderPizza Method

pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}

What’s

going t

o go he

re?

de in an object that
Then we place that co about how to create
is only going to worry object needs a pizza
pizzas. If any other ject to come to.
created, this is the ob

We’ve still got a few details to ﬁll in here; for instance, what does
the orderPizza() method replace its creation code with? Let’s
implement a simple factory for the pizza store and ﬁnd out...
114

Chapter 4
Download at WoweBook.Com

im
p

S

Factories handle the details of object creation. Once we have
a SimplePizzaFactory, our orderPizza() method just becomes a
client of that object. Any time it needs a pizza it asks the pizza
factory to make one. Gone are the days when the orderPizza()
method needs to know about Greek versus Clam pizzas. Now
the orderPizza() method just cares that it gets a pizza, which
implements the Pizza interface so that it can call prepare(),
bake(), cut(), and box().

to
ry

We’ve got a name for this new object: we
call it a Factory.

lePizzaFac

the factory pattern

Building a simple pizza factory
We’ll start with the factory itself. What we’re going to do is deﬁne a class that encapsulates the object
creation for all pizzas. Here it is...

plePizzaFactory. It has
Here’s our new class, the Sim s for its clients.
one job in life: creating pizza

public class SimplePizzaFactory {
public Pizza createPizza(String type) {
Pizza pizza = null;

a
n
efine method i e
d
e
w
h
)
t
First tePizza( . This is ill use to
crea factory lients w cts.
the hod all c new obje
met ntiate
insta

if (type.equals(“cheese”)) {
pizza = new CheesePizza();
} else if (type.equals(“pepperoni”)) {
pizza = new PepperoniPizza();
} else if (type.equals(“clam”)) {
pizza = new ClamPizza();
} else if (type.equals(“veggie”)) {
pizza = new VeggiePizza();
}
return pizza;

Here’s the code we
plucked out of the
orderPizza() method.

}
}

This code is still parameterized by
the type of the pizza, just like our
original orderPizza() method was.

Q:

What’s the advantage of this?
It looks like we are just pushing the
problem off to another object.

A:

One thing to remember is that the
SimplePizzaFactory may have many clients.
We’ve only seen the orderPizza() method;
however, there may be a PizzaShopMenu
class that uses the factory to get pizzas
for their current description and price. We
might also have a HomeDelivery class that
handles pizzas in a different way than our

there are no
Dumb
Questions
PizzaShop class but is also a client of the
factory.
So, by encapsulating the pizza creating
in one class, we now have only one
place to make modifications when the
implementation changes.
Don’t forget, we are also just about to
remove the concrete instantiations from our
client code!

Q:

I’ve seen a similar design where
a factory like this is defined as a static
method. What is the difference?

A:

Defining a simple factory as a
static method is a common technique and
is often called a static factory. Why use a
static method? Because you don’t need
to instantiate an object to make use of the
create method. But remember it also has
the disadvanage that you can’t subclass and
change the behavior of the create method.
you are here 4

Download at WoweBook.Com

115

simple factory

Reworking the PizzaStore class
Now it’s time to ﬁx up our client code. What we want to do is rely on the
factory to create the pizzas for us. Here are the changes:

Now we give PizzaStore a reference
to a SimplePizzaFactory.
public class PizzaStore {
SimplePizzaFactory factory;
public PizzaStore(SimplePizzaFactory factory) {
this.factory = factory;
}

PizzaStore gets the factory pas
sed to
it in the constructor.

public Pizza orderPizza(String type) {
Pizza pizza;
pizza = factory.createPizza(type);

And the orderPizza() method uses the
factory to create its pizzas by simply
passing on the type of the order.

pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
// other methods here
}

A

Notice that we’ve replaced the new
operator with a create method on the
factory object. No more concrete
instantiations here!

brain
power

We know that object composition allows us to change behavior dynamically at runtime (among
other things) because we can swap in and out implementations. How might we be able to use
that in the PizzaStore? What factory implementations might we be able to swap in and out?

We don’t know about you, but we’re thinking New York, Chicago, and California style pizza factories (let’s
not forget New Haven, too)

116

Chapter 4
Download at WoweBook.Com

the factory pattern

The Simple Factory defined

First
Head rable
o
Hon tion
Men

The Simple Factory isn’t actually a Design Pattern; it’s more of a programming idiom.
But it is commonly used, so we’ll give it a Head First Pattern Honorable Mention.
Some developers do mistake this idiom for the “Factory Pattern,” so the next time
there is an awkward silence between you and another developer, you’ve got a nice
topic to break the ice.

Pattern
Honorable
Mention

Just because Simple Factory isn’t a REAL pattern doesn’t mean we shouldn’t check out
how it’s put together. Let’s take a look at the class diagram of our new Pizza Store:

This is the factory where we create
pizzas; it should be the only part
of our application that refers to
concrete Pizza classes..

PizzaStore
orderPizza()

a
We’ve defined Pizzs
as
cl
as an abstract
with some helpful at
implementations th
can be overridden.

Pizza

SimplePizzaFactory
createPizza()

t of
This is the produca!
zz
pi
the factory:

prepare()
bake()
cut()

nt of the
This is the clieaStore
factory. Pizz ugh the
now goes throactory to get
SimplePizzaF zza.
instances of pi

d is often
The create metho .
declared statically

These are our concrete products.
product needs to implement the Each
Pizza
interface* (which in this case mea
“extend the abstract Pizza class”) ns
be concrete. As long as that’s the and
it can be created by the factor case,
y and
handed back to the client.

box()

PepperoniPizza

CheesePizza

VeggiePizza

ClamPizza

Think of Simple Factory as a warm up. Next, we’ll explore two heavy duty patterns
that are both factories. But don’t worry, there’s more pizza to come!

*Just another reminder: in design patterns, the phrase “implement an interface” does NOT always mean
“write a class the implements a Java interface, by using the “implements” keyword in the class declaration.” In
the general use of the phrase, a concrete class implementing a method from a supertype (which could be a
class OR interface) is still considered to be “implementing the interface” of that supertype.
you are here 4
Download at WoweBook.Com

117

pizza franchise

Franchising the pizza store
Your Objectville PizzaStore has done so well that you’ve trounced
the competition and now everyone wants a PizzaStore in their
own neighborhood. As the franchiser, you want to ensure the
quality of the franchise operations and so you want them to use
your time-tested code.
But what about regional differences? Each franchise might
want to offer different styles of pizzas (New York, Chicago, and
California, to name a few), depending on where the franchise
store is located and the tastes of the local pizza connoisseurs.

N

izzaFacto

zaStore

C

hi
cag

a
oPizzaF

We’ve seen one approach...
If we take out SimplePizzaFactory and create three different
factories, NYPizzaFactory, ChicagoPizzaFactory and
CaliforniaPizzaFactory, then we can just compose the PizzaStore
with the appropriate factory and a franchise is good to go. That’s
one approach.
Let’s see what that would look like...

118

ct
ory

Piz

YP

ry

You want all the franchise pizza stores
to leverage your PizzaStore code, so the
pizzas are prepared in the same way.

Chapter 4
Download at WoweBook.Com

One franchise wants a factory
that makes NY style pizzas:
thin crust, tasty sauce and
just a little cheese.

Another franchise
wants a factory that
makes Chicago style
pizzas; their customers
like pizzas with thick
crust, rich sauce, and
tons of cheese.

the factory pattern

Here we create a factory
for making NY style pizzas.

NYPizzaFactory nyFactory = new NYPizzaFactory();
PizzaStore nyStore = new PizzaStore(nyFactory);
nyStore.order(“Veggie”);

Then we create a PizzaStore and pass it
a reference to the NY factory.
...and when we make pizzas, we
get NY-styled pizzas.

ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();
PizzaStore chicagoStore = new PizzaStore(chicagoFactory);
chicagoStore.order(“Veggie”);

Likewise for the Chicago pizza stores: we create
a factory for Chicago pizzas and create a store
that is composed with a Chicago factory. When
we make pizzas, we get the Chicago flavored
ones

But you’d like a little more quality control...
So you test marketed the SimpleFactory idea, and what you
found was that the franchises were using your factory to
create pizzas, but starting to employ their own home grown
procedures for the rest of the process: they’d bake things a
little differently, they’d forget to cut the pizza and they’d use
third-party boxes.

I’ve been making pizza for
years so I thought I’d add my
own “improvements” to the
PizzaStore procedures...

Rethinking the problem a bit, you see that what you’d really
like to do is create a framework that ties the store and the
pizza creation together, yet still allows things to remain
ﬂexible.
In our early code, before the SimplePizzaFactory, we had
the pizza-making code tied to the PizzaStore, but it wasn’t
ﬂexible. So, how can we have our pizza and eat it too?

good
Not what you want in a want to know
franchise. You do NOT s.
what he puts on his pizza
you are here 4
Download at WoweBook.Com

119

let the subclasses decide

A framework for the pizza store
There is a way to localize all the pizza making activities to the PizzaStore
class, and yet give the franchises freedom to have their own regional style.
What we’re going to do is put the createPizza() method back into PizzaStore,
but this time as an abstract method, and then create a PizzaStore
subclass for each regional style.
First, let’s look at the changes to the PizzaStore:

PizzaStore is now abstract (see why below).
public abstract class PizzaStore {

public Pizza orderPizza(String type) {
Pizza pizza;

Now createPizza is back to being a
call to a method in the PizzaStore
rather than on a factory object.

pizza = createPizza(type);
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();

All this looks just the same...

return pizza;
}

abstract Pizza createPizza(String type);
}

Now we’ve moved our factory
object to this method.

Our “factory method” is now
abstract in PizzaStore.
Now we’ve got a store waiting for subclasses; we’re going to have a
subclass for each regional type (NYPizzaStore, ChicagoPizzaStore,
CaliforniaPizzaStore) and each subclass is going to make the decision about
what makes up a pizza. Let’s take a look at how this is going to work.

120

Chapter 4
Download at WoweBook.Com

the factory pattern

Allowing the subclasses to decide
Remember, the PizzaStore already has a well-honed order system in the orderPizza()
method and you want to ensure that it’s consistent across all franchises.
What varies among the regional PizzaStores is the style of pizzas they make – New York
Pizza has thin crust, Chicago Pizza has thick, and so on – and we are going to push all
these variations into the createPizza() method and make it responsible for creating the
right kind of pizza. The way we do this is by letting each subclass of PizzaStore deﬁne
what the createPizza() method looks like. So, we will have a number of concrete subclasses
of PizzaStore, each with its own pizza variations, all ﬁtting within the PizzaStore
framework and still making use of the well-tuned orderPizza() method.

Each subclass overrides the createPizza()
method, while all subclasses make use
of the orderPizza() method defined
in PizzaStore. We could make the
orderPizza() method final if we really
wanted to enforce this.

PizzaStore
createPizza()
orderPizza()

If a franchise wants NY style
pizzas for its customers, it
uses the NY subclass, which has
its own createPizza() method,
creating NY style pizzas.

NYStylePizzaStore

ChicagoStylePizzaStore
createPizza()

createPizza()

Remember: createPizza() is
abstract in PizzaStore, so all
pizza store subtypes MUST
implement the method.

Similarly, by using the
Chicago subclass, we get an
implementation of createPizza()
with Chicago ingredients.

public Pizza createPizza(type) {
public Pizza createPizza(type) {

if (type.equals(“cheese”)) {

if (type.equals(“cheese”)) {

pizza = new ChicagoStyleCheesePizza();

pizza = new NYStyleCheesePizza();

} else if (type.equals(“pepperoni”) {

} else if (type.equals(“pepperoni”) {

pizza = new ChicagoStylePepperoniPizza();

pizza = new NYStylePepperoniPizza();

} else if (type.equals(“clam”) {

} else if (type.equals(“clam”) {

pizza = new ChicagoStyleClamPizza();

pizza = new NYStyleClamPizza();

} else if (type.equals(“veggie”) {

} else if (type.equals(“veggie”) {

pizza = new ChicagoStyleVeggiePizza();

pizza = new NYStyleVeggiePizza();
}

}
}

}

you are here 4
Download at WoweBook.Com

121

how do subclasses decide?

I don’t get it. The
PizzaStore subclasses are just
subclasses. How are they deciding
anything? I don’t see any logical decisionmaking code in NYStylePizzaStore....

Well, think about it from the point of view of the PizzaStore’s orderPizza() method: it is
deﬁned in the abstract PizzaStore, but concrete types are only created in the subclasses.

in the abstract
orderPizza() is defined classes. So, the
PizzaStore, not the sub subclass is actually
method has no idea whichking the pizzas.
running the code and ma

PizzaStore
createPizza()
orderPizza()

Now, to take this a little further, the orderPizza() method does a lot of things with a
Pizza object (like prepare, bake, cut, box), but because Pizza is abstract, orderPizza() has
no idea what real concrete classes are involved. In other words, it’s decoupled!
PizzaStore

pizza = createPizza();
pizza.prepare();

createPizza()

pizza.bake();

orderPizza()

pizza.cut();
pizza.box();

Pizza() to actually get
orderPizza() calls createich kind of pizza will it
a pizza object. But wh method can’t decide; it
get? The orderPizza() o does decide?
doesn’t know how. So wh
When orderPizza() calls createPizza(), one of your subclasses will be called into action to
create a pizza. Which kind of pizza will be made? Well, that’s decided by the choice of
pizza store you order from, NYStylePizzaStore or ChicagoStylePizzaStore.

NYStylePizzaStore
createPizza()

ChicagoStylePizzaStore
createPizza()

So, is there a real-time decision that subclasses make? No, but from the perspective of
orderPizza(), if you chose a NYStylePizzaStore, that subclass gets to determine which
pizza is made. So the subclasses aren’t really “deciding” – it was you who decided by
choosing which store you wanted – but they do determine which kind of pizza gets made.

122

Chapter 4
Download at WoweBook.Com

the factory pattern

Let’s make a PizzaStore
Being a franchise has its beneﬁts. You get all the PizzaStore
functionality for free. All the regional stores need to do is subclass
PizzaStore and supply a createPizza() method that implements
their style of Pizza. We’ll take care of the big three pizza styles for
the franchisees.
Here’s the New York regional style:

Pizza, and the
createPizza() returns a for which
subclass is fully responsibleiates
concrete Pizza it instant

The NYPizzaStore extends
PizzaStore, so it inherits the
orderPizza() method (among others).

public class NYPizzaStore extends PizzaStore {
Pizza createPizza(String item) {
if (item.equals(“cheese”)) {
return new NYStyleCheesePizza();
} else if (item.equals(“veggie”)) {
return new NYStyleVeggiePizza();
} else if (item.equals(“clam”)) {
return new NYStyleClamPizza();
} else if (item.equals(“pepperoni”)) {
return new NYStylePepperoniPizza();
} else return null;
}
}

We’ve got to implement
createPizza(), since it is
abstract in PizzaStore.

Here’s where we create our
concrete classes. For each type
of Pizza we create the NY style.

* Note that the orderPizza() method in the
superclass has no clue which Pizza we are creating; it
just knows it can prepare, bake, cut, and box it!
Once we’ve got our PizzaStore subclasses built, it will be time
to see about ordering up a pizza or two. But before we do that,
why don’t you take a crack at building the Chicago Style and
California Style pizza stores on the next page.

you are here 4
Download at WoweBook.Com

123

factory method

Sharpen your pencil
We’ve knocked out the NYPizzaStore, just two more to go and we’ll be ready to franchise!
Write the Chicago and California PizzaStore implementations here:

124

Chapter 4
Download at WoweBook.Com

the factory pattern

Declaring a factory method
With just a couple of transformations to the PizzaStore we’ve gone from
having an object handle the instantiation of our concrete classes to a set of
subclasses that are now taking on that responsibility. Let’s take a closer look:

The subclasses of le object
PizzaStore handr us in the
instantiation fo ethod.
createPizza() m

public abstract class PizzaStore {

public Pizza orderPizza(String type) {
Pizza pizza;

NYStylePizzaStore
createPizza()

pizza = createPizza(type);
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();

ChicagoStylePizzaStore
createPizza()

return pizza;
}
protected abstract Pizza createPizza(String type);
// other methods here
}

All the responsibility for
instantiating Pizzas has been
moved into a method that
acts as a factory.

Code Up Close
A factory method handles object creation and encapsulates it in
a subclass. This decouples the client code in the superclass from
the object creation code in the subclass.

abstract Product factoryMethod(String type)

A factory method
abstract so the su is
A factory method returns
bc
la
ss
es
are counted on to
a Product that is typically
ha
nd
le
object creation.
used within methods defined
in the superclass.

hod may be
A factory met (or not)
parameterized several
to select among product.
variations of a

lates the client (the
A factory method iso like orderPizza())
code in the superclass, d of concrete
from knowing what kineated.
Product is actually cr
you are here 4

Download at WoweBook.Com

125

ordering a pizza

Let’s see how it works: ordering pizzas with
the pizza factory method

I like NY Style pizza... you
know, thin, crispy crust
with a little cheese and
really good sauce.

I like Chicago style deep dish
pizza with thick crust and
tons of cheese.

Joel

Ethan

Ethan needs to order
his pizza from a NY
pizza store.

Joel needs to order his
pizza from a Chicago
pizza store. Same pizza
ordering method, but
different kind of pizza!

So how do they order?

126

1

First, Joel and Ethan need an instance of a PizzaStore. Joel needs to instantiate a
ChicagoPizzaStore and Ethan needs a NYPizzaStore.

2

With a PizzaStore in hand, both Ethan and Joel call the orderPizza() method and pass
in the type of pizza they want (cheese, veggie, and so on).

3

To create the pizzas, the createPizza() method is called, which is deﬁned in the
two subclasses NYPizzaStore and ChicagoPizzaStore. As we deﬁned them, the
NYPizzaStore instantiates a NY style pizza, and the ChicagoPizzaStore instantiates
Chicago style pizza. In either case, the Pizza is returned to the orderPizza() method.

4

The orderPizza() method has no idea what kind of pizza was created, but it knows it is
a pizza and it prepares, bakes, cuts, and boxes it for Ethan and Joel.

Chapter 4
Download at WoweBook.Com

the factory pattern

Behind
the Scenes

Let’s check out how these pizzas are
really made to order...

1

Let’s follow Ethan’s order: ﬁrst we need a NY PizzaStore:
PizzaStore nyPizzaStore = new NYPizzaStore();

Creates a instance of
NYPizzaStore.

nyPizzaStore.orderPizza(“cheese”);

is called on
The orderPizza() methode (the method
the nyPizzaStore instance runs).
defined inside PizzaStor

3

The orderPizza() method then calls the createPizza()
method:
Pizza pizza

n yP

izzaSto

r

e

Now that we have a store, we can take an order:

createPizza(“cheese”)

2

= createPizza(“cheese”);

Remember, createPizza(), the factory
method, is implemented in the subclass. In
this case it returns a NY Cheese Pizza.
Pizza

4

Finally we have the unprepared pizza in hand and the
orderPizza() method ﬁnishes preparing it:
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();

od gets
The orderPizza() methknowing
t
back a Pizza, withou class it is.
exactly what concrete

e defined
All of these methods arturned
in the specific pizza re od
from the factory meth in the
createPizza(), defined
NYPizzaStore.

you are here 4
Download at WoweBook.Com

127

the pizza classes

We’re just missing one thing: PIZZA!
Our PizzaStore isn’t going to be very popular
without some pizzas, so let’s implement them:
ract
with an abst
We’ll start and all the concrete
Pizza class derive from this.
pizzas will
public abstract class Pizza {
String name;
String dough;
String sauce;
ArrayList toppings = new ArrayList();

gh, a
Each Pizza has a name, a type of dou
s.
type of sauce, and a set of topping

void prepare() {
System.out.println(“Preparing “ + name);
System.out.println(“Tossing dough...”);
System.out.println(“Adding sauce...”);
System.out.println(“Adding toppings: “);
for (int i = 0; i < toppings.size(); i++) {
System.out.println(“
“ + toppings.get(i));
}
}

The abstract class provides
some basic defaults for baking,
cutting and boxing.

void bake() {
System.out.println(“Bake for 25 minutes at 350”);
}

Preparation follows a
number of steps in a
particular sequence.

void cut() {
System.out.println(“Cutting the pizza into diagonal slices”);
}
void box() {
System.out.println(“Place pizza in ofﬁcial PizzaStore box”);
}
public String getName() {
return name;
}
}

REMEMBER: we don’t provide import and package statements in the
code listings. Get the complete source code from the headfirstlabs
web site. You’ll find the URL on page xxxiii in the Intro.
128

Chapter 4
Download at WoweBook.Com

the factory pattern

Now we just need some concrete subclasses... how about defining
New York and Chicago style cheese pizzas?

public class NYStyleCheesePizza extends Pizza {
public NYStyleCheesePizza() {
name = “NY Style Sauce and Cheese Pizza”;
dough = “Thin Crust Dough”;
sauce = “Marinara Sauce”;

The NY Pizza has its own
marinara style sauce and thin crust.

toppings.add(“Grated Reggiano Cheese”);
}
}

And one topping, reggiano

public class ChicagoStyleCheesePizza extends Pizza {
public ChicagoStyleCheesePizza() {
name = “Chicago Style Deep Dish Cheese Pizza”;
dough = “Extra Thick Crust Dough”;
sauce = “Plum Tomato Sauce”;
toppings.add(“Shredded Mozzarella Cheese”);
}

cheese!

The Chicago Pizza uses plum
tomatoes as a sauce along
with extra thick crust.

The Chicago style deep
dish pizza has lots of
mozzarella cheese!

void cut() {
System.out.println(“Cutting the pizza into square slices”);
}
}

The Chicago style pizza also overrides the cut()
method so that the pieces are cut into squares.

you are here 4
Download at WoweBook.Com

129

make some pizzas

You’ve waited long enough, time for some pizzas!
eate two
First we cr ores.
different st

public class PizzaTestDrive {
public static void main(String[] args) {
PizzaStore nyStore = new NYPizzaStore();
PizzaStore chicagoStore = new ChicagoPizzaStore();

Then use one one store
to make Ethan’s order.

Pizza pizza = nyStore.orderPizza(“cheese”);
System.out.println(“Ethan ordered a “ + pizza.getName() + “\n”);
pizza = chicagoStore.orderPizza(“cheese”);
System.out.println(“Joel ordered a “ + pizza.getName() + “\n”);
}
}

And the other for Joel’s.

File Edit Window Help YouWantMootzOnThatPizza?

%java PizzaTestDrive
Preparing NY Style Sauce and Cheese Pizza
Tossing dough...
Adding sauce...
Adding toppings:
Grated Regiano cheese
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in ofﬁcial PizzaStore box
Ethan ordered a NY Style Sauce and Cheese Pizza
Preparing Chicago Style Deep Dish Cheese Pizza
Tossing dough...
Adding sauce...
Adding toppings:
Shredded Mozzarella Cheese
Bake for 25 minutes at 350
Cutting the pizza into square slices
Place pizza in ofﬁcial PizzaStore box
Joel ordered a Chicago Style Deep Dish Cheese Pizza

130

Chapter 4
Download at WoweBook.Com

Both pizzas get prepared,
the toppings added, and the .
pizzas baked, cut and boxed
Our superclass never had to ss
know the details, the subcla
handled all that just by
.
instantiating the right pizza

the factory pattern

It’s finally time to meet the Factory Method Pattern
All factory patterns encapsulate object creation. The Factory Method Pattern encapsulates
object creation by letting subclasses decide what objects to create. Let’s check out these class
diagrams to see who the players are in this pattern:

The Creator classes
This is our abstract
cr
class. It defines an ab eator
factory method that stract
subclasses implement tothe
produce products.

PizzaStore
createPizza()
orderPizza()

ChicagoPizzaStore

NYPizzaStore

createPizza()

createPizza()

The cre
is our faatePizza() meth
produces ctory method. od
It
product
s.

Often the creator contains code that
depends on an abstract product, which
is produced by a subclass. The creator
never really knows which concrete
product was produced.

oduce
Classes that pr lled
products are ca rs
concrete creato

The Product classes

Factories produce products,
and in the PizzaStore, our
product is a Pizza.

Pizza

These are the concrete
products - all the pizzas that
are produced by our stores. NYStyleCheesePizza
NYStylePepperoniPizza
NYStyleClamPizza

Since each franchise gets its
own subclass of PizzaStore,
it’s free to create its
own style of pizza by
implementing createPizza().

ChicagoStyleCheesePizza
ChicagoStylePepperoniPizza
ChicagoStyleClamPizza

NYStyleVeggiePizza

ChicagoStyleVeggiePizza

you are here 4
Download at WoweBook.Com

131

creators and products

Another perspective: parallel class hierarchies
We’ve seen that the factory method provides a framework by supplying an
orderPizza() method that is combined with a factory method. Another way to look
at this pattern as a framework is in the way it encapsulates product knowledge into
each creator.
Let’s look at the two parallel class hierarchies and see how they relate:

The Product classes
Pizza

Notice how these
class hierarchies are
parallel: both have
abstract classes that
are extended by
concrete classes, which
know about specific
implementations for NY
and Chicago.

The Creator classes
PizzaStore
createPizza()
orderPizza()

NYStyleCheesePizza
NYStylePepperoniPizza
NYStyleClamPizza

NYStyleVeggiePizza

ChicagoStyleCheesePizza

NYPizzaStore
createPizza()

ChicagoStylePepperoniPizza

ChicagoPizzaStore
createPizza()

ChicagoStyleClamPizza
ChicagoStyleVeggiePizza

tes
e
psula to
a
c
n
e how
Stor
a
e
z
r
z
o
i
P
ut
St
icago s all the ow to .
izza edge aboas.
h
P
C
Y
e
e
l
N
z
Th apsulat about h pizzas
The the know tyle piz
enc ledge go style
all e NY s
know e Chica
mak
mak

The factory m

132

Chapter 4
Download at WoweBook.Com

ledge.

ating this know

y to encapsul
ethod is the ke

the factory pattern

Design Puzzle
We need another kind of pizza for those crazy Californians (crazy in a good way
of course). Draw another parallel set of classes that you’d need to add a new
California region to our PizzaStore.

PizzaStore
createPizza()
orderPizza()

rawing
Your d
NYPizzaStore
createPizza()

NYStyleCheesePizza
NYStylePepperoniPizza
NYStyleClamPizza

NYStyleVeggiePizza

here...

ChicagoPizzaStore
createPizza()

ChicagoStyleCheesePizza
ChicagoStylePepperoniPizza
ChicagoStyleClamPizza
ChicagoStyleVeggiePizza

Okay, now write the ﬁve most bizarre things you can think of to put on a pizza.
Then, you’ll be ready to go into business making pizza in California!

you are here 4
Download at WoweBook.Com

133

factory method deﬁned

Factory Method Pattern defined
It’s time to roll out the ofﬁcial deﬁnition of the Factory Method Pattern:
The Factory Method Pattern deﬁnes an interface
for creating an object, but lets subclasses decide which
class to instantiate. Factory Method lets a class defer
instantiation to subclasses.

As with every factory, the Factory Method Pattern gives us a way to encapsulate the
instantiations of concrete types. Looking at the class diagram below, you can see that the
abstract Creator gives you an interface with a method for creating objects, also known as the
“factory method.” Any other methods implemented in the abstract Creator are written to
operate on products produced by the factory method. Only subclasses actually implement
the factory method and create products.
As in the ofﬁcial deﬁnition, you’ll often hear developers say that the Factory Method lets
subclasses decide which class to instantiate. They say “decides” not because the pattern
allows subclasses themselves to decide at runtime, but because the creator class is written
without knowledge of the actual products that will be created, which is decided purely by
the choice of the subclass that is used.

hat
them wwe bet
k
s
a
d
ul
t
You co s” means, bu d this
e
n
a
d
i
“dec ow underst do !
you n r than they
bette

ains
a class that cont
The Creator is tions for all of the
the implementa ipulate products,
methods to man factory method.
except for the
Creator

Product

t implement
All products musace so that the
the same interfe the products
classes which us e interface,
can refer to thte class.
not the concre

factoryMethod()
anOperation()

ConcreteProduct

ConcreteCreator
factoryMethod()

The ConcreteCreator is responsible for
creating one or more concrete products. It
is the only class that has the knowledge of
how to create these products.
134

Chapter 4
Download at WoweBook.Com

The abstract factoryMethod()
is what all Creator subclasses
must implement.

The ConcreteCreator
implements the
factoryMethod(), which is
the method that actually
produces products.

the factory pattern

Q:

there are no
Dumb
Questions

What’s the advantage of the Factory Method
Pattern when you only have one ConcreteCreator?

A:

A:

We implemented what is known as the
parameterized factory method. It can make more than
one object based on a parameter passed in, as you
noticed. Often, however, a factory just produces one
object and is not parameterized. Both are valid forms
of the pattern.

The Factory Method Pattern is useful if
you’ve only got one concrete creator because you are
decoupling the implementation of the product from
its use. If you add additional products or change a
product’s implementation, it will not affect your Creator
(because the Creator is not tightly coupled to any
ConcreteProduct).

Q:

Q:

A:

Would it be correct to say that our NY and
Chicago stores are implemented using Simple
Factory? They look just like it.

A:

They’re similar, but used in different ways. Even
though the implementation of each concrete store looks
a lot like the SimplePizzaFactory, remember that the
concrete stores are extending a class which has defined
createPizza() as an abstract method. It is up to each
store to define the behavior of the createPizza() method.
In Simple Factory, the factory is another object that is
composed with the PizzaStore.

Q:

Are the factory method and the Creator
always abstract?

A:

No, you can define a default factory method
to produce some concrete product. Then you always
have a means of creating products even if there are no
subclasses of the Creator.

Q:

Each store can make four different kinds
of pizzas based on the type passed in. Do all
concrete creators make multiple products, or do they
sometimes just make one?

Your parameterized types don’t seem “typesafe.” I’m just passing in a String! What if I asked for
a “CalmPizza”?

You are certainly correct and that would cause,
what we call in the business, a “runtime error.” There
are several other more sophisticated techniques that
can be used to make parameters more “type safe”, or,
in other words, to ensure errors in parameters can be
caught at compile time. For instance, you can create
objects that represent the parameter types, use static
constants, or, in Java 5, you can use enums.

Q:

I’m still a bit confused about the difference
between Simple Factory and Factory Method. They
look very similar, except that in Factory Method, the
class that returns the pizza is a subclass. Can you
explain?

A:

You’re right that the subclasses do look a lot
like Simple Factory, however think of Simple Factory
as a one shot deal, while with Factory Method you are
creating a framework that let’s the subclasses decide
which implementation will be used. For example, the
orderPizza() method in the Factory Method provides a
general framework for creating pizzas that relies on a
factory method to actually create the concrete classes
that go into making a pizza. By subclassing the
PizzaStore class, you decide what concrete products
go into making the pizza that orderPizza() returns.
Compare that with SimpleFactory, which gives you a
way to encapsulate object creation, but doesn’t give
you the flexibility of the Factory Method because there
is no way to vary the products you’re creating.

you are here 4
Download at WoweBook.Com

135

master and student

Master and Student...
Master: Grasshopper, tell me how your training is going?
Student: Master, I have taken my study of “encapsulate what
varies” further.
Master: Go on...
Student: I have learned that one can encapsulate the code that
creates objects. When you have code that instantiates concrete
classes, this is an area of frequent change. I’ve learned a
technique called “factories” that allows you to encapsulate this
behavior of instantiation.
Master: And these “factories,” of what beneﬁt are they?
Student: There are many. By placing all my creation code in one
object or method, I avoid duplication in my code and provide one
place to perform maintenance. That also means clients depend
only upon interfaces rather than the concrete classes required to
instantiate objects. As I have learned in my studies, this allows me
to program to an interface, not an implementation, and that makes
my code more ﬂexible and extensible in the future.
Master: Yes Grasshopper, your OO instincts are growing. Do
you have any questions for your master today?
Student: Master, I know that by encapsulating object creation
I am coding to abstractions and decoupling my client code from
actual implementations. But my factory code must still use
concrete classes to instantiate real objects. Am I not pulling the
wool over my own eyes?
Master: Grasshopper, object creation is a reality of life; we must
create objects or we will never create a single Java program. But,
with knowledge of this reality, we can design our code so that we
have corralled this creation code like the sheep whose wool you
would pull over your eyes. Once corralled, we can protect and
care for the creation code. If we let our creation code run wild,
then we will never collect its “wool.”
Student: Master, I see the truth in this.
Master: As I knew you would. Now, please go and meditate on
object dependencies.

136

Chapter 4
Download at WoweBook.Com

the factory pattern

A very dependent PizzaStore
Sharpen your pencil
Let’s pretend you’ve never heard of an OO factory. Here’s a version of the PizzaStore that
doesn’t use a factory; make a count of the number of concrete pizza objects this class is
dependent on. If you added California style pizzas to this PizzaStore, how many objects would it
be dependent on then?
public class DependentPizzaStore {
public Pizza createPizza(String style, String type) {
Pizza pizza = null;
if (style.equals(“NY”)) {
if (type.equals(“cheese”)) {
pizza = new NYStyleCheesePizza();
} else if (type.equals(“veggie”)) {
Handles all the NY
pizza = new NYStyleVeggiePizza();
style pizzas
} else if (type.equals(“clam”)) {
pizza = new NYStyleClamPizza();
} else if (type.equals(“pepperoni”)) {
pizza = new NYStylePepperoniPizza();
}
} else if (style.equals(“Chicago”)) {
if (type.equals(“cheese”)) {
pizza = new ChicagoStyleCheesePizza();
Handles all the
} else if (type.equals(“veggie”)) {
Chicago style
pizza = new ChicagoStyleVeggiePizza();
pizzas
} else if (type.equals(“clam”)) {
pizza = new ChicagoStyleClamPizza();
} else if (type.equals(“pepperoni”)) {
pizza = new ChicagoStylePepperoniPizza();
}
} else {
System.out.println(“Error: invalid type of pizza”);
return null;
}
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
}

You can write
your answers here:

number

ifornia too

number with Cal

you are here 4
Download at WoweBook.Com

137

object dependencies

Looking at object dependencies
When you directly instantiate an object, you are depending on its
concrete class. Take a look at our very dependent PizzaStore one
page back. It creates all the pizza objects right in the PizzaStore class
instead of delegating to a factory.
If we draw a diagram representing that version of the PizzaStore
and all the objects it depends on, here’s what it looks like:

If the implemen
classes change, thtation of these
have to modify en we may
in PizzaStore.

This version of the
PizzaStore depends on all
those pizza objects, because
it’s creating them directly.

Because any changes to the concrete
implementations of pizzas affects the
PizzaStore, we say that the PizzaStore
“depends on” the pizza implementations.

Pizza

ePizza

he
es

oS
tyleC

Chapter 4
Download at WoweBook.Com

oni P z a
i z

er

Pizza

ie
zz a

Pi

lam

iPizza

on

oS
tyleC

g
ica
Ch

S
NY

Clam

ty
lePepp

S

yl
St

138

ty
le

go

Ve g g

g
ica
Ch

S
NY

NY

ty
le

eP
e p pe r

Every new kind of pizza
we add creates another
dependency for PizzaStore.

eg
giePizza

oS
tyleV

Che e

i ca
Ch

se
Pizza

g
ica
Ch

S
NY

ty
le

re

P

izzaSto

the factory pattern

The Dependency Inversion Principle
It should be pretty clear that reducing dependencies to
concrete classes in our code is a “good thing.” In fact, we’ve
got an OO design principle that formalizes this notion; it even
an
phrase you c in
r
e
h
t
o
n
a
has a big, formal name: Dependency Inversion Principle.
t
Ye
e execs

Here’s the general principle:

Design Principle

ss th
use to impreYour raise will
!
the room ffset the cost
more than o , and you’ll gain
of this book ion of your
the admiratlopers.
fellow deve

Depend upon abstractions. Do not
depend upon concrete classes.

At ﬁrst, this principle sounds a lot like “Program to an
interface, not an implementation,” right? It is similar;
however, the Dependency Inversion Principle makes an even
stronger statement about abstraction. It suggests that our
high-level components should not depend on our low-level
components; rather, they should both depend on abstractions.
But what the heck does that mean?
Well, let’s start by looking again at the pizza store diagram
on the previous page. PizzaStore is our “high-level
component” and the pizza implementations are our “lowlevel components,” and clearly the PizzaStore is dependent
on the concrete pizza classes.
Now, this principle tells us we should instead write our code
so that we are depending on abstractions, not concrete
classes. That goes for both our high level modules and our
low-level modules.

A “high-level” component is a class
with behavior defined in terms of
other, “low level” components.
For example, PizzaStore is a
high-level component because
its behavior is defined in terms
of pizzas - it creates all the
different pizza objects, prepares,
bakes, cuts, and boxes them, while
the pizzas it uses are low-level
components.

But how do we do this? Let’s think about how we’d
apply this principle to our Very Dependent PizzaStore
implementation...

you are here 4
Download at WoweBook.Com

139

dependency inversion principle

Applying the Principle
Now, the main problem with the Very Dependent PizzaStore is that it depends
on every type of pizza because it actually instantiates concrete types in its
orderPizza() method.
While we’ve created an abstraction, Pizza, we’re nevertheless creating concrete
Pizzas in this code, so we don’t get a lot of leverage out of this abstraction.
How can we get those instantiations out of the orderPizza() method? Well, as
we know, the Factory Method allows us to do just that.
So, after we’ve applied the Factory Method, our diagram looks like this:

nds only
PizzaStore now depect class.
ra
st
on Pizza, the ab

zaStor

e

Piz

Pizza is an abstract
class...an abstraction.

classes depend on
The concrete pizza too, because they
the Pizza abstractioninterface (remember,
implement the Pizza e” in the general
we’re using “interfac stract class.
sense) in the Pizza ab

oniP z
i za

Pizza

er

ie

ePizza

ty
lePepp

he
es

iPizza

on

Pizza

lam

g
ica
Ch

g
ica
Ch

oS
tyleC

Ve g g

S

oS
tyleV

go

eg
giePizza

ty
le

Clam

i ca
Ch

yl
St

S
NY

NY

g
ica
Ch

eP
e p pe r

zz a

ty
le

Che e

Pi

S
NY

S
NY

ty
le

se
Pizza

Pizza

oS
tyleC

After applying the Factory Method, you’ll notice that our high-level component,
the PizzaStore, and our low-level components, the pizzas, both depend on Pizza,
the abstraction. Factory Method is not the only technique for adhering to the
Dependency Inversion Principle, but it is one of the more powerful ones.

140

Chapter 4
Download at WoweBook.Com

the factory pattern

Okay, I get the dependency
part, but why is it called
dependency inversion?

Where’s the “inversion” in Dependency
Inversion Principle?
The “inversion” in the name Dependency Inversion
Principle is there because it inverts the way you
typically might think about your OO design. Look
at the diagram on the previous page, notice that the
low-level components now depend on a higher level
abstraction. Likewise, the high-level component
is also tied to the same abstraction. So, the top-tobottom dependency chart we drew a couple of pages
back has inverted itself, with both high-level and lowlevel modules now depending on the abstraction.
Let’s also walk through the thinking behind the typical
design process and see how introducing the principle
can invert the way we think about the design...

you are here 4
Download at WoweBook.Com

141

invert your thinking

Inverting your thinking...
Hmmm, Pizza Stores prepare, bake and
box pizzas. So, my store needs to be
able to make a bunch of different
pizzas: CheesePizza, VeggiePizza,
ClamPizza, and so on...

Well, a CheesePizza and a
VeggiePizza and a ClamPizza
are all just Pizzas, so they
should share a Pizza interface.

Okay, so you need to implement a PizzaStore.
What’s the ﬁrst thought that pops into your head?

Right, you start at top and follow things down to
the concrete classes. But, as you’ve seen, you don’t
want your store to know about the concrete pizza
types, because then it’ll be dependent on all those
concrete classes!
Now, let’s “invert” your thinking... instead of
starting at the top, start at the Pizzas and think
about what you can abstract.

Right! You are thinking about the abstraction
Pizza. So now, go back and think about the design
of the Pizza Store again.
Since I now have a Pizza
abstraction, I can design my
Pizza Store and not worry about
the concrete pizza classes.

Close. But to do that you’ll have to rely on a
factory to get those concrete classes out of
your Pizza Store. Once you’ve done that, your
different concrete pizza types depend only on an
abstraction and so does your store. We’ve taken
a design where the store depended on concrete
classes and inverted those dependencies (along
with your thinking).
142

Chapter 4
Download at WoweBook.Com

the factory pattern

A few guidelines to help you follow the
Principle...
The following guidelines can help you avoid OO designs that violate
the Dependency Inversion Principle:

be holding
If you use new, you’ll rete class.
nc
a reference to a co t around that!
Use a factory to ge

ß No variable should hold a reference to a concrete class.

ß No class should derive from a concrete class.

ß No method should override an implemented method of
any of its base classes.

If you derive from a concrete class,
you’re depending on a concrete class.
Derive from an abstraction, like an
interface or an abstract class.

If you override an
then your base clas implemented method,
abstraction to stars wasn’t really an
methods implemente t with. Those
meant to be shared d in the base class are
by all your subclass
es.

But wait, aren’t these
guidelines impossible to follow?
If I follow these, I’ll never be
able to write a single program!

You’re exactly right! Like many of our principles, this is a guideline
you should strive for, rather than a rule you should follow all the time.
Clearly, every single Java program ever written violates these guidelines!
But, if you internalize these guidelines and have them in the back of
your mind when you design, you’ll know when you are violating the
principle and you’ll have a good reason for doing so. For instance, if you
have a class that isn’t likely to change, and you know it, then it’s not the
end of the world if you instantiate a concrete class in your code. Think
about it; we instantiate String objects all the time without thinking twice.
Does that violate the principle? Yes. Is that okay? Yes. Why? Because
String is very unlikely to change.
If, on the other hand, a class you write is likely to change, you have some
good techniques like Factory Method to encapsulate that change.

you are here 4
Download at WoweBook.Com

143

families of ingredients

Meanwhile, back at the PizzaStore...
The design for the PizzaStore is really shaping up: it’s got a
ﬂexible framework and it does a good job of adhering to
design principles.

Dough
Pepperoni

Now, the key to Objectville Pizza’s success has
always been fresh, quality ingredients, and
what you’ve discovered is that with the
new framework your franchises have been
following your procedures, but a few franchises
have been substituting inferior ingredients
in their pies to lower costs and increase
their margins. You know you’ve got to do
something, because in the long term this is
going to hurt the Objectville brand!

Ensuring consistency in your
ingredients

Cheese

Sauce

So how are you going to ensure each franchise is using
quality ingredients? You’re going to build a factory that
produces them and ships them to your franchises!
Now there is only one problem with this plan: the franchises are located in
different regions and what is red sauce in New York is not red sauce in Chicago.
So, you have one set of ingredients that need to be shipped to New York and a
different set that needs to shipped to Chicago. Let’s take a closer look:

Chicago
PizzaMenu
Cheese Pizza

san,
Plum Tomato Sauce, Mozzarella, Parme
Oregano

Veggie Pizza

san,
Plum Tomato Sauce, Mozzarella, Parme
Eggplant, Spinach, Black Olives

We’ve got the
same product
families (dough,
sauce, cheese,
veggies, meats)
but different
implementations
based on region.

Cheese Pizza

Marinara Sauce, Reggiano, Garlic

Veggie Pizza

Marinara Sauce, Reggiano, Mushrooms,
Onions, Red Peppers

Clam Pizza

Clam Pizza

Pepperoni Pizza

Pepperoni Pizza

san, Clams
Plum Tomato Sauce, Mozzarella, Parme

Marinara Sauce, Reggiano, Fresh Clams

Marinara Sauce, Reggiano, Mushrooms,
Onions, Red Peppers, Pepperoni

san,
Plum Tomato Sauce, Mozzarella, Parme
oni
Eggplant, Spinach, Black Olives, Pepper

144

New York
PizzaMenu

Chapter 4
Download at WoweBook.Com

Veggies

the factory pattern

Families of ingredients...
New York uses one set of
ingredients and Chicago another.
Given the popularity of Objectville
Pizza it won’t be long before you
also need to ship another set of
regional ingredients to California,
and what’s next? Seattle?

Chicago
FrozenClams

MozzarellaCheese

For this to work, you are going to
have to ﬁgure out how to handle
families of ingredients.

New York

e same
e made from thent
ar
as
z
iz
P
s
e’
ill
All Objectv t each region has a differ
components, bu of those components.
implementation

FreshClams

MarinaraSauce

ThickCrustDough

PlumTomatoSauce

ThinCrustDough

California
ReggianoCheese
Calamari

VeryThinCrust

BruschettaSauce

GoatCheese

Each family consists of a type of dough,
a type of sauce, a type of cheese, and a
seafood topping (along with a few more we
haven’t shown, like veggies and spices).

lies, with
ke up ingredient fami ents.
ma
ns
gio
re
e
re
th
e
es
di
of ingre
In total, th
ing a complete family
each region implement
you are here 4
Download at WoweBook.Com

145

ingredient factories

Building the ingredient factories
Now we’re going to build a factory to create our ingredients; the
factory will be responsible for creating each ingredient in the
ingredient family. In other words, the factory will need to create
dough, sauce, cheese, and so on... You’ll see how we are going to
handle the regional differences shortly.
Let’s start by deﬁning an interface for the factory that is going to
create all our ingredients:

public interface PizzaIngredientFactory {
public
public
public
public
public
public

ea
ient we defin ce.
ed
gr
in
ch
ea
a
For
in our interf
create method

Dough createDough();
Sauce createSauce();
Cheese createCheese();
Veggies[] createVeggies();
Pepperoni createPepperoni();
Clams createClam();

}

Lots of new classes here,
one per ingredient.

nery”
If we’d had some common “machi
of
e
anc
to implement in each inst
s an
factory, we could have made thi
...
abstract class instead

Here’s what we’re going to do:

146

1

Build a factory for each region. To do this, you’ll create a subclass of
PizzaIngredientFactory that implements each create method

2

Implement a set of ingredient classes to be used with the factory, like
ReggianoCheese, RedPeppers, and ThickCrustDough. These classes can be
shared among regions where appropriate.

3

Then we still need to hook all this up by working our new ingredient
factories into our old PizzaStore code.

Chapter 4
Download at WoweBook.Com

the factory pattern

Building the New York ingredient factory
Okay, here’s the implementation for
the New York ingredient factory. This
factory specializes in Marinara sauce,
Reggiano Cheese, Fresh Clams...

ents
The NY ingredient factory implem
ent
edi
ingr
all
the interface for
factories

public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
public Dough createDough() {
return new ThinCrustDough();
}
public Sauce createSauce() {
return new MarinaraSauce();
}

ient in the
For each ingredily, we create
ingredient fam version.
the New York

public Cheese createCheese() {
return new ReggianoCheese();
}
public Veggies[] createVeggies() {
Veggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };
return veggies;
For veggies, we return an array of
}

Veggies. Here we’ve hardcoded the
veggies. We could make this more
sophisticated, but that doesn’t really
add anything to learning the factory
pattern, so we’ll keep it simple.

public Pepperoni createPepperoni() {
return new SlicedPepperoni();
}
public Clams createClam() {
return new FreshClams();
}
}

New York is on the coast; it
gets fresh clams. Chicago has
to settle for frozen.

The best sliced pepperoni. This
is shared between New York
and Chicago. Make sure you
use it on the next page when
you get to implement the
Chicago factory yourself

you are here 4
Download at WoweBook.Com

147

build a factory

Sharpen your pencil

Write the ChicagoPizzaIngredientFactory. You can
reference the classes below in your implementation:

EggPlant
Spinach

ThickCrustDough
SlicedPepperoni

BlackOlives

PlumTomatoSauce
FrozenClams
Mozzarella

148

Chapter 4
Download at WoweBook.Com

the factory pattern

Reworking the pizzas...
We’ve got our factories all ﬁred up and ready to produce quality ingredients; now we
just need to rework our Pizzas so they only use factory-produced ingredients. We’ll
start with our abstract Pizza class:

public abstract class Pizza {
String name;
Dough dough;
Sauce sauce;
Veggies veggies[];
Cheese cheese;
Pepperoni pepperoni;
Clams clam;

Each pizza holds a set of ingredients
that are used in its preparation.

We’ve now made the prepare method abstract.
This is where we are going to collect the
ingredients needed for the pizza, which of
course will come from the ingredient factory.

abstract void prepare();

void bake() {
System.out.println(“Bake for 25 minutes at 350”);
}
void cut() {
System.out.println(“Cutting the pizza into diagonal slices”);
}
void box() {
System.out.println(“Place pizza in ofﬁcial PizzaStore box”);
}
void setName(String name) {
this.name = name;
}
String getName() {
return name;
}

main the same, with
Our other methods ree prepare method.
the exception of th

public String toString() {
// code to print pizza here
}
}

you are here 4
Download at WoweBook.Com

149

decoupling ingredients

Reworking the pizzas, continued...
Now that you’ve got an abstract Pizza to work from, it’s time to create
the New York and Chicago style Pizzas – only this time around they will
get their ingredients straight from the factory. The franchisees’ days of
skimping on ingredients are over!
When we wrote the Factory Method code, we had a NYCheesePizza and
a ChicagoCheesePizza class. If you look at the two classes, the only thing
that differs is the use of regional ingredients. The pizzas are made just
the same (dough + sauce + cheese). The same goes for the other pizzas:
Veggie, Clam, and so on. They all follow the same preparation steps; they
just have different ingredients.
So, what you’ll see is that we really don’t need two classes for each pizza;
the ingredient factory is going to handle the regional differences for us.
Here’s the Cheese Pizza:

public class CheesePizza extends Pizza {
PizzaIngredientFactory ingredientFactory;
public CheesePizza(PizzaIngredientFactory ingredientFactory)
this.ingredientFactory = ingredientFactory;
}
void prepare() {
System.out.println(“Preparing “ + name);
dough = ingredientFactory.createDough();
sauce = ingredientFactory.createSauce();
cheese = ingredientFactory.createCheese();
}

we need
To make a pizza now,e the
a factory to provid Pizza
ingredients. So each
{ ss gets a factory passed
cla
and it’s
into its constructor,e variable.
stored in an instanc

Here’s where the magic happens!

}

The prepare() method steps through creating
a cheese pizza, and each time it needs an it.
ingredient, it asks the factory to produce

150

Chapter 4
Download at WoweBook.Com

the factory pattern

Code Up Close
The Pizza code uses the factory it has been composed with to produce the ingredients used in the
pizza. The ingredients produced depend on which factory we’re using. The Pizza class doesn’t care;
it knows how to make pizzas. Now, it’s decoupled from the differences in regional ingredients and
can be easily reused when there are factories for the Rockies, the Paciﬁc Northwest, and beyond.

sauce = ingredientFactory.createSauce();

We’re setting the
Pizza instance
variable to refer
the specific sauce to
used in this pizza.

This is our ingredient factory.
The Pizza doesn’t care which
factory is used, as long as it is
an ingredient factory.

e
thod returns the sauc
The createSauce() me n. If this is a NY
that is used in its regioen we get marinara sauce.
ingredient factory, th

Let’s check out the ClamPizza as well:

public class ClamPizza extends Pizza {
PizzaIngredientFactory ingredientFactory;
public ClamPizza(PizzaIngredientFactory ingredientFactory) {
this.ingredientFactory = ingredientFactory;
ClamPizza
}

also stashes an
ory.
fact
ingredient

void prepare() {
System.out.println(“Preparing “ + name);
dough = ingredientFactory.createDough();
sauce = ingredientFactory.createSauce();
cheese = ingredientFactory.createCheese();
clam = ingredientFactory.createClam();
}
}

To make a clam pizza, the
prepare method collects the right
ingredients from its local factory.

If it’s a New York factory,
the clams will be fresh; if it’s
Chicago, they’ll be frozen.
you are here 4
Download at WoweBook.Com

151

use the right ingredient factory

Revisiting our pizza stores
We’re almost there; we just need to make a quick trip to our
franchise stores to make sure they are using the correct
Pizzas. We also need to give them a reference to their local
ingredient factories:

public class NYPizzaStore extends PizzaStore {
protected Pizza createPizza(String item) {
Pizza pizza = null;
PizzaIngredientFactory ingredientFactory =
new NYPizzaIngredientFactory();
if (item.equals(“cheese”)) {
pizza = new CheesePizza(ingredientFactory);
pizza.setName(“New York Style Cheese Pizza”);
} else if (item.equals(“veggie”)) {
pizza = new VeggiePizza(ingredientFactory);
pizza.setName(“New York Style Veggie Pizza”);

a NY
posed with will
m
o
c
is
e
r
o
t
The NY S dient factory. This s
pizza ingre produce the ingredient
be used to style pizzas.
for all NY
We now pass each pizza the
factory that should be used to
produce its ingredients.
Look back one page and make sure
you understand how the pizza and
the factory work together!

} else if (item.equals(“clam”)) {
pizza = new ClamPizza(ingredientFactory);
pizza.setName(“New York Style Clam Pizza”);
} else if (item.equals(“pepperoni”)) {
pizza = new PepperoniPizza(ingredientFactory);
pizza.setName(“New York Style Pepperoni Pizza”);

For each type of Pizza, we
instantiate a new Pizza and give
it the factory it needs to get
its ingredients.

}
return pizza;
}
}

A

brain
power
Compare this version of the createPizza() method
to the one in the Factory Method implementation
earlier in the chapter.

152

Chapter 4
Download at WoweBook.Com

the factory pattern

What have we done?
That was quite a series of
code changes; what exactly
did we do?
We provided a means
of creating a family of
ingredients for pizzas by
introducing a new type of
factory called an Abstract
Factory.
An Abstract Factory gives
us an interface for creating
a family of products. By
writing code that uses this
interface, we decouple our
code from the actual factory
that creates the products.
That allows us to implement
a variety of factories that
produce products meant for
different contexts – such as
different regions, different
operating systems, or
different look and feels.
Because our code is
decoupled from the actual
products, we can substitute
different factories to get
different behaviors (like
getting marinara instead of
plum tomatoes).

An Abstract Factory provides an interface for
a family of products. What’s a family? In our
case it’s all the things we need to make a pizza:
dough, sauce, cheese, meats and veggies.

Defines the
interface.

ObjectvilleAbstract IngredientFactory
Provides ions
implementat s.
for product

Chicago

New York

From the abstract factory, we
derive one or more concrete
factories that produce the same
products, but with different
implementations.

Piz
zaStore

with
Pizza made produced by
ingredients ctory.
concrete fa

We then write our code so that it uses the
factory to create products. By passing in
a variety of factories, we get a variety of
implementations of those products. But
our client code stays the same.

you are here 4
Download at WoweBook.Com

153

order some more pizza

More pizza for Ethan and Joel...
Behind
the Scenes

Ethan and Joel can’t get enough Object ville Pizza! What they
don’t know is that now their orders are making use of the
new ingredient factories. So now when they order...

I’m stickin’
with Chicago.

I’m still lovin’ NY Style.

The first part of the order process hasn’t changed at
all. Let’s follow Ethan’s order again:

1

First we need a NY PizzaStore:
PizzaStore nyPizzaStore = new NYPizzaStore();

2

Now that we have a store, we can take an order:

n yP

izzaSto

r

e

Creates an instance of
NYPizzaStore.

nyPizzaStore.orderPizza(“cheese”);

is called on
the orderPizza() method e.
the nyPizzaStore instanc

3

The orderPizza() method ﬁrst calls the createPizza() method:
Pizza pizza

154

= createPizza(“cheese”);

Chapter 4
Download at WoweBook.Com

ese”)
zza(“che
createPi

the factory pattern

From here things change, because we
are using an ingredient factory

4

Behind
the Scenes

When the createPizza() method is called, that’s
when our ingredient factory gets involved:

ory is chosen and
The ingredient fact PizzaStore and then
instantiated in the tructor of each pizza.
passed into the cons
holds

Creates a instance of
Pizza that is composed
with the New York
ingredient factory.

ac
t or y

Pizza pizza = new CheesePizza(nyIngredientFactory);

n

yI
ngr
edientF

5

Next we need to prepare the pizza. Once the
prepare() method is called, the factory is asked
to prepare ingredients:
void prepare() {
dough = factory.createDough();
sauce = factory.createSauce();
cheese = factory.createCheese();
}

ust
Thin cr
Marinara

prepare()

Pizza

Reggiano

w York
For Ethan’s pizza the Ned, and so we
ingredient factory is use
get the NY ingredients.

6

Finally we have the prepared pizza in hand and the
orderPizza() method bakes, cuts, and boxes the pizza.
you are here 4
Download at WoweBook.Com

155

abstract factory deﬁned

Abstract Factory Pattern defined
We’re adding yet another factory pattern to our pattern family, one that lets us create families
of products. Let’s check out the ofﬁcial deﬁnition for this pattern:
The Abstract Factory Pattern provides an interface
for creating families of related or dependent objects
without specifying their concrete classes.

We’ve certainly seen that Abstract Factory allows a client to use an abstract interface to
create a set of related products without knowing (or caring) about the concrete products that
are actually produced. In this way, the client is decoupled from any of the speciﬁcs of the
concrete products. Let’s look at the class diagram to see how this all holds together:

The Client is written against the
abstract factory and then composed at
runtime with an actual factory.

The AbstractFactory defines the
interface that all Concrete factories
must implement, which consists of a set
of methods for producing products.

Client

This is the product
family. Each concrete
factory can produce an
entire set of products.

<<interface>>
AbstractFactory

<<interface>>
AbstractProductA

CreateProductA()
CreateProductB()

ProductA1

ProductA2

ConcreteFactory1

ConcreteFactory2

CreateProductA()

CreateProductA()

CreateProductB()

CreateProductB()

<<interface>>
AbstractProductB

The concrete factories implement the
different product families. To create a
product, the client uses one of these factories,
so it never has to instantiate a product object.

156

Chapter 4
Download at WoweBook.Com

ProductB2

ProductB1

the factory pattern

That’s a fairly complicated class
diagram; let’s look at it all in terms of
our PizzaStore:

The clients of the
Abstract Factory are
the concrete instances of
the Pizza abstract class.
Pizza
prepare()
// other methods

The abstract PizzaIngredientFactory
is the interface that defines how to
make a family of related products
- everything we need to make a pizza.

<<interface>>
Dough

ThickCrustDough

ThinCrustDough

<<interface>>
PizzaIngredientFactory
createDough()

<<interface>>
Sauce

createSauce()
createCheese()
createVeggies()
createPepperoni()

PlumTomatoSauce

createClam()

NYPizzaIngredientFactory

ChicagoPizzaIngredientFactory

createDough()

createDough()

createSauce()

createSauce()

createCheese()

createCheese()

createVeggies()

createVeggies()

createPepperoni()

createPepperoni()

createClam()

createClam()

MarinaraSauce

<<interface>>
Cheese

Mozzarella Cheese

ReggianoCheese

<<interface>>
Clams

The job of the concrete
pizza factories is to
make pizza ingredients.
Each factory knows
how to create the right
objects for their region.

FrozenClams

FreshClams

Each factory produces a different
implementation for the family of products.
you are here 4
Download at WoweBook.Com

157

interview with factory patterns

I noticed that each method in the
Abstract Factory actually looks like a Factory
Method (createDough(), createSauce(), etc.).
Each method is declared abstract and the
subclasses override it to create some
object. Isn’t that Factory Method?

Is that a Factory Method lurking inside the
Abstract Factory?
Good catch! Yes, often the methods of an Abstract Factory are
implemented as factory methods. It makes sense, right? The job of an
Abstract Factory is to deﬁne an interface for creating a set of products.
Each method in that interface is responsible for creating a concrete
product, and we implement a subclass of the Abstract Factory to
supply those implementations. So, factory methods are a natural way to
implement your product methods in your abstract factories.

Patterns Exposed
This week’s interview:

Factory Method and Abstract Factory, on each other
HeadFirst: Wow, an interview with two patterns at once! This is a ﬁrst for us.
Factory Method: Yeah, I’m not so sure I like being lumped in with Abstract Factory,
you know. Just because we’re both factory patterns doesn’t mean we shouldn’t get our own
interviews.
HeadFirst: Don’t be miffed, we wanted to interview you together so we could help clear up
any confusion about who’s who for the readers. You do have similarities, and I’ve heard that
people sometimes get you confused.
Abstract Factory: It is true, there have been times I’ve been mistaken for Factory Method,
and I know you’ve had similar issues, Factory Method. We’re both really good at decoupling
applications from speciﬁc implementations; we just do it in different ways. So I can see why
people might sometimes get us confused.
Factory Method: Well, it still ticks me off. After all, I use classes to create and you use
objects; that’s totally different!
158

Chapter 4
Download at WoweBook.Com

the factory pattern
HeadFirst: Can you explain more about that, Factory
Method?
Factory Method: Sure. Both Abstract Factory and
I create objects – that’s our jobs. But I do it through
inheritance...
Abstract Factory: ...and I do it through object
composition.
Factory Method: Right. So that means, to create
objects using Factory Method, you need to extend a class
and override a factory method.
HeadFirst: And that factory method does what?
Factory Method: It creates objects, of course! I mean,
the whole point of the Factory Method Pattern is that
you’re using a subclass to do your creation for you. In
that way, clients only need to know the abstract type they
are using, the subclass worries about the concrete type.
So, in other words, I keep clients decoupled from the
concrete types.
Abstract Factory: And I do too, only I do it in a
different way.
HeadFirst: Go on, Abstract Factory... you said
something about object composition?
Abstract Factory: I provide an abstract type for
creating a family of products. Subclasses of this type
deﬁne how those products are produced. To use the
factory, you instantiate one and pass it into some code
that is written against the abstract type. So, like Factory
Method, my clients are decoupled from the actual
concrete products they use.
HeadFirst: Oh, I see, so another advantage is that you
group together a set of related products.
Abstract Factory: That’s right.
HeadFirst: What happens if you need to extend that
set of related products, to say add another one? Doesn’t
that require changing your interface?

Factory Method: Oh, come on, that’s a big deal!
Changing your interface means you have to go in and
change the interface of every subclass! That sounds like a
lot of work.
Abstract Factory: Yeah, but I need a big interface
because I am used to create entire families of products.
You’re only creating one product, so you don’t really need
a big interface, you just need one method.
HeadFirst: Abstract Factory, I heard that you often use
factory methods to implement your concrete factories?
Abstract Factory: Yes, I’ll admit it, my concrete
factories often implement a factory method to create
their products. In my case, they are used purely to create
products...
Factory Method: ...while in my case I usually
implement code in the abstract creator that makes use of
the concrete types the subclasses create.
HeadFirst: It sounds like you both are good at what
you do. I’m sure people like having a choice; after all,
factories are so useful, they’ll want to use them in all
kinds of different situations. You both encapsulate
object creation to keep applications loosely coupled
and less dependent on implementations, which is really
great, whether you’re using Factory Method or Abstract
Factory. May I allow you each a parting word?
Abstract Factory: Thanks. Remember me, Abstract
Factory, and use me whenever you have families of
products you need to create and you want to make sure
your clients create products that belong together.
Factory Method: And I’m Factory Method; use me to
decouple your client code from the concrete classes you
need to instantiate, or if you don’t know ahead of time
all the concrete classes you are going to need. To use me,
just subclass me and implement my factory method!

Abstract Factory: That’s true; my interface has to
change if new products are added, which I know people
don’t like to do....
Factory Method: <snicker>
Abstract Factory: What are you snickering at,
Factory Method?
you are here 4
Download at WoweBook.Com

159

patterns compared

Factory Method and Abstract Factory compared
Provides an abstract
interface for
creating one product.

y
PizzaStore is implemented as a Factor
to
Method because we want to be able
create a product that varies by region.
With the Factory Method, each region
gets its own concrete factory that
knows how to make pizzas which are
appropriate for the area.

PizzaStore
createPizza()

which
Each subclass decidestantiate.
ins
concrete class to

New York Store

ChicagoPizzaStore

NYPizzaStore

The Factory Method

Chicago Store

createPizza()

createPizza()

The Factory Method

The NYPizzaStore subclass only
instantiates NY style pizzas.

This is the product of the
PizzaStore. Clients only
rely on this abstract type.

The ChicagaoPizzaStore
subclass instantiates only
Chicago style pizzas.

Pizza

NYStyleCheesePizza
NYStylePepperoniPizza
NYStyleClamPizza

Subclasses are instaniated
by the Factory Methods.

ChicagoStyleCheesePizza
ChicagoStylePepperoniPizza
ChicagoStyleClamPizza

ChicagoStyleVeggiePizza

NYStyleVeggiePizza

New York

The createPizza() method is parameterized by pizza
type, so we can return many types of pizza products.
160

Chapter 4
Download at WoweBook.Com

Chicago

the factory pattern

an
ry is implemented as
PizzaIngredientFactocause we need to create
Abstract Factory be(the ingredients). Each
families of products e ingredients using its own
subclass implements th
regional suppliers.

<<interface>>
PizzaIngredientFactory
createDough()

Provides an abstract g a
interface for creatin
family of products.

createSauce()
createCheese()
createVeggies()

Each concrete subclass
creates a family of products.

createPepperoni()
createClam()

New York

NYPizzaIngredientFactory

ChicagoPizzaIngredientFactory

createDough()

createDough()

createSauce()

createSauce()

createCheese()

createCheese()

createVeggies()

createVeggies()

createPepperoni()

createPepperoni()

createClam()

createClam()

...for instance, the subclass
decides the type of dough...

Methods to create products
in an Abstract Factory are
often implemented with a
Factory Method...

... or the type of clams.

<<interface>>
Clams

<<interface>>
Dough

ThinCrustDough

FreshClams

ThickCrustDough

<<interface>>
Sauce

MarinaraSauce

Chicago

PlumTomatoSauce

Each ingredient
represents a
product that is
produced by a d
Factory Metho
in the Abstract
Factory.

FrozenClams

<<interface>>
Cheese

ReggianoCheese

Mozzarella Cheese

The product subclasses create parallel sets of product families.
Here we have a New York ingredient family and a Chicago family.
you are here 4
Download at WoweBook.Com

161

your design toolbox

Tools for your Design Toolbox
In this chapter, we added two more tools to your
toolbox: Factory Method and Abstract Factory. Both
patterns encapsulate object creation and allow you to
decouple your code from concrete types.

s
OO Principle

creation.

ß Factory Method relies on
inheritance: object creation is
delegated to subclasses which
implement the factory method to
create objects.

ß Abstract Factory relies on object

We have a new principle that
guides us to keep things
abstract whenever possible.

composition: object creation
is implemented in methods
exposed in the factory interface.

ß All factory patterns promote
loose coupling by reducing the
dependency of your application
on concrete classes.

w patterns
Both of these nect creation
encapsulate obje e decoupled,
and lead to mor
flexible designs.

def de
atvide ayn.
mitio
sdydso
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyPrihnrtaohm
dntmatoak
AF
baccjeteshcottarhe
e
micall
e
d
go
b
o
t
al
ll
es
c
y
c
a
t
c
e
at
he
,
c
je
n
debstritSaietras ttceghoayannlegetossabttstinagtefamilieit. ss of
pulenA
encadpseD
e
it
il
r
.
t
b
e
silerofbje
reenanspge
asccepfrrofoomovirtdclifceieient
oinonnab
aednsftaletnhaxodbibtjeuleuspcdtasxttweeditndhoinugt
inter
teadeten
whch
ly
r
n
t
o
d
e
e
r
p
cnodrenreelanttseda or dsuebclassing eftoer celasses.
inpdeeep
varydeD
nativey to eir concr
auatltomerspatteioiccnifaallyliintyg. th
an
func
hod - Deofbinjeect, but
t
e
M
y
r
o
t
c
n
Fa e for creating a ss to
interfac es decide which cla s
let subclass . Factory Method lete
instantiate r instantiation to th
a class defe
subclasses.

162

ß All factories encapsulate object
fide design pattern, is a simple
way to decouple your clients
from concrete classes.

Abstraction
n
Encapsulatio
.
what varies
olymorphism
Encapsulate
heritanceP.
in
er
ov
n
io
sit
Favor compo
Inheritance

OO Patteinresnafsinfames ilya oofneal-gotori-tmhmnas,anly

BULLET POINTS

ß Simple Factory, while not a bona

OO Basics

, not
o interfaces
Program tat
ions.
implement
designs
ely coupledteract.
os
lo
or
f
ve
Stri
cts that in
between obje
tension
open for ex
e
b
ld
ou
sh
Classes for modification.
but closed
Do not
stractions. ses.
ab
on
d
en
Dep
ncrete clas
depend on co

.

Chapter 4
Download at WoweBook.Com

ß The intent of Factory Method
is to allow a class to defer
instantiation to its subclasses.

ß The intent of Abstract Factory
is to create families of related
objects without having to depend
on their concrete classes.

ß The Dependency Inversion
Principle guides us to avoid
dependencies on concrete types
and to strive for abstractions.

ß Factories are a powerful
technique for coding to
abstractions, not concrete
classes

the factory pattern

It’s been a long chapter. Grab a slice of Pizza and relax while doing
this crossword; all of the solution words are from this chapter.

�

�
�
�

�

�

�

�

�

��

��

��

��

��

��

������

����

�� �� ������� ������� ���� ��������� �� �
��������������
�� �� ������� ������� ��� ������� ����� �����
�� ������������
�����������������������������������������������
����������������������������������������������
������
���������������������������������������������������
� �������������
�� ���� ��� ��� ���� ��� ��� ����������� ��
�� �����������
��� ������������� �� � �������������� ����
������
��� ���� ����� ���� ���� �� �����
����������������������������������������������
�������� ������ ��� ������ �� ���� �����������
��� ���� � ����� ������������ �� ������ ���� �
�������� ������ ���� ���������� �� ���� ������
��� ��� ������� �������� ����� �� �� ����������
������ ��������

�� �� ���� �������������� �� ������ �������
��� �������� ������� ��� ����������� �� �������
������
�� �������� ������� ������� � ����������� ��
��������
�����������������������������������������
�����������
��� ����� ����� ���� ���� �� �����

you are here 4
Download at WoweBook.Com

163

exercise solutions

Exercise solutions
Sharpen your pencil
We’ve knocked out the NYPizzaStore; just two more to go and we’ll be ready to franchise!
Write the Chicago and California PizzaStore implementations here:

exactly like the New York
Both of these stores are almost kinds of pizzas
store... they just create different
public class ChicagoPizzaStore extends PizzaStore {
protected Pizza createPizza(String item) {
if (item.equals(“cheese”)) {
return new ChicagoStyleCheesePizza();
} else if (item.equals(“veggie”)) {
return new ChicagoStyleVeggiePizza();
} else if (item.equals(“clam”)) {
return new ChicagoStyleClamPizza();
} else if (item.equals(“pepperoni”)) {
return new ChicagoStylePepperoniPizza();
} else return null;
}
}

public class CaliforniaPizzaStore extends PizzaStore {
protected Pizza createPizza(String item) {
if (item.equals(“cheese”)) {
return new CaliforniaStyleCheesePizza();
} else if (item.equals(“veggie”)) {
return new CaliforniaStyleVeggiePizza();
} else if (item.equals(“clam”)) {
return new CaliforniaStyleClamPizza();
} else if (item.equals(“pepperoni”)) {
return new CaliforniaStylePepperoniPizza();
} else return null;
}
}

164

Chapter 4
Download at WoweBook.Com

pizza
For the Chicago ve to
ha
store, we just eate
make sure we cr as...
Chicago style pizz

ifornia
and for the Cal create
e
pizza store, w pizzas.
California style

the factory pattern

Design Puzzle Solution
We need another kind of pizza for those crazy Californians (crazy in a GOOD way of
course). Draw another parallel set of classes that you’d need to add a new California
region to our PizzaStore.

PizzaStore

you need to
Here’s everythinga pizza store,
add a Californi zza store class,
the concrete pi nia style pizzas.
and the Califor

createPizza()
orderPizza()

NYPizzaStore
createPizza()

NYStyleCheesePizza
NYStylePepperoniPizza
NYStyleClamPizza
NYStyleVeggiePizza

ChicagoPizzaStore
createPizza()

ChicagoStyleCheesePizza

CaliforniaPizzaStore
createPizza()

CaliforniaStyleCheesePizza

ChicagoStylePepperoniPizza

ChicagoStyleClamPizza
ChicagoStyleVeggiePizza

CaliforniaStylePepperoniPizza
CaliforniaStyleClamPizza
CaliforniaStyleVeggiePizza

Okay, now write the ﬁve silliest things you can think of to put on a pizza. Then, you’ll
be ready to go into business making pizza in California!

Here artieonous...r Mashed Potatoes with Roasted Garlic
sugges
BBQ Sauce
Artichoke Hearts
M&M’s
Peanuts
you are here 4
Download at WoweBook.Com

165

exercise solutions

A very dependent PizzaStore
Sharpen your pencil
Let’s pretend you’ve never heard of an OO factory. Here’s a version of the PizzaStore
that doesn’t use a factory; make a count of the number of concrete pizza objects this
class is dependent on. If you added California style pizzas to this PizzaStore, how many
objects would it be dependent on then?
public class DependentPizzaStore {
public Pizza createPizza(String style, String type) {
Pizza pizza = null;
if (style.equals(“NY”)) {
if (type.equals(“cheese”)) {
pizza = new NYStyleCheesePizza();
} else if (type.equals(“veggie”)) {
Handles all the NY
pizza = new NYStyleVeggiePizza();
style pizzas
} else if (type.equals(“clam”)) {
pizza = new NYStyleClamPizza();
} else if (type.equals(“pepperoni”)) {
pizza = new NYStylePepperoniPizza();
}
} else if (style.equals(“Chicago”)) {
if (type.equals(“cheese”)) {
pizza = new ChicagoStyleCheesePizza();
Handles all the
} else if (type.equals(“veggie”)) {
Chicago style
pizza = new ChicagoStyleVeggiePizza();
pizzas
} else if (type.equals(“clam”)) {
pizza = new ChicagoStyleClamPizza();
} else if (type.equals(“pepperoni”)) {
pizza = new ChicagoStylePepperoniPizza();
}
} else {
System.out.println(“Error: invalid type of pizza”);
return null;
}
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
}

You can write
your answers here:
166

8

number

Chapter 4
Download at WoweBook.Com

12

ifornia too

number with Cal

the factory pattern

Sharpen your pencil
Go ahead and write the ChicagoPizzaIngredientFactory; you can reference the
classes below in your implementation:
public class ChicagoPizzaIngredientFactory
implements PizzaIngredientFactory
{
public Dough createDough() {
return new ThickCrustDough();
}
public Sauce createSauce() {
return new PlumTomatoSauce();
}
public Cheese createCheese() {
return new MozzarellaCheese();
}
public Veggies[] createVeggies() {
Veggies veggies[] = { new BlackOlives(),
new Spinach(),
new Eggplant() };
return veggies;
}
public Pepperoni createPepperoni() {
return new SlicedPepperoni();
}
public Clams createClam() {
return new FrozenClams();
}
}
EggPlant
Spinach

ThickCrustDough

SlicedPepperoni

BlackOlives

PlumTomatoSauce
FrozenClams
MozzarellaCheese

you are here 4
Download at WoweBook.Com

167

crossword puzzle solution

Puzzle Solution

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�
�

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�
�

�
�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

��

�

�

�

�

�

�

�

�

�

�

�
��

�

������

168

�

�

�

�

�

�

�

�

����

������������������������������������������
�� �� ���� �������������� �� ������
�������������� ��������� ��������
���������������������������������������������
����������������������������������������
���������������������������������������
����� �� ������������ ����������
�� �������� ������� ������� � �����������
����������������������������������������
���������������������
������� ���������
�����������������������������������������
�� ��� ��� ���� ����� ������ ��� ���� ���� ��
����������������������������
������������������
��� ����� ����� ���� ���� �� ����� ���������
����������������������������������������
������� �� � ������������� ���������
Chapter 4
��������
��������������������������������������������
�� ����������� ����������������Download at WoweBook.Com
��� ������������� �� � �������������� ����

5 the Singleton Pattern

g One

h

of a Kind Objects g

I tell ya she’s ONE OF A
KIND. Look at the lines,
the curves, the body,
the headlights!

You talkin’ to me or the car? Oh,
and when can I get my oven mitt
back?

Our next stop is the Singleton Pattern, our ticket to creating oneof-a-kind objects for which there is only one instance. You might be
happy to know that of all patterns, the Singleton is the simplest in terms of its class diagram;
in fact, the diagram holds just a single class! But don’t get too comfortable; despite its
simplicity from a class design perspective, we are going to encounter quite a few bumps and
potholes in its implementation. So buckle up.

this is a new chapter
Download at WoweBook.Com

169

one and only one

What is this? An
entire chapter about how to
instantiate just
ONE OBJECT!
That’s one and ONLY
ONE object.

Developer: What use is that?
Guru: There are many objects we only need one of: thread pools, caches, dialog boxes, objects that handle
preferences and registry settings, objects used for logging, and objects that act as device drivers to devices
like printers and graphics cards. In fact, for many of these types of objects, if we were to instantiate
more than one we’d run into all sorts of problems like incorrect program behavior, overuse of resources, or
inconsistent results.
Developer: Okay, so maybe there are classes that should only be instantiated once, but do I need a whole
chapter for this? Can’t I just do this by convention or by global variables? You know, like in Java, I could do it
with a static variable.
Guru: In many ways, the Singleton Pattern is a convention for ensuring one and only one object is instantiated
for a given class. If you’ve got a better one, the world would like to hear about it; but remember, like all
patterns, the Singleton Pattern is a time-tested method for ensuring only one object gets created. The
Singleton Pattern also gives us a global point of access, just like a global variable, but without the downsides.
Developer: What downsides?
Guru: Well, here’s one example: if you assign an object to a global variable, then that object might be created
when your application begins. Right? What if this object is resource intensive and your application never ends
up using it? As you will see, with the Singleton Pattern, we can create our objects only when they are needed.
Developer: This still doesn’t seem like it should be so difﬁcult.
Guru: If you’ve got a good handle on static class variables and methods as well as access modiﬁers, it’s not.
But, in either case, it is interesting to see how a Singleton works, and, as simple as it sounds, Singleton code is
hard to get right. Just ask yourself: how do I prevent more than one object from being instantiated? It’s not
so obvious, is it?

170

Chapter 5
Download at WoweBook.Com

the singleton pattern

The Little Singleton
A small Socratic exercise in the style of The Little Lisper

How would you create a single object?

new MyObject();

And, what if another object wanted to create a
MyObject? Could it call new on MyObject again?

Yes, of course.

So as long as we have a class, can we always
instantiate it one or more times?

Yes. Well, only if it’s a public class.

And if not?

Well, if it’s not a public class, only classes in the same
package can instantiate it. But they can still instantiate
it more than once.

Hmm, interesting.

No, I’d never thought of it, but I guess it makes
sense because it is a legal deﬁnition.

Did you know you could do this?

public MyClass {
private MyClass() {}
}

What does it mean?

I suppose it is a class that can’t be instantiated
because it has a private constructor.

Well, is there ANY object that could use
the private constructor?

Hmm, I think the code in MyClass is the only
code that could call it. But that doesn’t make
much sense.

you are here 4
Download at WoweBook.Com

171

creating a singleton

Why not ?

Because I’d have to have an instance of the
class to call it, but I can’t have an instance
because no other class can instantiate it. It’s
a chicken and egg problem: I can use the
constructor from an object of type MyClass,
but I can never instantiate that object because
no other object can use “new MyClass()”.

Okay. It was just a thought.

MyClass is a class with a static method. We can
call the static method like this:

What does this mean?

MyClass.getInstance();
public MyClass {
public static MyClass getInstance() {
}
}

Why did you use MyClass, instead of
some object name?

Well, getInstance() is a static method; in other
words, it is a CLASS method. You need to use
the class name to reference a static method.

Very interesting. What if we put things together.

Wow, you sure can.

Now can I instantiate a MyClass?
public MyClass {
private MyClass() {}
public static MyClass getInstance() {
return new MyClass();
}
}

So, now can you think of a second way to instantiate
an object?

MyClass.getInstance();

Can you ﬁnish the code so that only ONE instance
of MyClass is ever created?

Yes, I think so...

172

Chapter 5
Download at WoweBook.Com

(You’ll ﬁnd the code on the next page.)

the singleton pattern

Dissecting the classic Singleton
Pattern implementation
Let’s rename MyClass
to Singleton.
public class Singleton {
private static Singleton uniqueInstance;
// other useful instance variables here
private Singleton() {}
public static Singleton getInstance() {
if (uniqueInstance == null) {
uniqueInstance = new Singleton();
}
return uniqueInstance;
}
// other useful methods here
}

.
Watch it!

tic
e a sta
We hav e to hold our
variabl tance of the
one ins ingleton.
class S

If you’re just
flipping through
the book, don’t
blindly type in this
code, you’ll see a
it has a few issues
later in the chapter.

Our constructor is
declared private;
only Singleton can
instantiate this class!

The getInstance()
method gives us a way
to instantiate the class
and also to return an
instance of it.
Of course, Singleton is
a normal class; it has
other useful instance
variables and methods.

Code Up Close

then we
If uniqueInstance is null,tance yet...
ins
e
th
uniqueInstance holds our ONE
haven’t created
...and, if it doesn’t exist, we
instance; remember, it is a
instantiate Singleton through its
static variable.
private constructor and assign
it to uniqueInstance. Note that
if we never need the instance, it
if (uniqueInstance == null) {
never gets created; this is lazy
uniqueInstance = new MyClass();
instantiation.

}
return uniqueInstance;

By the time we hit this code, we
have an instance and we return it.

If uniqueInstance wasn’t null,
then it was previously created.
We just fall through to the
return statement.

you are here 4
Download at WoweBook.Com

173

interview with singleton

Patterns Exposed
This week’s interview:

Confessions of a Singleton
HeadFirst: Today we are pleased to bring you an interview with a Singleton object. Why don’t
you begin by telling us a bit about yourself.
Singleton: Well, I’m totally unique; there is just one of me!
HeadFirst: One?
Singleton: Yes, one. I’m based on the Singleton Pattern, which assures that at any one time
there is only one instance of me.
HeadFirst: Isn’t that sort of a waste? Someone took the time to develop a full-blown class and
now all we can get is one object out of it?
Singleton: Not at all! There is power in ONE. Let’s say you have an object that contains
registry settings. You don’t want multiple copies of that object and its values running around
– that would lead to chaos. By using an object like me you can assure that every object in your
application is making use of the same global resource.
HeadFirst: Tell us more…
Singleton: Oh, I’m good for all kinds of things. Being single sometimes has its advantages you
know. I’m often used to manage pools of resources, like connection or thread pools.
HeadFirst: Still, only one of your kind? That sounds lonely.
Singleton: Because there’s only one of me, I do keep busy, but it would be nice if more
developers knew me – many developers run into bugs because they have multiple copies of
objects ﬂoating around they’re not even aware of.
HeadFirst: So, if we may ask, how do you know there is only one of you? Can’t anyone with a
new operator create a “new you”?
Singleton: Nope! I’m truly unique.
HeadFirst: Well, do developers swear an oath not to instantiate you more than once?
Singleton: Of course not. The truth be told… well, this is getting kind of personal but… I
have no public constructor.
HeadFirst: NO PUBLIC CONSTRUCTOR! Oh, sorry, no public constructor?
Singleton: That’s right. My constructor is declared private.
HeadFirst: How does that work? How do you EVER get instantiated?
Singleton: You see, to get a hold of a Singleton object, you don’t instantiate one, you just ask
for an instance. So my class has a static method called getInstance(). Call that, and I’ll show up
at once, ready to work. In fact, I may already be helping other objects when you request me.
HeadFirst: Well, Mr. Singleton, there seems to be a lot under your covers to make all this work.
Thanks for revealing yourself and we hope to speak with you again soon!
174

Chapter 5
Download at WoweBook.Com

the singleton pattern

The Chocolate Factory
Everyone knows that all modern chocolate factories have computer controlled
chocolate boilers. The job of the boiler is to take in chocolate and milk, bring them
to a boil, and then pass them on to the next phase of making chocolate bars.
Here’s the controller class for Choc-O-Holic, Inc.’s industrial strength Chocolate
Boiler. Check out the code; you’ll notice they’ve tried to be very careful to ensure
that bad things don’t happen, like draining 500 gallons of unboiled mixture, or
ﬁlling the boiler when it’s already full, or boiling an empty boiler!
public class ChocolateBoiler {
private boolean empty;
private boolean boiled;
private
public ChocolateBoiler() {
empty = true;
boiled = false;
}

This code is only started
when the boiler is empty!

fill the boiler it must

be

To
public void fill() {
full, we
empty, and, once it’sd flags.
if (isEmpty()) {
the empty and boile
empty = false;
boiled = false;
// ﬁll the boiler with a milk/chocolate mixture
}
}
public void drain() {
if (!isEmpty() && isBoiled()) {
// drain the boiled milk and chocolate
empty = true;
}
}
public void boil() {
if (!isEmpty() && !isBoiled()) {
// bring the contents to a boil
boiled = true;
}
}

set

To drain the boiler, it must be full
(non empty) and also boiled. Once it is
drained we set empty back to true.

To boil the mixture, the boiler
has to be full and not already
boiled. Once it’s boiled we set
the boiled flag to true.

public boolean isEmpty() {
return empty;
}
public boolean isBoiled() {
return boiled;
}
}
you are here 4
Download at WoweBook.Com

175

chocolate boiler singleton

A

brain
power
Choc-O-Holic has done a decent job of ensuring bad things don’t happen, don’t ya think? Then
again, you probably suspect that if two ChocolateBoiler instances get loose, some very bad
things can happen.
How might things go wrong if more than one instance of ChocolateBoiler is created in an
application?

Sharpen your pencil

Can you help Choc-O-Holic improve their ChocolateBoiler class
by turning it into a singleton?

public class ChocolateBoiler {
private boolean empty;
private boolean boiled;

private ChocolateBoiler() {
empty = true;
boiled = false;
}

public void ﬁll() {
if (isEmpty()) {
empty = false;
boiled = false;
// ﬁll the boiler with a milk/chocolate mixture
}
}
// rest of ChocolateBoiler code...
}

176

Chapter 5
Download at WoweBook.Com

the singleton pattern

Singleton Pattern defined
Now that you’ve got the classic implementation of Singleton
in your head, it’s time to sit back, enjoy a bar of chocolate,
and check out the ﬁner points of the Singleton Pattern.
Let’s start with the concise deﬁnition of the pattern:

The Singleton Pattern ensures a class has only one
instance, and provides a global point of access to it.

No big surprises there. But, let’s break it down a bit more:

ß What’s really going on here? We’re taking a class and letting it manage a
single instance of itself. We’re also preventing any other class from creating a
new instance on its own. To get an instance, you’ve got to go through the class
itself.

ß We’re also providing a global access point to the instance: whenever you
need an instance, just query the class and it will hand you back the single
instance. As you’ve seen, we can implement this so that the Singleton is created
in a lazy manner, which is especially important for resource intensive objects.
Okay, let’s check out the class diagram:

,
d is statsico you
o
h
t
e
m
)
(
stance
thod,
The getIneans it’s a class mehis method
which m eniently access t de using
can conv ywhere in your co hat’s just as
from an n.getInstance(). Tvariable, but
Singleto accessing a global instantiation
easy as enefits like lazy
we get be Singleton.
from th

The uniqueInstance
class variable holds our
one and only instance
of Singleton.

Singleton
static uniqueInstance
// Other useful Singleton data...
static getInstance()
// Other useful Singleton methods...

Singleton
A class implementing thae Sin
gleton;
Pattern is more than class with its
it is a general purpose thods.
own set of data and me
you are here 4
Download at WoweBook.Com

177

threads are a problem

y, PA
e
h
s
r
e
H
Houston, we have a problem...
It looks like the Chocolate Boiler has let us down; despite
the fact we improved the code using Classic Singleton,
somehow the ChocolateBoiler’s ﬁll() method was able
to start ﬁlling the boiler even though a batch of milk and
chocolate was already boiling! That’s 500 gallons of spilled
milk (and chocolate)! What happened!?

We don’t know what happened! The
new Singleton code was running ﬁne. The only
thing we can think of is that we just added some
optimizations to the Chocolate Boiler Controller
that makes use of multiple threads.

Could the addition of threads have caused
this? Isn’t it the case that once we’ve set
the uniqueInstance variable to the sole
instance of ChocolateBoiler, all calls to
getInstance() should return the same
instance? Right?

178

Chapter 5
Download at WoweBook.Com

the singleton pattern

BE the JVM

We have two threads, each executing this code. Your job is to play the JVM
and determine whether there is a case in which two threads might get ahold
of different boiler objects. Hint:
you really just need to look at the
ChocolateBoiler boiler =
sequence of operations
ChocolateBoiler.getInstance();
ﬁ
ll();
in the getInstance()
boil();
method and the value of
drain();
uniqueInstance to see
how they might overlap.
Use the code Magnets to help
you study how the code might interleave to create two boiler objects.
public static ChocolateBoiler
getInstance() {

Make sure you check your answer on
page 188 before turning the page!

if (uniqueInstance == null) {
uniqueInstance =
new ChocolateBoiler();
}

Thread

Thread

Value of

One

Two

uniqueInstance

return uniqueInstance;

}

you are here 4
Download at WoweBook.Com

179

multithreading and singleton

Dealing with multithreading
Our multithreading woes are almost trivially ﬁxed by making
getInstance() a synchronized method:

onized keyword to
By adding the synchr e every thread to
getInstance(), we forcit can enter the
wait its turn before two threads may
method. That is, no the same time.
enter the method at

public class Singleton {
private static Singleton uniqueInstance;
// other useful instance variables here
private Singleton() {}

public static synchronized Singleton getInstance() {
if (uniqueInstance == null) {
uniqueInstance = new Singleton();
}
return uniqueInstance;
}
// other useful methods here
}

I agree this
ﬁxes the problem.
But synchronization
is expensive; is this an
issue?

Good point, and it’s actually a little worse than you make out: the only
time synchronization is relevant is the ﬁrst time through this method. In
other words, once we’ve set the uniqueInstance variable to an instance
of Singleton, we have no further need to synchronize this method. After
the ﬁrst time through, synchronization is totally unneeded overhead!

180

Chapter 5
Download at WoweBook.Com

the singleton pattern

Can we improve multithreading?
For most Java applications, we obviously need to ensure that the Singleton works in the presence
of multiple threads. But, it looks fairly expensive to synchronize the getInstance() method, so what
do we do?
Well, we have a few options...

1. Do nothing if the performance of getInstance() isn’t critical to
your application
That’s right; if calling the getInstance() method isn’t causing substantial overhead for your
application, forget about it. Synchronizing getInstance() is straightforward and effective. Just keep
in mind that synchronizing a method can decrease performance by a factor of 100, so if a high
trafﬁc part of your code begins using getInstance(), you may have to reconsider.

2. Move to an eagerly created instance rather than a lazily
created one
If your application always creates and uses an instance of the Singleton or the overhead of
creation and runtime aspects of the Singleton are not onerous, you may want to create your
Singleton eagerly, like this:

public class Singleton {
private static Singleton uniqueInstance = new Singleton();
private Singleton() {}
public static Singleton getInstance() {
return uniqueInstance;
}
}

Go ahead and create an
instance of Singleton in
a static initializer. This
code is guaranteed to be
thread safe!

an
We’ve already gotreturn it.
instance, so just

Using this approach, we rely on the JVM to create the unique instance of the Singleton when
the class is loaded. The JVM guarantees that the instance will be created before any thread
accesses the static uniqueInstance variable.

you are here 4
Download at WoweBook.Com

181

double-checked locking

3. Use “double-checked locking” to reduce the use of
synchronization in getInstance()
With double-checked locking, we ﬁrst check to see if an instance is created, and if not, THEN we
synchronize. This way, we only synchronize the ﬁrst time through, just what we want.
Let’s check out the code:
public class Singleton {
private volatile static Singleton uniqueInstance;
private Singleton() {}

}

e and

Check for an instanc

ter a
public static Singleton getInstance() {
if there isn’t one, en
if (uniqueInstance == null) {
.
ck
synchronized blo
synchronized (Singleton.class) {
if (uniqueInstance == null) {
Note we only synchronize
uniqueInstance = new Singleton();
the first time through!
}
}
}
return uniqueInstance;
Once in the block, check again and
}
if still null, crea

te an instance.

The volatile keyword ensures that multiple threads
handle the uniqueInstance variable correctly when it
is being initialized to the Singleton instance.
If performance is an issue in your use of the getInstance() method then this method of
implementing the Singleton can drastically reduce the overhead.

.
Watch it!

g doesn’t
Double-checked lockin
r!
rlie
ea
or
1.4
va
Ja
work in

sion 1.4 and earlier, many
Unfortunately, in Java ver
ns of the volatile keyword
atio
JVMs contain implement
ed
onization for double-check
that allow improper synchr
5,
a
Jav
n
tha
er
oth
a JVM
locking. If you must use
ton.
implementing your Single
of
ds
tho
me
er
oth
er
sid
con

182

Chapter 5
Download at WoweBook.Com

the singleton pattern

Meanwhile, back at the Chocolate Factory...
While we’ve been off diagnosing the multithreading problems, the chocolate boiler
has been cleaned up and is ready to go. But ﬁrst, we have to ﬁx the multithreading
problems. We have a few solutions at hand, each with different tradeoffs, so which
solution are we going to employ?

Sharpen your pencil
For each solution, describe its applicability to the problem of ﬁxing the Chocolate
Boiler code:
Synchronize the getInstance() method:

Use eager instantiation:

Double-checked locking:

Congratulations!
At this point, the Chocolate Factory is a happy customer and Choc-O-Holic was glad to have some
expertise applied to their boiler code. No matter which multithreading solution you applied, the boiler
should be in good shape with no more mishaps. Congratulations. You’ve not only managed to escape
500lbs of hot chocolate in this chapter, but you’ve been through all the potential problems of the Singleton.

you are here 4
Download at WoweBook.Com

183

q&a about singleton

there are no
Dumb
Questions

Q:

Q:

Q:

A:

A:

A:

For such a simple pattern
consisting of only one class,
Singletons sure seem to have some
problems.

Well, we warned you up
front! But don’t let the problems
discourage you; while implementing
Singletons correctly can be tricky, after
reading this chapter you are now
well informed on the techniques for
creating Singletons and should use
them wherever you need to control
the number of instances you are
creating.

Can’t I just create a class in
which all methods and variables are
deﬁned as static? Wouldn’t that be
the same as a Singleton?

Yes, if your class is selfcontained and doesn’t depend on
complex initialization. However,
because of the way static
initializations are handled in Java,
this can get very messy, especially if
multiple classes are involved. Often
this scenario can result in subtle,
hard to find bugs involving order
of initialization. Unless there is a
compelling need to implement your
“singleton” this way, it is far better to
stay in the object world.

What about class loaders?
I heard there is a chance that two
class loaders could each end up with
their own instance of Singleton.

Yes, that is true as each class
loader defines a namespace. If you
have two or more classloaders, you
can load the same class multiple times
(once in each classloader). Now, if that
class happens to be a Singleton, then
since we have more than one version
of the class, we also have more than
one instance of the Singleton. So, if
you are using multiple classloaders
and Singletons, be careful. One way
around this problem is to specify the
classloader yourself.

Rumors of Singletons being eaten by the garbage
collectors are greatly exaggerated
Prior to Java 1.2, a bug in the garbage collector allowed Singletons
to be prematurely collected if there was no global reference to them. In other
words, you could create a Singleton and if the only reference to the Singleton
was in the Singleton itself, it would be collected and destroyed by the garbage
collector. This leads to confusing bugs because after the Singleton is
“collected,” the next call to getInstance() produced a shiny new Singleton. In
many applications, this can cause confusing behavior as state is mysteriously
reset to initial values or things like network connections are reset.
Since Java 1.2 this bug has been ﬁxed and a global reference is no longer
required. If you are, for some reason, still using a pre-Java 1.2 JVM, then be
aware of this issue, otherwise, you can sleep well knowing your Singletons
won’t be prematurely collected.

184

Chapter 5
Download at WoweBook.Com

the singleton pattern

Q:

I’ve always been taught that
a class should do one thing and one
thing only. For a class to do two
things is considered bad OO design.
Isn’t a Singleton violating this?

A:

You would be referring to
the “One Class, One Responsibility”
principle, and yes, you are correct,
the Singleton is not only responsible
for managing its one instance (and
providing global access), it is also responsible for whatever its main role is
in your application. So, certainly it can
be argued it is taking on two responsibilities. Nevertheless, it isn’t hard
to see that there is utility in a class
managing its own instance; it certainly
makes the overall design simpler. In
addition, many developers are familiar
with the Singleton pattern as it is in
wide use. That said, some developers
do feel the need to abstract out the
Singleton functionality.

Q:

Q:

A:

A:

I wanted to subclass my
Singleton code, but I ran into
problems. Is it okay to subclass a
Singleton?

One problem with subclassing
Singleton is that the constructor is
private. You can’t extend a class with
a private constructor. So, the first
thing you’ll have to do is change
your constructor so that it’s public
or protected. But then, it’s not really
a Singleton anymore, because other
classes can instantiate it.
If you do change your constructor,
there’s another issue. The
implementation of Singleton is based
on a static variable, so if you do a
straightforward subclass, all of your
derived classes will share the same
instance variable. This is probably
not what you had in mind. So, for
subclassing to work, implementing
registry of sorts is required in the base
class.

I still don’t totally understand
why global variables are worse than
a Singleton.

In Java, global variables are
basically static references to objects.
There are a couple of disadvantages
to using global variables in this
manner. We’ve already mentioned
one: the issue of lazy versus eager
instantiation. But we need to keep
in mind the intent of the pattern: to
ensure only one instance of a class
exists and to provide global access. A
global variable can provide the latter,
but not the former. Global variables
also tend to encourage developers
to pollute the namespace with lots
of global references to small objects.
Singletons don’t encourage this in
the same way, but can be abused
nonetheless.

Before implementing such a scheme,
you should ask yourself what you
are really gaining from subclassing
a Singleton. Like most patterns, the
Singleton is not necessarily meant
to be a solution that can fit into a
library. In addition, the Singleton code
is trivial to add to any existing class.
Last, if you are using a large number
of Singletons in your application,
you should take a hard look at your
design. Singletons are meant to be
used sparingly.

you are here 4
Download at WoweBook.Com

185

your design toolbox

Tools for your Design Toolbox
You’ve now added another pattern to your
toolbox. Singleton gives you another method
of creating objects – in this case, unique
objects.

s
OO Principle

OO Basics

Abstraction
n
Encapsulatio
es.
ri
va
at
h
w
Encapsulate
morphism
eritance.Poly
h
in
er
ov
n
sitio
Favor compo
Inheritance
not
interfaces,
Program to ions.
implementat
led designs
loosely coup interact.
or
f
ve
ri
t
S
cts that
between obje
or extension
ld be open f
Classes shoufor modification.
but closed
. Do not
abstractions
Depend on ncrete classes.
depend on co

OO Patterns

ß The Singleton Pattern ensures
you have at most one instance
of a class in your application.

ß The Singleton Pattern also
provides a global access point
to that instance.

ß Java’s implementation of the
Singleton Pattern makes use
of a private constructor, a static
method combined with a static
variable.

ß Examine your performance

to ensure you
When you needinstance of a class
only have one your application,
running aroundSingleton.
turn to the

thms, y
ilya oofneal-gotori-mnaanl
am
f
a
s
e
es
in
in
f
e
ef
d
d
mitPio
oavimtfdicineaeallnya.n
sddso
atcjeesohcrttayhe
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
Adntamtocak
b
e
e
e sof
tahm
d
go
F
b
o
t
al
ll
es
c
y
c
a
t
d
c
e
at
he
,
c
je
n
o
e
t
ul
b
e
a
D
h
t
o
s
d
ps
r
a
il
t
t
n
stg famenieitoits.bje
encadepe Abst ilc. it
yanrnlegeeeastin
oM
t, butas
ttcreg
y
s
ra
r
a
ie
t
h
o
S
t
t
b
c
c
le
a
a
si
le
us
t
n
je
ab
F
g
ib
o
o
a
b
t
c
xsubdinjeruecptdas wlaeitdsshcooinunttlygo h oint
tnotnha
reenanspinge
sfeEale
otneerofacseapfcfrroeomoviftodoclifrenieiecnt
r
a
inter
d
whch
d
n
ss
e
t
la
n
t
c
e
ly
f
r
epbescdladessciniddgepfwreoohrviiccladehxessaes.globasl p
cnrodeenrelainadntteneSeostdinaorgrelendsstsu
inpdeeep
varydeD
e an et
let

nleatoaivysu
nlleineybgtcinolatstheae.nirceFcoancitct.rory Method he
auatltomespratetincioicifst
yia. t to
ot
a
n
func oaflinttacdceefsser instantiation t
a class
subclasses.

and resource constraints and
carefully choose an appropriate
Singleton implementation for
multithreaded applications
(and we should consider all
applications multithreaded!).

ß Beware of the double-checked
locking implementation; it is not
thread-safe in versions before
Java 2, version 5.

ß Be careful if you are using
multiple class loaders; this
could defeat the Singleton
implementation and result in
multiple instances.

ß If you are using a JVM earlier
than 1.2, you’ll need to create a
registry of Singletons to defeat
the garbage collector.

lot of details
As you’ve seen, despite its apparent simplicity, there areng athis
er,
involved in the Singleton’s implementation. After readithe wild.chapt
though, you are ready to go out and use Singleton in
186

BULLET POINTS

Chapter 5
Download at WoweBook.Com

the singleton pattern

Sit back, open that case of chocolate that you were sent for solving
the multithreading problem, and have some downtime working on
this little crossword puzzle; all of the solution words are from this
chapter.
�

�

�
�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

��

��
��

��

��
��

��

��

�� ��

�� ��

�� ��

������
������
�� �� ��� ���� �� � �����

����
����

�� �� ��� ���� �� � �����
�� ����� �� ��������� �� ��� ������
�� ����� �� ��������� �� ��� ������
�� �� ��������� �������������� ������ ���� ��
�� ��
��������� �������������� ������ ���� ��
��������
��������
��� ��������� �������� � ������ �������� ���
��� ���������
�������� � ������ �������� ���
������ ������
������
������
��� ������ �������������� �������� �� ��� �����
��� ������
���������������������� �������� �� ��� �����
��������
��� ��������� ������� �� ��� ��
��� ���������
������� ������
��� ������
�� ����������
��� ��� ���������
��� ���
���������
���� ������ ����������
�������
��������
��� �������
�������
������������ �������� �������
��� �� �������
������
��� ���
������������ ��
��� �������
����
��������
�������
����
�� �������
��������
��� ��
�������
���������
��������������
��� ������������
��
���� �� ������� ��� ����������� ��������

�� �������� ���������� ��� ����� ��������

�� �������� ���������� ��� ����� ��������
�� � ��������� �� � ����� ���� ������� ��
�� � ��������� �� � ����� ���� ������� ��
�������� �� ��������
��������
�� ��������
�����������������������������������������
�����������������������������������������
�������������� ��� ��� ������ ���� ��������
��������������
�������� ��� ��� ������ ���� ��������
��������
�� ����� �� ���� ���� ��� ��� ���� ���������� ����
��������
����� �� ���� ���� ��� ��� ���� ���������� ����
������
�� ��� ��������� ��� ���������� �� ��� ��
��������
��� ���������
��� ���������� �� ��� ��
������������
������
�� ���������������
������� �������������� ������� ������
������
��� ������� �������������� ������� ������
�� ��������� ������� ���� ��� �� ����� �����
����
��� ���������
�������
��� ��
�������� �����
�����
���������
�������
���� ���
��� ��� ��������� ������� ��� ���
you are here 4

Download at WoweBook.Com

187

exercise solutions

Exercise
solutions

BE the JVM

Thead

Thead

Value of

One

Two

uniqueInstance

public static ChocolateBoiler
getInstance() {

null

public static ChocolateBoiler
getInstance() {

null

if (uniqueInstance == null) {

null

if (uniqueInstance == null) {

uniqueInstance =
new ChocolateBoiler();

<object1>

return uniqueInstance;

<object1>

uniqueInstance =
new ChocolateBoiler();

<object2>

<object2>
return uniqueInstance;

Sharpen your pencil

Can you help Choc-O-Holic improve their ChocolateBoiler class
by turning it into a singleton?

public class ChocolateBoiler {
private boolean empty;
private boolean boiled;
private static ChocolateBoiler uniqueInstance;
private ChocolateBoiler() {
empty = true;
boiled = false;
}
public static ChocolateBoiler getInstance() {
if (uniqueInstance == null) {
uniqueInstance = new ChocolateBoiler();
}
return uniqueInstance;
}

public void ﬁll() {
if (isEmpty()) {
empty = false;
boiled = false;
// ﬁll the boiler with a milk/chocolate mixture
}
}
// rest of ChocolateBoiler code...
}

188

Chapter 5
Download at WoweBook.Com

Uh oh, this doesn’t
look good!

Two different
objects are
returned! We have
two ChocolateBoiler
instances!!!

the singleton pattern

Exercise solutions

Sharpen your pencil
For each solution, describe its applicability to the problem of ﬁxing the Chocolate
Boiler code:

Synchronize the getInstance() method:

A straightforward technique that is guaranteed to work. We don’t seem to have any

performance concerns with the chocolate boiler, so this would be a good choice.

Use eager instantiation:

We are always going to instantiate the chocolate boiler in our code, so statically inializing the
instance would cause no concerns. This solution would work as well as the synchronized method,
although perhaps be less obvious to a developer familar with the standard pattern.
Double checked locking:

Given we have no performance concerns, double-checked locking seems like overkill. In addition, we’d
have to ensure that we are running at least Java 5.

you are here 4
Download at WoweBook.Com

189

crossword puzzle solution

Exercise solutions

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

�

�

�

�

�

�
��

�

������

190

�

����

�� �� ��� ���� �� � ����� �����
�� �������� ���������� ��� ����� ��������
�������������������������������������������
��������������
����������������������������������������������
�� � ��������� �� � ����� ���� ������� ��
�������� ��������
�������� �� �������� ��������
���������������������������������������������
�����������������������������������������
����������������������������������
�������������� ��� ��� ������ ���� ��������
������������������������������������������
�������� ������������
�������������������������������
�� ����� �� ���� ���� ��� ��� ���� ����������
Chapter 5
������������������������������������������
�������������������������������
�����������������������������������������
������������������������������������������
Download at WoweBook.Com
������� �������� ������
������ ������������ �������������

6 the Command Pattern

g Encapsulating

h

Invocation

g

These top secret drop
boxes have revolutionized the spy
industry. I just drop in my request
and people disappear, governments
change overnight and my dry cleaning
gets done. I don’t have to worry
about when, where, or how; it
just happens!

In this chapter, we take encapsulation to a whole new level:
we’re going to encapsulate method invocation. That’s right, by
encapsulating method invocation, we can crystallize pieces of computation so that the
object invoking the computation doesn’t need to worry about how to do things, it just uses
our crystallized method to get it done. We can also do some wickedly smart things with
these encapsulated method invocations, like save them away for logging or reuse them to
implement undo in our code.

this is a new chapter
Download at WoweBook.Com

191

home automation or bust

Home Automation or Bust, Inc.
1221 Industrial Avenue, Suite 2000
Future City, IL 62914

Greetings!
Johnny
I recently received a demo and brieﬁng from
new
their
on
ama,
er-O-R
Weath
of
CEO
,
Hurricane
I was so
expandable weather station. I have to say,
that I’d like to
impressed with the software architecture
Automation
Home
new
our
for
API
the
ask you to design
ces we’d be happy
Remote Control. In return for your servi
ns in Home
to handsomely reward you with stock optio
Automation or Bust, Inc.
aking remote
I’m enclosing a prototype of our ground-bre
features seven
ol
contr
te
remo
The
control for your perusal.
to a different
ned
assig
be
can
(each
slots
able
amm
progr
ing on/off buttons
household device) along with correspond
button.
for each. The remote also has a global undo

CD-R that were
I’m also enclosing a set of Java classes on
automation
created by various vendors to control home
ment, and
equip
audio
tubs,
hot
fans,
,
lights
as
devices such
nces.
applia
other similar controllable
ing the remote
We’d like you to create an API for programm
device or set of
a
ol
contr
to
ned
so that each slot can be assig
be able to control
we
that
tant
impor
is
it
that
Note
es.
devic
any future devices
the current devices on the disc, and also
that the vendors may supply.
ama weather
Given the work you did on the Weather-O-R
our remote control!
station, we know you’ll do a great job on
We look forward to seeing your design.
Sincerely,

Bill “X-10” Thompson, CEO

192

Chapter 6
Download at WoweBook.Com

the command pattern

Free hardware! Let’s check out the Remote Control...

There are “on” and “off”
buttons for each of the
seven slots.
. We
slots to programch slot
n
ve
se
t
go
ve
e’
W
ent device in ea
can put a differa the buttons.
and control it vi

These two button
used to control ths are
household device ste
ored
in slot one...
... and these two co
the household devi ntrol
stored in slot two.ce
..
... and so on.

d
Get your Sharpie out an here.
s
write your device name

Here’s the global “undo” button that
undoes the last button pressed.

you are here 4
Download at WoweBook.Com

193

vendor classes from home automation

Taking a look at the vendor classes
Check out the vendor classes on the CD-R. These should give
you some idea of the interfaces of the objects we need to control
from the remote.

ApplianceControl
on()
off()

Stereo
on()
off()

CeilingLight

setCd()

on()

setDvd()

off()

TV

dim()

OutdoorLight

setRadio()
setVolume()

FaucetControl

on()

on()

off()

openValue()

off()

setInputChannel()

closeValue()

setVolume()

Hottub

CeilingFan
circulate()

high()

GardenLight

GarageDoor

medium()
low()

jetsOn()
jetsOff()

up()

setDuskTime()

off()

setDawnTime()

getSpeed()

setTemperaturet()

down()
stop()

manualOn()

Thermostat

lightOn()

manualOff()

setTemperature()

lightOff()

Sprinkler

SecurityControl

waterOn()

Light

waterOff()

arm()
disarm()

on()
off()

It looks like we have quite a set of classes here, and not a lot of
industry effort to come up with a set of common interfaces. Not
only that, it sounds like we can expect more of these classes in the
future. Designing a remote control API is going to be interesting.
Let’s get on to the design.

194

Chapter 6
Download at WoweBook.Com

the command pattern

Cubicle Conversation
Your teammates are already discussing how to design the remote control API...

Sue

Well, we’ve got another design to do.
My ﬁrst observation is that we’ve got a
simple remote with on and off buttons but
a set of vendor classes that are quite
diverse.

Mary: Yes, I thought we’d see a bunch of classes with on()
and off() methods, but here we’ve got methods like dim(),
setTemperature(), setVolume(), setDirection().
Sue: Not only that, it sounds like we can expect more vendor
classes in the future with just as diverse methods.
Mary: I think it’s important we view this as a separation of
concerns: the remote should know how to interpret button presses
and make requests, but it shouldn’t know a lot about home
automation or how to turn on a hot tub.
Sue: Sounds like good design. But if the remote is dumb and
just knows how to make generic requests, how do we design the
remote so that it can invoke an action that, say, turns on a light or
opens a garage door?
Mary: I’m not sure, but we don’t want the remote to have to
know the speciﬁcs of the vendor classes.
Sue: What do you mean?
Mary: We don’t want the remote to consist of a set of if
statements, like “if slot1 == Light, then light.on(), else if slot1 =
Hottub then hottub.jetsOn()”. We know that is a bad design.
Sue: I agree. Whenever a new vendor class comes out, we’d have
to go in and modify the code, potentially creating bugs and more
work for ourselves!

you are here 4
Download at WoweBook.Com

195

command pattern might work

Hey, I couldn’t help
overhearing. Since Chapter 1
I’ve been boning up on Design
Patterns. There’s a pattern
called “Command Pattern” I think
might help.

Mary: Yeah? Tell us more.
Joe: The Command Pattern allows you to decouple the requester of an action
from the object that actually performs the action. So, here the requester would be
the remote control and the object that performs the action would be an instance
of one of your vendor classes.
Sue: How is that possible? How can we decouple them? After all, when I press a
button, the remote has to turn on a light.
Joe: You can do that by introducing “command objects” into your design. A
command object encapsulates a request to do something (like turn on a light) on
a speciﬁc object (say, the living room light object). So, if we store a command
object for each button, when the button is pressed we ask the command object to
do some work. The remote doesn’t have any idea what the work is, it just has a
command object that knows how to talk to the right object to get the work done.
So, you see, the remote is decoupled from the light object!
Sue: This certainly sounds like it’s going in the right direction.
Mary: Still, I’m having a hard time wrapping my head around the pattern.
Joe: Given that the objects are so decoupled, it’s a little difﬁcult to picture how the
pattern actually works.
Mary: Let me see if I at least have the right idea: using this pattern we, could
create an API in which these command objects can be loaded into button
slots, allowing the remote code to stay very simple. And, the command objects
encapsulate how to do a home automation task along with the object that needs
to do it.
Joe: Yes, I think so. I also think this pattern can help you with that Undo button,
but I haven’t studied that part yet.
Mary: This sounds really encouraging, but I think I have a bit of work to do to
really “get” the pattern.
Sue: Me too.
196

Chapter 6
Download at WoweBook.Com

the command pattern

Meanwhile, back at the Diner...,
or,
A brief introduction to the Command Pattern
As Joe said, it is a little hard to understand the Command Pattern by just hearing
its description. But don’t fear, we have some friends ready to help:
remember our friendly diner from Chapter 1? It’s been a while since we
visited Alice, Flo, and the short-order cook, but we’ve got good reason
for returning (well, beyond the food and great conversation): the diner is
going to help us understand the Command Pattern.
So, let’s take a short detour back to the diner and study the interactions
between the customers, the waitress, the orders and the short-order
cook. Through these interactions, you’re going to understand the
objects involved in the Command Pattern and also get a feel for how
the decoupling works. After that, we’re going to knock out that remote
control API.

Objectville Diner

ere here...
Wish you w

Checking in at the Objectville Diner...

Okay, we all know how the Diner operates:
Cheese
r with
Burge Shake
Malt

2 The Waitress
1

takes the Order,
places it on the
order counter
and says “Order
up!”

You, the Customer,
give the Waitress
your Order.

3 The Short-Order Cook prepares your meal

from the Order.
you are here 4
Download at WoweBook.Com

197

the diner

Let’s study the interaction in a little more detail...
...and given this Diner is in Objectville, let’s think
about the object and method calls involved, too!

ists of an order
The Order consstomer’s menu
slip and the cu written on it.
items that are
c re a

Cheese
r with
e
g
r
u
B
hake
Malt S

I’ll have a Burger
with Cheese and a
Malt Shake.

te O

rd e

r()

re
He
t
r
Sta
tak eO

rd e r (

The customer knows
what he wants and
creates an order.

)

The Waitress takes the Order,
gets around to it, she calls its and when she
method to begin the Order’s preorderUp()
paration.

or

d

p(

)

The Short Order
Cook follows the
instructions of
the Order and
produces the meal.

Cheese
r with
Burge Shake
Malt

ut

makeBurger(), makeShake()

ou

tp

all
er has s
d
r
O
e
Th struction
the in to prepare
needed al. The
the me directs the
Order Order Cook
Short ethods like
with m urger().
makeB

U
er

198

Chapter 6
Download at WoweBook.Com

the command pattern

The Object ville Diner roles and responsibilities
An Order Slip encapsulates a request to prepare a meal.
Think of the Order Slip as an object, an object that acts
as a request to prepare a meal. Like any object, it can be
passed around – from the Waitress to the order counter, or to the
next Waitress taking over her shift. It has an interface that consists
of only one method, orderUp(), that encapsulates the actions
needed to prepare the meal. It also has a reference to the object
that needs to prepare it (in our case, the Cook). It’s encapsulated
in that the Waitress doesn’t have to know what’s in the order
or even who prepares the meal; she only needs to pass the slip
through the order window and call “Order up!”

The Waitress’s job is to take Order Slips and
invoke the orderUp() method on them.
The Waitress has it easy: take an order from the customer,
continue helping customers until she makes it back to the
order counter, then invoke the orderUp() method to have
the meal prepared. As we’ve already discussed, in Objectville, the
Waitress really isn’t worried about what’s on the order or who is going to
prepare it; she just knows order slips have an orderUp() method she can
call to get the job done.

rUp() {
id orde er();
o
v
c
li
b
pu
keBurg
cook.ma Shake();
ke
a
cook.m
}

Okay, in r
care what eal life a waitress w
it, but this is on the Order Sli ould probably
p
is Objectv
ille... work and who cooks
with us he
re!
Don’t ask me to cook,
I just take orders and
yell “Order up!”

Now, throughout the day, the Waitress’s takeOrder() method gets
parameterized with different order slips from different customers, but
that doesn’t phase her; she knows all Order slips support the orderUp()
method and she can call orderUp() any time she needs a meal prepared.

The Short Order Cook has the knowledge
required to prepare the meal.
The Short Order Cook is the object that really knows
how to prepare meals. Once the Waitress has invoked
the orderUp() method; the Short Order Cook takes over and
implements all the methods that are needed to create meals.
Notice the Waitress and the Cook are totally decoupled: the
Waitress has Order Slips that encapsulate the details of the
meal; she just calls a method on each order to get it prepared.
Likewise, the Cook gets his instructions from the Order Slip; he
never needs to directly communicate with the Waitress.

You
can deﬁnitely say
the waitress and I are
decoupled. She’s not
even my type!

you are here 4
Download at WoweBook.Com

199

the diner is a model for command pattern

Okay, we have a
Diner with a Waitress who is
decoupled from the Cook by an
Order Slip, so what? Get to
the point!

Patience, we’re getting there...
Think of the Diner as a model for an OO design pattern that allows
us to separate an object making a request from the objects that
receive and execute those requests. For instance, in our remote
control API, we need to separate the code that gets invoked when
we press a button from the objects of the vendor-speciﬁc classes
that carry out those requests. What if each slot of the remote held
an object like the Diner’s order slip object? Then, when a button is
pressed, we could just call the equivalent of the “orderUp()” method
on this object and have the lights turn on without the remote
knowing the details of how to make those things happen or what
objects are making them happen.
Now, let’s switch gears a bit and map all this Diner talk to the
Command Pattern...

A

brain
power

a Burger Malt
a
I’ll have
ese and
with Che
Shake

er
an ord
sists ofr’s menu
der con
The Or the customeitten on it
slip andthat are wr
items

create

200

Chapter 6
Download at WoweBook.Com

)

he
ws what s an
omer kno
The cust pared and create
wants pre
order
takeOrder()

she gets
the order, and when
begin
The Waitress takescalls its orderUp() method to
around to it, she ation
the order’s prepar

de

rU

p()

The Short Order
Cook follows the
instructions of the
Order and produces
the meal

or

l
has al
Order ions
The instructepare
the to pr The
need meal. cts the
the er dire er Cook
rd
O t Ord ds like
Shor metho )
with eBurger(
mak

se
Chee
er with
Burg Shake
Malt

keShak

e()

t

er(), ma

tpu

makeBurg

ou

Before we move on, spend some time studying
the diagram two pages back along with Diner
roles and responsibilities until you think you’ve
got a handle on the Objectville Diner objects and
relationships. Once you’ve done that, get ready
to nail the Command Pattern!

Order(

eese
h Ch
er wit
Burg lt Shake
Ma

the command pattern

From the Diner to the Command Pattern
Okay, we’ve spent enough time in the Objectville Diner that we know all the
personalities and their responsibilities quite well. Now we’re going to rework
the Diner diagram to reﬂect the Command Pattern. You’ll see that all the
players are the same; only the names have changed.

ct
The command obje d,
ho
et
m
e
provides on
capsulates
execute(), that en n be
the actions and ca e actions
called to invoke th
on the Receiver.

The actions and the
Receiver are bound together
in the command object.

execute {
public void
ction1();
receiver.a
ction2();
receiver.a
}

c re a

action1()
action2()
...

te C

om
1

man

The client is responsible for
e
creating the command object. Th
set
a
command object consists of
of actions on a receiver.

Receiver

dOb

jec t

()

execute()

Co
mmand

s e t Co
2

create
Command
Object()

The client calls setCommand() on
an Invoker object and passes it
the command object, where it get
s
stored until it is needed.
mma

Client
3

Loading the Invoker

nd()
1

The client creates a
command object.

2

The client does a
setCommand() to store
the command object in
the invoker.

3

Later... the client asks
the invoker to execute
the command. Note:
as you’ll see later in
the chapter, once the
command is loaded into
the invoker, it may be
used and discarded, or
it may remain and be
used many times.

setCommand()

re
e futu and
h
t
n
i
m
e point
he com
At somvoker calls t method...
the In ’s execute()
object

Invoker
ex

e

t
cu

e()

execute()

Co
mmand

re
He
t
r
Sta

action1()
action2()
...

action1(), action2()

...which results
in the actions
being invoked on
the Receiver.

Receiver

you are here 4
Download at WoweBook.Com

201

who does what?

Match the diner objects and methods with the corresponding names from the
Command Pattern.

Command Pattern

Diner

202

Waitress

Command

Short Order Cook

execute()

orderUp()

Client

Order

Invoker

Customer

Receiver

takeOrder()

setCommand()

Chapter 6
Download at WoweBook.Com

the command pattern

Our first command object
Isn’t it about time we build our ﬁrst command object? Let’s go ahead and write
some code for the remote control. While we haven’t ﬁgured out how to design the
remote control API yet, building a few things from the bottom up may help us...

Implementing the Command interface
First things ﬁrst: all command objects implement the same interface, which
consists of one method. In the Diner we called this method orderUp(); however,
we typically just use the name execute().
Here’s the Command interface:
public interface Command {
public void execute();
}

Simple. All we need is one method

called execute().

Implementing a Command to turn a light on
Now, let’s say you want to implement a command for turning a light on.
Referring to our set of vendor classes, the Light class has two methods: on()
and off(). Here’s how you can implement this as a command:

Light
on()
off()

This is a command, so we need to
implement the Command interface.
public class LightOnCommand implements Command {
Light light;
public LightOnCommand(Light light) {
this.light = light;
}
public void execute() {
light.on();
}
}

d calls the
The execute methoe receiving
on() method on th e light we
object, which is th
are controlling.

The constructor is passed the specific
light that this command is going to
control - say the living room light
- and stashes it in the light instance
variable. When execute gets called, this
is the light object that is going to be
the Receiver of the request.

Now that you’ve got a LightOnCommand class, let’s see if we can put it to use...
you are here 4
Download at WoweBook.Com

203

using the command object

Using the command object
Okay, let’s make things simple: say we’ve got a remote control with only one
button and corresponding slot to hold a device to control:

hold our command,
We have one slot toone device.
which will control
We have a method for setting
public SimpleRemoteControl() {}
the command the slot is going
to control. This could be called
public void setCommand(Command command) {
slot = command;
multiple times if the client of
}
this code wanted to change the
behavior of the remote button.

public class SimpleRemoteControl {
Command slot;

public void buttonWasPressed() {
slot.execute();
}
}

This method is called when the
button is pressed. All we do
the current command bound tois take
slot and call its execute() methothe
d.

Creating a simple test to use the Remote Control
Here’s just a bit of code to test out the simple remote control. Let’s take a look and
we’ll point out how the pieces match the Command Pattern diagram:

n-speak.
Invoker;
The remote is our
it will be passed a at can
command object th quests.
args) {
be used to make re
new SimpleRemoteControl();
Now we create a Light
LightOnCommand(light);
object, this will be the
Receiver of the request.
Here, create a command and
pass the Receiver to it.
This is our Client

public class RemoteControlTest {
public static void main(String[]
SimpleRemoteControl remote =
Light light = new Light();
LightOnCommand lightOn = new
remote.setCommand(lightOn);
remote.buttonWasPressed();
}

Here, pass the command
to the Invoker.

}

And then we simulate the
button being pressed.

204

in Command Patter

File Edit Window Help DinerFoodYum

%java RemoteControlTest
Light is On

Here’s the output of
running this test code!

Chapter 6
Download at WoweBook.Com

%

the command pattern

Sharpen your pencil
Okay, it’s time for you to implement the
GarageDoorOpenCommand class. First, supply the code for
the class below. You’ll need the GarageDoor class diagram.
public class GarageDoorOpenCommand
implements Command {

GarageDoor
up()
down()
stop()
lightOn()
lightOff()

Your code here

}

Now that you’ve got your class, what is the output of the following
code? (Hint: the GarageDoor up() method prints out “Garage Door is
Open” when it is complete.)
public class RemoteControlTest {
public static void main(String[] args) {
SimpleRemoteControl remote = new SimpleRemoteControl();
Light light = new Light();
GarageDoor garageDoor = new GarageDoor();
LightOnCommand lightOn = new LightOnCommand(light);
GarageDoorOpenCommand garageOpen =
new GarageDoorOpenCommand(garageDoor);

remote.setCommand(lightOn);
remote.buttonWasPressed();
remote.setCommand(garageOpen);
remote.buttonWasPressed();
}
}
File Edit Window Help GreenEggs&Ham

%java RemoteControlTest

Your output here.

you are here 4
Download at WoweBook.Com

205

command pattern deﬁned

The Command Pattern defined

An encapsulated request.

The Command Pattern encapsulates a request as an
object, thereby letting you parameterize other objects
with different requests, queue or log requests, and support
undoable operations.

action()

Receiver
execute() {
receiver.action();
}

C om ma n d

Let’s step through this. We know that a command object
encapsulates a request by binding together a set of actions on a
speciﬁc receiver. To achieve this, it packages the actions and the
receiver up into an object that exposes just one method, execute().
When called, execute() causes the actions to be invoked on the
receiver. From the outside, no other objects really know what
actions get performed on what receiver; they just know that if they
call the execute() method, their request will be serviced.

206

Chapter 6
Download at WoweBook.Com

an
d

ig
htO

nComm

execute()

Ga

rageDoo

execute()

St

e il

Hi
gh

execute()

C

ereo O

ingFan

Re
mote Sl

ot

What we haven’t encountered yet is using commands to
implement queues and logs and support undo operations. Don’t worry,
those are pretty straightforward extensions of the basic Command
Pattern and we will get to them soon. We can also easily support
what’s known as the Meta Command Pattern once we have the
basics in place. The Meta Command Pattern allows you to create
macros of commands so that you can execute multiple commands
at once.

execute()

L

We’ve also seen a couple examples of parameterizing an object with
a command. Back at the diner, the Waitress was parameterized
with multiple orders throughout the day. In the simple remote
control, we ﬁrst loaded the button slot with a “light on” command
and then later replaced it with a “garage door open” command.
Like the Waitress, your remote slot didn’t care what command
object it had, as long as it implemented the Command interface.

An invoker - for instance
one slot of the remote
- can be parameterized with
different requests.

ff

Let’s start with its ofﬁcial deﬁnition:

rO
pe
n

You’ve done your time in the Objectville Diner, you’ve partly
implemented the remote control API, and in the process you’ve
got a fairly good picture of how the classes and objects interact in
the Command Pattern. Now we’re going to deﬁne the Command
Pattern and nail down all the details.

the command pattern

The Command Pattern defined:
the class diagram

le for
The Client is responsib mmand and
creating a ConcreteCo
setting its Receiver.

The Invoker holds
a command and at
some point asks the
command to carry
out a request by
calling its execute()
method.

Client

commands. As
Command declares an interface for all through its
you already know, a command is invoked to perform an
execute() method, which asks a receiver has an undo()
action. You’ll also notice this interface the chapter.
method, which we’ll cover a bit later in

<<interface>>
Command
execute()
undo()

Invoker
setCommand()

Receiver

ConcreteCommand

action()

The Receiver knows how to
perform the work needed to
carry out the request. Any class
can act as a Receiver.

execute()
undo()

The execute
method invokes
the action(s)
on the receiver
needed to fulfill
the request.

public void execute() {
receiver.action()
}

n
a binding between an actio
es
fin
de
d
an
mm
Co
te
re
calling
The Conc
oker makes a request by
and a Receiver. The Inv teCommand carries it out by
execute() and the Concrens on the Receiver.
calling one or more actio

A

brain
power

How does the design of the Command Pattern support the decoupling of the invoker of a
request and the receiver of the request?

you are here 4
Download at WoweBook.Com

207

where do we begin?

Okay, I think I’ve got a good feel
for the Command Pattern now. Great
tip Joe, I think we are going to look
like superstars after ﬁnishing off
the Remote Control API.

Mary: Me too. So where do we begin?
Sue: Like we did in the SimpleRemote, we need to provide a way
to assign commands to slots. In our case we have seven slots, each
with an “on” and “off ” button. So we might assign commands to
the remote something like this:
onCommands[0] = onCommand;
offCommands[0] = offCommand;
Mary: That makes sense, except for the Light objects. How does
the remote know the living room from the kitchen light?
Sue: Ah, that’s just it, it doesn’t! The remote doesn’t know
anything but how to call execute() on the corresponding
command object when a button is pressed.
Mary: Yeah, I sorta got that, but in the implementation, how do
we make sure the right objects are turning on and off the right
devices?
Sue: When we create the commands to be loaded into the
remote, we create one LightCommand that is bound to the living
room light object and another that is bound to the kitchen light
object. Remember, the receiver of the request gets bound to
the command it’s encapsulated in. So, by the time the button
is pressed, no one cares which light is which, the right thing just
happens when the execute() method is called.
Mary: I think I’ve got it. Let’s implement the remote and I think
this will get clearer!
Sue: Sounds good. Let’s give it a shot...

208

Chapter 6
Download at WoweBook.Com

the command pattern

Assigning Commands to slots
So we have a plan: We’re going to assign each slot to a command in
the remote control. This makes the remote control our invoker. When
a button is pressed the execute() method is going to be called on the
corresponding command, which results in actions being invoked on the
receiver (like lights, ceiling fans, stereos).

(1) Each slot gets a command.

(2) When the button is pressed, the execute()
method is called on the corresponding command.

execute()

an
d

Li

gh
tOnComm

execute()

Li

an
d

gh
tOnComm

H
ig h

gF a n

nF
o

Ce

ilin

S

tereoO

gF a n

execute()

We’ll worry about the
remaining slots in a bit.

geDoor

o

Cl

Ga
ra

se

execute()

O
ff

execute()

rC
D

O

p

Li

geDoor

m
and

execute()

gh
tOffCom

en

execute()

Ga
ra

gh
tOffCom

Li

Ce

ilin

m
and

execute()

execute()

execute()

ff

S

tereoO

(3) In the execute() method actions
are invoked on the reciever.

The Invoker
off()
on()

Stereo

you are here 4
Download at WoweBook.Com

209

implementing the remote control

Implementing the Remote Control
going to
This time around the remote is nds, which
ma
com
handle seven On and Off
.
we’ll hold in corresponding arrays

public class RemoteControl {
Command[] onCommands;
Command[] offCommands;

In the constructor all we need to do is
instantiate and initialize the on and off
arrays.

public RemoteControl() {
onCommands = new Command[7];
offCommands = new Command[7];
Command noCommand = new NoCommand();
for (int i = 0; i < 7; i++) {
onCommands[i] = noCommand;
offCommands[i] = noCommand;
}
}

public void setCommand(int slot, Command onCommand, Command offCommand) {
onCommands[slot] = onCommand;
The setCommand() method takes a slot position
offCommands[slot] = offCommand;
and an On and Off command to be stored in
}
public void onButtonWasPushed(int slot) {
onCommands[slot].execute();
}

that slot. It puts these commands in the on and
off arrays for later use.

public void offButtonWasPushed(int slot) {
offCommands[slot].execute();
}

}

210

When an On or Off button is
pressed, the hardware takes
care of calling the corresponding
methods onButtonWasPushed() or
offButtonWasPushed().

public String toString() {
StringBuffer stringBuff = new StringBuffer();
stringBuff.append(“\n------ Remote Control -------\n”);
for (int i = 0; i < onCommands.length; i++) {
stringBuff.append(“[slot “ + i + “] “ + onCommands[i].getClass().getName()
+ “
“ + offCommands[i].getClass().getName() + “\n”);
}
return stringBuff.toString();
}
We’ve overwritten toString()

to print out each slot and its
corresponding command. You’ll see us use this when we test
the
remote control.

Chapter 6
Download at WoweBook.Com

the command pattern

Implementing the Commands
Well, we’ve already gotten our feet wet implementing the LightOnCommand for
the SimpleRemoteControl. We can plug that same code in here and everything
works beautifully. Off commands are no different; in fact the LightOffCommand
looks like this:
public class LightOffCommand implements Command {
Light light;
public LightOffCommand(Light light) {
this.light = light;
}
public void execute() {
light.off();
}
}

The LightOffCommand works exactly
the same way as the LightOnCommand,
except that we are binding the receiver
to a different action: the off() method.

Let’s try something a little more challenging; how about writing on and off
commands for the Stereo? Okay, off is easy, we just bind the Stereo to the off()
method in the StereoOffCommand. On is a little more complicated; let’s say we
want to write a StereoOnWithCDCommand...

Stereo
on()
off()
setCd()
setDvd()
setRadio()
setVolume()

public class StereoOnWithCDCommand implements Command {
Stereo stereo;
public StereoOnWithCDCommand(Stereo stereo) {
this.stereo = stereo;
}
public void execute() {
stereo.on();
stereo.setCD();
stereo.setVolume(11);
}
}

we get
Just like the LightOnCommand,reo we
passed the instance of the ste we store
are going to be controlling and
it in a local instance variable.

To carry out this request, we need to call three
methods on the stereo: first, turn it on, then set
it to play the CD, and finally set the volume to 11.
Why 11? Well, it’s better than 10, right?

Not too bad. Take a look at the rest of the vendor classes; by now, you can deﬁnitely
knock out the rest of the Command classes we need for those.

you are here 4
Download at WoweBook.Com

211

testing the remote control

Putting the Remote Control through its paces
Our job with the remote is pretty much done; all we need to do is run some tests and
get some documentation together to describe the API. Home Automation or Bust,
Inc. sure is going to be impressed, don’t you think? We’ve managed to come up with
a design that is going to allow them to produce a remote that is easy to maintain
and they’re going to have no trouble convincing the vendors to write some simple
command classes in the future since they are so easy to write.
Let’s get to testing this code!
public class RemoteLoader {
public static void main(String[] args) {
RemoteControl remoteControl = new RemoteControl();
Light livingRoomLight = new Light(“Living Room”);
Light kitchenLight = new Light(“Kitchen”);
CeilingFan ceilingFan= new CeilingFan(“Living Room”);
GarageDoor garageDoor = new GarageDoor(“”);
Stereo stereo = new Stereo(“Living Room”);
LightOnCommand livingRoomLightOn =
new LightOnCommand(livingRoomLight);
LightOffCommand livingRoomLightOff =
new LightOffCommand(livingRoomLight);
LightOnCommand kitchenLightOn =
new LightOnCommand(kitchenLight);
LightOffCommand kitchenLightOff =
new LightOffCommand(kitchenLight);
CeilingFanOnCommand ceilingFanOn =
new CeilingFanOnCommand(ceilingFan);
CeilingFanOffCommand ceilingFanOff =
new CeilingFanOffCommand(ceilingFan);
GarageDoorUpCommand garageDoorUp =
new GarageDoorUpCommand(garageDoor);
GarageDoorDownCommand garageDoorDown =
new GarageDoorDownCommand(garageDoor);
StereoOnWithCDCommand stereoOnWithCD =
new StereoOnWithCDCommand(stereo);
StereoOffCommand stereoOff =
new StereoOffCommand(stereo);

212

Chapter 6
Download at WoweBook.Com

ces in
Create all the devions.
ti
their proper loca

Create all the Light
Command objects.

Off
Create the On and
for the ceiling fan.

Create the Up and Down
commands for the Garage.
Create the stereo On
and Off commands.

the command pattern

remoteControl.setCommand(0,
remoteControl.setCommand(1,
remoteControl.setCommand(2,
remoteControl.setCommand(3,

livingRoomLightOn, livingRoomLightOff);
kitchenLightOn, kitchenLightOff);
ceilingFanOn, ceilingFanOff);
Now that
stereoOnWithCD, stereoOff);
all our

we’ve got
commands, we
can load them into
the remote slots.

System.out.println(remoteControl);
remoteControl.onButtonWasPushed(0);
remoteControl.offButtonWasPushed(0);
remoteControl.onButtonWasPushed(1);
remoteControl.offButtonWasPushed(1);
remoteControl.onButtonWasPushed(2);
remoteControl.offButtonWasPushed(2);
remoteControl.onButtonWasPushed(3);
remoteControl.offButtonWasPushed(3);

Here’s where we use our toString()
method to print each remote slot and
the command that it is assigned to.
All right, we are ready to roll!
Now, we step through each slot
and push its On and Off button.

}
}

Now, let’s check out the execution of our remote control test...
File Edit Window Help CommandsGetThingsDone

% java RemoteLoader
------ Remote Control ------[slot 0] headﬁrst.command.remote.LightOnCommand
[slot 1] headﬁrst.command.remote.LightOnCommand
[slot 2] headﬁrst.command.remote.CeilingFanOnCommand
[slot 3] headﬁrst.command.remote.StereoOnWithCDCommand
[slot 4] headﬁrst.command.remote.NoCommand
[slot 5] headﬁrst.command.remote.NoCommand
[slot 6] headﬁrst.command.remote.NoCommand
Living Room light is on
Living Room light is off
Kitchen light is on
Kitchen light is off
Living Room ceiling fan is on high
Living Room ceiling fan is off
Living Room stereo is on
Living Room stereo is set for CD input
Living Room Stereo volume set to 11
Living Room stereo is off

On slots

headﬁrst.command.remote.LightOffCommand
headﬁrst.command.remote.LightOffCommand
headﬁrst.command.remote.CeilingFanOffCommand
headﬁrst.command.remote.StereoOffCommand
headﬁrst.command.remote.NoCommand
headﬁrst.command.remote.NoCommand
headﬁrst.command.remote.NoCommand

Off Slots
Our commands in action! Remember, the output
from each device comes from the vendor classes.
For instance, when a light object is turned on it
prints “Living Room light is on.”

%

you are here 4
Download at WoweBook.Com

213

null object

Wait a second, what
is with that NoCommand that
is loaded in slots four through six?
Trying to pull a fast one?

Good catch. We did sneak a little something in there. In the remote
control, we didn’t want to check to see if a command was loaded every
time we referenced a slot. For instance, in the onButtonWasPushed()
method, we would need code like this:
public void onButtonWasPushed(int slot) {
if (onCommands[slot] != null) {
onCommands[slot].execute();
}
}

So, how do we get around that? Implement a command that does nothing!
public class NoCommand implements Command {
public void execute() { }
}

Then, in our RemoteControl constructor, we assign every slot a
NoCommand object by default and we know we’ll always have some
command to call in each slot.
Command noCommand = new NoCommand();
for (int i = 0; i < 7; i++) {
onCommands[i] = noCommand;
offCommands[i] = noCommand;
}

So in the output of our test run, you are seeing slots that haven’t been
assigned to a command, other than the default NoCommand object
which we assigned when we created the RemoteControl.

First
Head rable
o
Hon tion
Men

Pattern
Honorable
Mention

The NoCommand object is an example of a null object. A null object is useful
when you don’t have a meaningful object to return, and yet you want to remove
the responsibility for handling null from the client. For instance, in our remote
control we didn’t have a meaningful object to assign to each slot out of the box,
so we provided a NoCommand object that acts as a surrogate and does nothing
when its execute method is called.
You’ll find uses for Null Objects in conjunction with many Design Patterns and
sometimes you’ll even see Null Object listed as a Design Pattern.

214

Chapter 6
Download at WoweBook.Com

the command pattern

Time to write that documentation...
Remote Control API Design for

Home Automation or Bust, Inc.,

Home
on programming inter face for your
the following design and applicati
possible so that
as
le
simp
as
code
rol
cont
We are pleased to present you with
te
the remo
primary design goal was to keep
loyed the Command Pattern to
Automation Remote Control. Our
produced. To this end we have emp
are
es
class
or
vend
new
as
ges
reduce the cost of producing
will
this
it doesn’t require chan
ve
belie
We
ol class from the Vendor Classes.
ontr
oteC
Rem
the
uple
deco
ally
logic
s.
ce your ongoing maintenance cost
the remote as well as drastically redu
ides an over view of our design:
The following class diagram prov

The RemoteLoader creates a
number of Command Objects
that are loaded into the slots
of the Remote Control. Each
command objec t encapsulates
a request of a home
automation device.

of Command
The RemoteControl manages a set
button is pressed,
objec ts, one per button. When a
ed() method is
the corresponding ButtonWasPush
method on the
called, which invokes the execute()
of the remote’s
command. That is the full extent
ing as the
knowledge of the classes it’s invok
te from the
Command objec t decouples the remo
mation work.
-auto
home
l
actua
the
doing
es
class

<<interface>>
Command

RemoteControl

RemoteLoader

onCommands
offCommands

All RemoteControl commands
implement the Command
inter face, which consists of one
method: execute(). Commands
encapsulate a set of actions
on a specific vendor class. The
remote invokes these actions by
calling the execute() method.

execute()

setCommand()
onButtonWasPushed()
offButtonWasPushed()

LightOnCommand

Light
on()
off()

execute()

LightOffCommand

execute()
public void execute() {
light.on()
}
ic void execute() {

publ
light.off()

}

rm
The Vendor Classes are used to perfo
of
the actual home-automation work
the
controlling devices. Here, we are using
Light class as an example.

action that can be
Using the Command Inter face, each
the remote is implemented
on
n
butto
a
ing
press
by
ed
invok
Command Object holds
with a simple Command objec t. The
nce of a Vendor Class
insta
an
is
that
t
objec
an
to
a reference
calls one or more
that
od
meth
te
execu
an
s
and implement
such classes
two
show
we
Here
t.
objec
methods on that
ctively.
that turn a light on and off, respe

you are here 4
Download at WoweBook.Com

215

don’t forget undo

Great job; it looks like
you’ve come up with a terriﬁc design,
but aren’t you forgetting one little thing
the customer asked for?
LIKE THE UNDO BUTTON!!!!

Whoops! We almost forgot... luckily, once we
have our basic Command classes, undo is easy
to add. Let’s step through adding undo to our
commands and to the remote control...

What are we doing?
Okay, we need to add functionality to support the undo button on the remote. It works like
this: say the Living Room Light is off and you press the on button on the remote. Obviously
the light turns on. Now if you press the undo button then the last action will be reversed – in
this case the light will turn off. Before we get into more complex examples, let’s get the light
working with the undo button:
1

When commands support undo, they have an undo() method that mirrors the execute()
method. Whatever execute() last did, undo() reverses. So, before we can add undo to our
commands, we need to add an undo() method to the Command interface:
public interface Command {
public void execute();
public void undo();
}

Here’s the new undo() method.

That was simple enough.
Now, let’s dive into the Light command and implement the undo() method.

216

Chapter 6
Download at WoweBook.Com

the command pattern

2

Let’s start with the LightOnCommand: if the LightOnCommand’s execute() method
was called, then the on() method was last called. We know that undo() needs to do the
opposite of this by calling the off() method.
public class LightOnCommand implements Command {
Light light;
public LightOnCommand(Light light) {
this.light = light;
}
public void execute() {
light.on();
}
public void undo() {
light.off();
}
}

urns the
execute() t undo()
light on, so s the light
simply turn
back off.

Piece of cake! Now for the LightOffCommand. Here the undo() method just
needs to call the Light’s on() method.

public class LightOffCommand implements Command {
Light light;
public LightOffCommand(Light light) {
this.light = light;
}
public void execute() {
light.off();
}
public void undo() {
light.on();
}
}

ndo() turns
And here, uack on!
the light b

Could this be any easier? Okay, we aren’t done yet; we need to work a little
support into the Remote Control to handle tracking the last button pressed
and the undo button press.
you are here 4
Download at WoweBook.Com

217

implementing undo

3

To add support for the undo button we only have to make a few small changes to the Remote
Control class. Here’s how we’re going to do it: we’ll add a new instance variable to track the
last command invoked; then, whenever the undo button is pressed, we retrieve that command
and invoke its undo() method.

public class RemoteControlWithUndo {
Command[] onCommands;
Command[] offCommands;
Command undoCommand;

e last command
This is where we’ll stash th ton.
executed for the undo but

public RemoteControlWithUndo() {
onCommands = new Command[7];
offCommands = new Command[7];
Command noCommand = new NoCommand();
for(int i=0;i<7;i++) {
onCommands[i] = noCommand;
offCommands[i] = noCommand;
}
undoCommand = noCommand;
}

Just like the other slots, undo
starts off with a NoCommand, so
pressing undo before any other
button won’t do anything at all.

public void setCommand(int slot, Command onCommand, Command offCommand) {
onCommands[slot] = onCommand;
offCommands[slot] = offCommand;
}
public void onButtonWasPushed(int slot) {
onCommands[slot].execute();
undoCommand = onCommands[slot];
}
public void offButtonWasPushed(int slot) {
offCommands[slot].execute();
undoCommand = offCommands[slot];
}
public void undoButtonWasPushed() {
undoCommand.undo();
}
public String toString() {
// toString code here...
}
}

218

Chapter 6
Download at WoweBook.Com

When a button is pressed, we take
the command and first execute
it; then we save a reference to
it in the undoCommand instance
variable. We do this for both “on”
commands and “off” commands.

When the undo button is pressed, we
invoke the undo() method of the
command stored in undoCommand.
This reverses the operation of the
last command executed.

the command pattern

Time to QA that Undo button!
Okay, let’s rework the test harness a bit to test the undo button:
public class RemoteLoader {
public static void main(String[] args) {
RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();
Light livingRoomLight = new Light(“Living Room”);
LightOnCommand livingRoomLightOn =
new LightOnCommand(livingRoomLight);
LightOffCommand livingRoomLightOff =
new LightOffCommand(livingRoomLight);

undo()
Create a Light, and our newCommands.
enabled Light On and Off

remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);
remoteControl.onButtonWasPushed(0);
remoteControl.offButtonWasPushed(0);
System.out.println(remoteControl);
remoteControl.undoButtonWasPushed();
remoteControl.offButtonWasPushed(0);
remoteControl.onButtonWasPushed(0);
System.out.println(remoteControl);
remoteControl.undoButtonWasPushed();

Add the light Commands
to the remote in slot 0.
Turn the light on, then
off and then undo.
Then, turn the light off, back on and undo.

}
}

And here’s the test results...
File Edit Window Help UndoCommandsDefyEntropy

% java RemoteLoader
Light is on
Light is off

Turn the light on, then off.

Here’s the Light commands.

------ Remote Control ------[slot 0] headﬁrst.command.undo.LightOnCommand
headﬁrst.command.undo.LightOffCommand
[slot 1] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 2] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 3] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 4] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 5] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 6] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[undo] headﬁrst.command.undo.LightOffCommand
Now undo
Light is on
Light is off
Light is on

holds the
LightOffCommand, the last
command invoked.

Undo was pressed... the LightOffCommand
undo() turns the light back on.

Then we turn the light off then back on.

------ Remote Control ------[slot 0] headﬁrst.command.undo.LightOnCommand
headﬁrst.command.undo.LightOffCommand
[slot 1] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 2] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 3] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 4] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 5] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 6] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[undo] headﬁrst.command.undo.LightOnCommand
Light is off

Undo was pressed, the light is back off.

Now undo holds the LightOnCommand, the last
command invoked.
you are here 4

Download at WoweBook.Com

219

we need to keep some state for undo

Using state to implement Undo
Okay, implementing undo on the Light was instructive but a little too easy. Typically,
we need to manage a bit of state to implement undo. Let’s try something a little more
interesting, like the CeilingFan from the vendor classes. The ceiling fan allows a
number of speeds to be set along with an off method.
Here’s the source code for the CeilingFan:

public class CeilingFan {
public static ﬁnal int
public static ﬁnal int
public static ﬁnal int
public static ﬁnal int
String location;
int speed;

Hmm, so to properly
implement undo, I’d have
to take the previous speed of
the ceiling fan into account...

public void high() {
speed = HIGH;
// code to set fan to high
}
public void medium() {
speed = MEDIUM;
// code to set fan to medium
}

public int getSpeed() {
return speed;
}
}

220

off()

cal
class holds lo ng fan.
n
a
F
g
n
li
ei
C
the
ceili
Notice that enting the speed of the
es
r
state rep

public CeilingFan(String location) {
this.location = location;
speed = OFF;
}

public void off() {
speed = OFF;
// code to turn fan off
}

medium()
low()
getSpeed()

HIGH = 3;
MEDIUM = 2;
LOW = 1;
OFF = 0;

public void low() {
speed = LOW;
// code to set fan to low
}

CeilingFan
high()

These methods set the
speed of the ceiling fan.

he current
We can get t ceiling fan
speed of the d().
using getSpee

Chapter 6
Download at WoweBook.Com

the command pattern

Adding Undo to the ceiling fan commands
Now let’s tackle adding undo to the various CeilingFan commands. To
do so, we need to track the last speed setting of the fan and, if the undo()
method is called, restore the fan to its previous setting. Here’s the code for
the CeilingFanHighCommand:

public class CeilingFanHighCommand implements Command {
CeilingFan ceilingFan;
int prevSpeed;
public CeilingFanHighCommand(CeilingFan ceilingFan) {
this.ceilingFan = ceilingFan;
}
public void execute() {
prevSpeed = ceilingFan.getSpeed();
ceilingFan.high();
}
public void undo() {
if (prevSpeed == CeilingFan.HIGH) {
ceilingFan.high();
} else if (prevSpeed == CeilingFan.MEDIUM) {
ceilingFan.medium();
} else if (prevSpeed == CeilingFan.LOW) {
ceilingFan.low();
} else if (prevSpeed == CeilingFan.OFF) {
ceilingFan.off();
}
}

cal state
We’ve added lo of the
to keep track of the fan.
previous speed

In execute, before we change
the speed of the fan, we
need to first record its
previous state, just in case we
need to undo our actions.

To undo, we set the speed
of the fan back to its
previous speed.

}

A

brain
power

We’ve got three more ceiling fan commands to write: low, medium, and off. Can you see
how these are implemented?

you are here 4
Download at WoweBook.Com

221

test the ceiling fan

Get ready to test the ceiling fan
Time to load up our remote control with the ceiling fan
commands. We’re going to load slot zero’s on button with
the medium setting for the fan and slot one with the high
setting. Both corresponding off buttons will hold the ceiling
fan off command.
Here’s our test script:

public class RemoteLoader {
public static void main(String[] args) {
RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();
CeilingFan ceilingFan = new CeilingFan(“Living Room”);
CeilingFanMediumCommand ceilingFanMedium =
new CeilingFanMediumCommand(ceilingFan);
CeilingFanHighCommand ceilingFanHigh =
new CeilingFanHighCommand(ceilingFan);
CeilingFanOffCommand ceilingFanOff =
new CeilingFanOffCommand(ceilingFan);

Here we instantiate three
commands: high, medium, and off.

remoteControl.setCommand(0, ceilingFanMedium, ceilingFanOff);
remoteControl.setCommand(1, ceilingFanHigh, ceilingFanOff);
remoteControl.onButtonWasPushed(0);
remoteControl.offButtonWasPushed(0);
System.out.println(remoteControl);
remoteControl.undoButtonWasPushed();
remoteControl.onButtonWasPushed(1);
System.out.println(remoteControl);
remoteControl.undoButtonWasPushed();

First, turn the fan on medium.
Then turn it off.
Undo! It should go back to medium...
Turn it on to high this time.
to medium.
And, one more undo; it should go back

}
}

222

Here we put medium in
slot zero, and high in
slot one. We also load
up the off commands.

Chapter 6
Download at WoweBook.Com

the command pattern

Testing the ceiling fan...
Okay, let’s ﬁre up the remote, load it with commands, and push some buttons!

File Edit Window Help UndoThis!

% java RemoteLoader
Living Room ceiling fan is on medium
Living Room ceiling fan is off

Turn the ceiling fan on
medium, then turn it off.

Here are the commands
in the remote control...

------ Remote Control ------[slot 0] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 1] headﬁrst.command.undo.CeilingFanMediumCommand
headﬁrst.command.undo.CeilingFanOffCommand
[slot 2] headﬁrst.command.undo.CeilingFanHighCommand
headﬁrst.command.undo.CeilingFanOffCommand
[slot 3] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 4] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
...and undo has the last
[slot 5] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
command executed, the
[slot 6] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
Ceilin
gFanOfCommand.
[undo] headﬁrst.command.undo.CeilingFanOffCommand
Living Room ceiling fan is on medium
Living Room ceiling fan is on high

Undo the last command, and it goes back to medium.
Now, turn it on high.

------ Remote Control ------[slot 0] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 1] headﬁrst.command.undo.CeilingFanMediumCommand
headﬁrst.command.undo.CeilingFanOffCommand
[slot 2] headﬁrst.command.undo.CeilingFanHighCommand
headﬁrst.command.undo.CeilingFanOffCommand
[slot 3] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 4] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 5] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
[slot 6] headﬁrst.command.undo.NoCommand
headﬁrst.command.undo.NoCommand
Now, high is the last
[undo] headﬁrst.command.undo.CeilingFanHighCommand
Living Room ceiling fan is on medium
%

One more undo, and the ceiling fan
goes back to medium speed.

command executed.

you are here 4
Download at WoweBook.Com

223

macro commands

Every remote needs a Party Mode!

Stereo
on()
off()
setCd()

What’s the point of having a remote if you can’t
push one button and have the lights dimmed, the
stereo and TV turned on and set to a DVD and the
hot tub ﬁred up?

on()

setRadio()

off()

setVolume()

setInputChannel()

Hottub

setVolume()

on()

Light

off()
circulate()
jetsOn()
jetsOff()
setTemperature()

Hmm, our remote
control would need a
button for each device, I
don’t think we can do this.

TV

setDvd()

on()
off()
dim()

Hold on Sue, don’t be
so sure. I think we can
do this without changing the
remote at all!

Mary’s idea is to make a new
kind of Command that can
execute other Commands...
and more than one of them!
Pretty good idea, huh?
public class MacroCommand implements Command {
Command[] commands;
public MacroCommand(Command[] commands) {
this.commands = commands;
Take an
}

array of
Commands and store them in the MacroCommand.

public void execute() {
for (int i = 0; i < commands.length; i++) {
commands[i].execute();
}
When the macro gets executed
}

by the remote,
execute those commands one at a time.

}

224

Chapter 6
Download at WoweBook.Com

the command pattern

Using a macro command
Let’s step through how we use a macro command:
1

First we create the set of commands we want to go into the macro:
Light light = new Light(“Living Room”);
TV tv = new TV(“Living Room”);
Stereo stereo = new Stereo(“Living Room”);
Hottub hottub = new Hottub();

Create all the devices, a light,
tv, stereo, and hot tub.

LightOnCommand lightOn = new LightOnCommand(light);
StereoOnCommand stereoOn = new StereoOnCommand(stereo);
TVOnCommand tvOn = new TVOnCommand(tv);
HottubOnCommand hottubOn = new HottubOnCommand(hottub);

Sharpen your pencil

2

Now create all the On
commands to control them.

We will also need commands for the off buttons,
write the code to create those here:

Next we create two arrays, one for the On commands and one for the Off commands, and load them with the corresponding commands:

Create an array for On
and an array for Off
commands...

Command[] partyOn = { lightOn, stereoOn, tvOn, hottubOn};
Command[] partyOff = { lightOff, stereoOff, tvOff, hottubOff};
MacroCommand partyOnMacro = new MacroCommand(partyOn);
MacroCommand partyOffMacro = new MacroCommand(partyOff);

3

Then we assign MacroCommand to a button like we always do:
remoteControl.setCommand(0, partyOnMacro, partyOffMacro);

...and create two
corresponding macros
to hold them.
Assign the macro
command to a button as
we would any command.
you are here 4

Download at WoweBook.Com

225

macro command exercise

4

Finally, we just need to push some buttons and see if this works.
System.out.println(remoteControl);
System.out.println(“--- Pushing Macro On---”);
remoteControl.onButtonWasPushed(0);
System.out.println(“--- Pushing Macro Off---”);
remoteControl.offButtonWasPushed(0);

Here’s the output.

File Edit Window Help You Can’tBeatABabka

% java RemoteLoader
------ Remote Control ------[slot 0] headﬁrst.command.party.MacroCommand
[slot 1] headﬁrst.command.party.NoCommand
[slot 2] headﬁrst.command.party.NoCommand
[slot 3] headﬁrst.command.party.NoCommand
[slot 4] headﬁrst.command.party.NoCommand
[slot 5] headﬁrst.command.party.NoCommand
[slot 6] headﬁrst.command.party.NoCommand
[undo] headﬁrst.command.party.NoCommand

Here are the two macro commands.
headﬁrst.command.party.MacroCommand
headﬁrst.command.party.NoCommand
headﬁrst.command.party.NoCommand
headﬁrst.command.party.NoCommand
headﬁrst.command.party.NoCommand
headﬁrst.command.party.NoCommand
headﬁrst.command.party.NoCommand

--- Pushing Macro On--Light is on
Living Room stereo is on
Living Room TV is on
Living Room TV channel is set for DVD
Hottub is heating to a steaming 104 degrees
Hottub is bubbling!
--- Pushing Macro Off--Light is off
Living Room stereo is off
Living Room TV is off
Hottub is cooling to 98 degrees

and when we invoke the off
macro. Looks like it works.

%

226

All the Commands in the macro
are executed when we invoke
the on macro...

Chapter 6
Download at WoweBook.Com

the command pattern

Exercise

The only thing our MacroCommand is missing its undo functionality. When the
undo button is pressed after a macro command, all the commands that were invoked
in the macro must undo their previous actions. Here’s the code for MacroCommand;
go ahead and implement the undo() method:
public class MacroCommand implements Command {
Command[] commands;
public MacroCommand(Command[] commands) {
this.commands = commands;
}
public void execute() {
for (int i = 0; i < commands.length; i++) {
commands[i].execute();
}
}
public void undo() {

}
}

Q:

Do I always need a receiver?
Why can’t the command object
implement the details of the
execute() method?

A:

In general, we strive for “dumb”
command objects that just invoke
an action on a receiver; however,
there are many examples of “smart”
command objects that implement
most, if not all, of the logic needed
to carry out a request. Certainly
you can do this; just keep in mind
you’ll no longer have the same level
of decoupling between the invoker
and receiver, nor will you be able to
parameterize your commands with
receivers.

there are no
Dumb
Questions

Q:

How can I implement a history
of undo operations? In other words,
I want to be able to press the undo
button multiple times.

A:

Great question! It’s pretty
easy actually; instead of keeping just
a reference to the last Command
executed, you keep a stack of previous
commands. Then, whenever undo is
pressed, your invoker pops the first
item off the stack and calls its undo()
method.

Q:

Could I have just implemented
Party Mode as a Command by
creating a PartyCommand and
putting the calls to execute the other
Commands in the PartyCommand’s
execute() method?

A:

You could; however, you’d
essentially be “hardcoding” the
party mode into the PartyCommand.
Why go to the trouble? With the
MacroCommand, you can decide
dynamically which Commands you
want to go into the PartyCommand,
so you have more flexibility using
MacroCommands. In general, the
MacroCommand is a more elegant
solution and requires less new code.
you are here 4

Download at WoweBook.Com

227

queuing requests

More uses of the Command Pattern: queuing requests
Commands give us a way to package a piece of
computation (a receiver and a set of actions) and pass it
around as a ﬁrst-class object. Now, the computation itself
may be invoked long after some client application creates
the command object. In fact, it may even be invoked by a
different thread. We can take this scenario and apply it to
many useful applications such as schedulers, thread pools
and job queues, to name a few.

RayTrace

Re

et
ch

at
ion

Ta
sk

et
ch

u

RayTrace

Co
m p il e r

at
ion

u

st

que

Co

mp

ilerT

q
Jo b

ue u

e

as
k

execute()
execute()

mp

as
k

execute()

execute()

et
workF

N

D

ow
nload

an
cialComp t

n
Fi

n
Fi

an
cialComp t

Re

D

N

et
workF

execute()

execute()

execute()

execute()

execute()
execute()

st

que

execute()

ow
nload

Co

Imagine a job queue: you add commands to the queue
on one end, and on the other end sit a group of threads.
Threads run the following script: they remove a command
from the queue, call its execute() method, wait for the call
to ﬁnish, then discard the command object and retrieve a
new one.

ibu edC
t

r

ng the
Objects implemenactie are
command interf eue.
added to the qu

om
p

st
Di

execute()

tation

Commands

ilerT

at
ion

execute()

u

n
Fi

an
cialComp t

Co
m p il e r

T h re a d
execute()
execute()

que

T h re a d

D

ow
nload

Note that the job queue classes are totally decoupled from the objects that are doing the computation. One minute a thread may be
computing a ﬁnancial computation, and the next it may be retrieving
something from the network. The job queue objects don’t care; they
just retrieve commands and call execute(). Likewise, as long as you
put objects into the queue that implement the Command Pattern,
your execute() method will be invoked when a thread is available.
Chapter 6
Download at WoweBook.Com

Re

T h re a d

st

execute()

RayTrace

T h re a d

Threads computing
jobs

228

et
ch

execute()

et
workF

N

Threads remove commands
from the queue one by one
and call their execute()
method. Once complete,
they go back for a new
command object.

Ta
sk

This gives us an effective way
to limit computation to a
fixed number of threads.

A

brain
power

How might a web server make
use of such a queue? What other
applications can you think of?

the command pattern

More uses of the Command Pattern: logging requests
The semantics of some applications require that we log all actions and be able to
recover after a crash by reinvoking those actions. The Command Pattern can support
these semantics with the addition of two methods: store() and load(). In Java we could
use object serialization to implement these methods, but the normal caveats for using
serialization for persistence apply.

<<interface

>>

How does this work? As we execute commands, we store a history of them on disk.
When a crash occurs, we reload the command objects and invoke their execute()
methods in batch and in order.

execute()
undo()

Now, this kind of logging wouldn’t make sense for a remote control; however, there
are many applications that invoke actions on large data structures that can’t be quickly
saved each time a change is made. By using logging, we can save all the operations
since the last check point, and if there is a system failure, apply those operations to our
checkpoint. Take, for example, a spreadsheet application: we might want to implement
our failure recovery by logging the actions on the spreadsheet rather than writing a copy
of the spreadsheet to disk every time a change occurs. In more advanced applications,
these techniques can be extended to apply to sets of operations in a transactional
manner so that all of the operations complete, or none of them do.

.

Restore

d
loa

execute()
store()
load()

om
m

load
loa
d

ne

andTh

Crash!

C

As each command
is executed, it is
stored on disk.

re

C

om
m

e

execute()
store()
load()

,
After a system failure
the objects are
reloaded and executed
in the correct order.

andO

execute()
store()
load()

Co
mmand T

wo

Co
mmand T

re
sto

execute()
store()
load()

C

om
m

1.
ex
ec
ute
()

2. execute()

()
ute
xec
3. e

Invoker

e

execute()
store()
load()

wo

Invoker

store

re

andO

2. execute()

3.
ex
ec
ute
()

We add two methods
for logging.

sto
re

om
m

C

()
ute
xec
1. e

store()
load()

ne

execute()
store()
load()

Command

andTh

you are here 4
Download at WoweBook.Com

229

your design toolbox

Tools for your Design Toolbox
Your toolbox is starting to get heavy! In this chapter
we’ve added a pattern that allows us to encapsulate
methods into Command objects: store them, pass them
around, and invoke them when you need them.

s

OO Principle

OO Basics

OO Patteinresnafsinfames ilya oofneal-gotori-tmhmnas,anly

decouples an object, making
a request from the one that
knows how to perform it.
center of this decoupling and
encapsulates a receiver with
an action (or set of actions) .

ß An invoker makes a request of
a Command object by calling
its execute() method, which
invokes those actions on the
receiver.

not
interfaces,
Program to ions.
implementat
led designs
loosely coup
Strive for jects that interact.
between ob

. Do not
abstractions
Depend on ncrete classes.
depend on co

ß The Command Pattern

ß A Command object is at the

Abstraction
n
Encapsulatio
.
es
ri
va
what
rphism
Encapsulate
ce. Polymo
an
it
er
h
in
sition over
Favor compo
Inheritance

or
ld be open f
Classes shnobuut closed for
extensio tion.
modifica

BULLET POINTS

ß Invokers can be parameterized
with Commands, even
dynamically at runtime.

decouple an
When you need toquests from
object making re know how
the objects thatrequests, use
to perform the attern.
the Command P

def de
mitPio
oavimtfdicineaeallnya.n
sddso
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
batcjeesohcrttayhe
eAdntamtocak
eF
e sof
tahm
d
go
b
o
t
al
ll
es
c
y
c
a
t
d
c
e
at
he
,
c
je
n
o
e
t
ul
b
e
a
D
h
t
stga fameilnieitoits.bje
encadpsepenAdbstrilc. it
yanrnlegeeetatosstin
M
o
eg
t
t, butas
t
y
s
ra
r
a
ie
t
h
o
S
c
t
t
b
c
c
le
a
a
si
le
us
ab
xsubdinibtjerguecptdasactwlaeitdsshcooinunttlygo h oint
ofbajece foormvifdoclreieiecnt
tnotnha
reenanspinge
sfeEale
ootnnF
r
a
eeren
inter
d
whch
d
r
e
ro
n
if
ss
p
c
n
e
f
t
t
oepoeden inidge fwohrviicdehxectaelas.glotbeasl ap request
lyafsoragrelendt
cnrodeenrelainadntteSeostdrin
inpdeeep
varydeD
bscladessc d preo claasspsula
ss
o
la
t
c
b
e
y ginCtsthsuoaeemnircmeFcoaaancnnctd.roert-y EMnectehboydleletttsing you
netlecaictifoaivysu
ll
r
e
e
n
lt
a
in
a
m
o
t
u
a sptiniost
yia. te. to it
jecatn,tiathteiorn ts owtithhe different
func noaaflinttacdacesefssaenr oinbst
client
ss
la
c
a
rameterize e or log requests, and
a
p
s.
e
subclass requests, queu operations.
oable
support und

ß Commands may support undo
by implementing an undo
method that restores the object
to its previous state before
the execute() method was last
called.

ß Macro Commands are a simple
extension of Command that
allow multiple commands to
be invoked. Likewise, Macro
Commands can easily support
undo().

ß In practice, it is not uncommon
for “smart” Command objects
to implement the request
themselves rather than
delegating to a receiver.

ß Commands may also be used
to implement logging and
transactional systems.

230

Chapter 6
Download at WoweBook.Com

the command pattern

Time to take a breather and let it all sink in.
It’s another crossword; all of the solution words are from
this chapter.

�

�

�

�

�

�

�

�

�

�
�

�

�
�

�
�

�
��

��
��

��

�

��

��

��
��

��
��

��

��
��

��

��
��

������
������

����

�� ��� �������� ��� ���
�� ���
�� ���������
������� ���
�������
� ��� �� ������� ��� �
�� ���������
������� ���� � ��� �� ������� ��� �
��������
�� ��� ����� ����� ����
��������������������
�� ���
����� ����� ����
�� ��� �� ��� ��������� �� ��� ������ �������
��������������������
�����
������
���� �������
���
�������
����������
���
�� ���
��� ���������
���
������
��������
��� ������ ���� ����� ��� ������� ��� ���
��� ������� ����� ������� ��� ��
��������
��� ������ ���� ����� ��� �� ��� ������ ����
��� ���
�������
����� �������
���
��
� �������
������������
����

����

�� ���� �� �������� �� ��� ������� �������
����
��������
�� ���
�������
�� ��
���
����� ��
�������
������
����������
���� �������
��
���
�����
�������
������
����������
�� ������� ��� �������� ��� �������������� ����
�����������
������
��������
��������������
�� ��
�������
�� �������
�� �����
��������
��������
��������
�������
�������� �� ����� ��������
�������
����
��� ��
������
���
��� ���� ������
����
�������
��������
�������
��������������
���������
��� ��� ���� ��� ���� ������ ���� ����������
������������
������� ��� � �������
��� �������� ������ �� ����

��� ������� ��� � �������
��� �������� ������ �� ����

��� ������ ���� ����� ��� �� ��� ������ ����
��� � ������� ������������ ����
you are here 4
Download at WoweBook.Com

231

exercise solutions

Match the diner objects and methods with the corresponding names from the
Command Pattern

Exercise
solutions

Diner
Waitress

Command

Short Order Cook

execute()

orderUp()

Client

Order

Invoker

Customer

Receiver

takeOrder()

setCommand()

Sharpen your pencil
public class GarageDoorOpenCommand implements Command {
GarageDoor garageDoor;
public GarageDoorOpenCommand(GarageDoor garageDoor) {
this.garageDoor = garageDoor;
}
public void execute() {
garageDoor.up();
}
}
File Edit Window Help GreenEggs&Ham

%java RemoteControlTest
Light is on
Garage Door is Open
%

232

Command Pattern

Chapter 6
Download at WoweBook.Com

the command pattern

Write the undo() method for MacroCommand

Exercise

public class MacroCommand implements Command {
Command[] commands;
public MacroCommand(Command[] commands) {
this.commands = commands;
}

Exercise
solutions

public void execute() {
for (int i = 0; i < commands.length; i++) {
commands[i].execute();
}
}
public void undo() {
for (int i = 0; i < commands.length; i++) {
commands[i].undo();
}
}
}

Sharpen your pencil

We will also need commands for the off button.
Write the code to create those here:

LightOffCommand lightOff = new LightOffCommand(light);
StereoOffCommand stereoOff = new StereoOffCommand(stereo);
TVOffCommand tvOff = new TVOffCommand(tv);
HottubOffCommand hottubOff = new HottubOffCommand(hottub);

�

�
�
�

�

�

�

�

�

�

�

�

�

�

�

� �

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�
�

�

��

�

��

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

� � �

�

�

�

�

��

�

�

��

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

������

�

�

�

�

�

�

����

�

�

you are here 4

����������������������������������
�������������������������������������������
�����������������������������������������
Download��������
at WoweBook.Com
�����������������
��������������������������������������������

233

Download at WoweBook.Com

7 the Adapter and Facade Patterns

g

h

Being Adaptive

Do you think the readers are
really getting the impression we’re
watching a horse race rather than
sitting in a photo studio?

g

That’s the
beauty of our profession,
we can make things look
like something they’re not!

You
mean it’s not
supposed to be a
football match?

Wrapped in
this coat, I’m a
different man!

In this chapter we’re going to attempt such impossible feats as
putting a square peg in a round hole. Sound impossible? Not when we have
Design Patterns. Remember the Decorator Pattern? We wrapped objects to give them new
responsibilities. Now we’re going to wrap some objects with a different purpose: to make their
interfaces look like something they’re not. Why would we do that? So we can adapt a design
expecting one interface to a class that implements a different interface. That’s not all; while
we’re at it, we’re going to look at another pattern that wraps objects to simplify their interface.

this is a new chapter
Download at WoweBook.Com

235

adapters everywhere

Adapters all around us
You’ll have no trouble understanding what an OO adapter is
because the real world is full of them. How’s this for an example:
Have you ever needed to use a US-made laptop in a European
country? Then you’ve probably needed an AC power adapter...

European Wall Outlet
AC Power Adapter

poses
utlet ex ower.
o
ll
a
w
n
gp
opea
The Eur rface for gettin
e
one int

Standard AC Plug

The US laptop expects
another interface.

The adapter converts one
interface into another.

You know what the adapter does: it sits in between the plug of your laptop and the
European AC outlet; its job is to adapt the European outlet so that you can plug your
laptop into it and receive power. Or look at it this way: the adapter changes the interface
of the outlet into one that your laptop expects.
Some AC adapters are simple – they only change the shape of the outlet so that it matches
your plug, and they pass the AC current straight through – but other adapters are more
complex internally and may need to step the power up or down to match your devices’
needs.
Okay, that’s the real world, what about object oriented adapters? Well, our OO adapters
play the same role as their real world counterparts: they take an interface and adapt it to
one that a client is expecting.
236

Chapter 7
Download at WoweBook.Com

rld
eal wo of?
r
r
e
h
think
any ot
How m ers can you
adapt

the adapter pattern

Object oriented adapters
Say you’ve got an existing software system that you need to work a new vendor class library
into, but the new vendor designed their interfaces differently than the last vendor:
Vendor
Class

Your
Existing
System

e you’ve
atch the on going to work!
m
’t
sn
e
o
d
e
ac
’t
Their interfr code against. This isn
u
o
y
n
writte
Okay, you don’t want to solve the problem by changing your existing code (and you can’t
change the vendor’s code). So what do you do? Well, you can write a class that adapts the
new vendor interface into the one you’re expecting.
Your
Existing
System

Vendor
Class

Adapter

The adapter implements the
interface your classes expect.

ace
e vendor interf
th
to
s
lk
ta
nd
A
requests.
to service your

The adapter acts as the middleman by receiving requests from the client and converting
them into requests that make sense on the vendor classes.
Your
Existing
System

Adapter

No code changes.

New code.

Vendor
Class

ion
k of a solut U to
in
h
t
u
o
y
n
a
C
require YO
that doesn’tadditional code
write ANY e the new vendor
to integrat w about making the
classes? Ho the adapter class.
vendor supply

No code changes.
you are here 4

Download at WoweBook.Com

237

turkey adapter

If it walks like a duck and quacks like a duck,
then it must might be a duck turkey wrapped
with a duck adapter...
It’s time to see an adapter in action. Remember our
ducks from Chapter 1? Let’s review a slightly simpliﬁed
version of the Duck interfaces and classes:

public interface Duck {
public void quack();
public void ﬂy();
}

ound, our
This time ar ent a Duck
ducks implemhat allows
interface t ack and fly.
Ducks to qu

Here’s a subclass of Duck, the MallardDuck.
public class MallardDuck implements Duck {
public void quack() {
System.out.println(“Quack”);
}
public void ﬂy() {
System.out.println(“I’m ﬂying”);
}

the duck
mentations: is doing.
le
p
im
le
p
im
S
ut what it
just prints o

}

Now it’s time to meet the newest fowl on the block:

obble.

uack, they g

public interface Turkey {
public void gobble();
public void ﬂy();
}

238

’t q
Turkeys don

Turkeys can fly, although they
can only fly short distances.

Chapter 7
Download at WoweBook.Com

the adapter pattern

public class WildTurkey implements Turkey {
public void gobble() {
System.out.println(“Gobble gobble”);
}

plementation
Here’s a concrete imk, it just
of Turkey; like Ducons.
prints out its acti

public void ﬂy() {
System.out.println(“I’m ﬂying a short distance”);
}
}

Now, let’s say you’re short on Duck objects and you’d like to
use some Turkey objects in their place. Obviously we can’t
use the turkeys outright because they have a different interface.
So, let’s write an Adapter:

Code Up Close

First, you need to implement the interface
of the type you’re adapting to. This is the
interface your client expects to see.

public class TurkeyAdapter implements Duck {
Turkey turkey;
public TurkeyAdapter(Turkey turkey) {
this.turkey = turkey;
}

Next, we need to get a reference to
the object that we are adapting; here
we do that through the constructor.

Now we need to implement all the methods in
the interface; the quack() translation between
classes is easy: just call the gobble() method.

public void quack() {
turkey.gobble();
}
public void ﬂy() {
for(int i=0; i < 5; i++) {
turkey.ﬂy();
}
}
}

Even though both interfaces have a fly()
method, Turkeys fly in short spurts - they
can’t do long-distance flying like ducks. To
map between a Duck’s fly() method and a
Turkey’s, we need to call the Turkey’s fly()
method five times to make up for it.
you are here 4

Download at WoweBook.Com

239

test the adapter

Test drive the adapter
Now we just need some code to test drive our adapter:
public class DuckTestDrive {
public static void main(String[] args) {
MallardDuck duck = new MallardDuck();

a Duck...
e
t
a
e
r
c
Let’s
rkey.
and a Tu

WildTurkey turkey = new WildTurkey();
Duck turkeyAdapter = new TurkeyAdapter(turkey);
System.out.println(“The Turkey says...”);
turkey.gobble();
turkey.ﬂy();

Then, let’s test the Turkey:
make it gobble, make it fly.

System.out.println(“\nThe Duck says...”);
testDuck(duck);
System.out.println(“\nThe TurkeyAdapter says...”);
testDuck(turkeyAdapter);
}
static void testDuck(Duck duck) {
duck.quack();
duck.ﬂy();
}
}

Test run

And then wrap the turkey
in a TurkeyAdapter, which
makes it look like a Duck.

Now let’s test the duck
by calling the testDuck()
method, which expects a
Duck object.

Now t
off thhe big test:
e turke we try
y as a
to pass
Here’s our testDuc
d
u
c
k
k(
.
)
.
.
m
ethod; it
gets a duck an
and fly() methoddscalls its quack()
.

File Edit Window Help Don’tForgetToDuck

%java RemoteControlTest

The Turkey gobbles and
flies a short distance.

The Turkey says...
Gobble gobble
I’m ﬂying a short distance
The Duck says...
Quack
I’m ﬂying
The TurkeyAdapter
Gobble gobble
I’m ﬂying a short
I’m ﬂying a short
I’m ﬂying a short
I’m ﬂying a short
I’m ﬂying a short
240

says...
distance
distance
distance
distance
distance

Chapter 7
Download at WoweBook.Com

The Duck quacks and flies
just like you’d expect.

And the adapter gobbles when
quack() is called and flies a few
times when fly() is called. Thews it
testDuck() method never kno
has a turkey disguised as a duck!

the adapter pattern

The Adapter Pattern explained
Now that we have an idea of what an Adapter is, let’s step back
and look at all the pieces again.

t()

Client

requ

est()

Adaptee

es
equ
edR

slat

tran

The Client is implemented
against the target interface.

Adapter

et in

targ

adapt
ee
interf
ace

ce
terfa
The Adapter implements the
target interface and holds an
instance of the Adaptee.

Here’s how the Client uses the Adapter
1

plementecdk.
im
r
e
t
p
a
u
d
TurkeyAget interface, D
r
a
t
the

The client makes a request to the
adapter by calling a method on it using
the target interface.

2

The adapter translates the request into
one or more calls on the adaptee using
the adaptee interface.

3

The client receives the results of the
call and never knows there is an adapter
doing the translation.

Turkey was the
adaptee interface

ee
lient and Adapt
C
he
t
t
ha
t
e
ot
N
neither knows
are decoupled –r.
about the othe

you are here 4
Download at WoweBook.Com

241

adapter pattern deﬁned

Sharpen your pencil

Let’s say we also need an Adapter that converts a Duck to a Turkey.
Let’s call it DuckAdapter. Write that class:

How did you handle the ﬂy method (after all we know ducks ﬂy longer than turkeys)? Check the answers at
the end of the chapter for our solution. Did you think of a better way?

there are no

Dumb Questions

Q:

How much “adapting” does
an adapter need to do? It seems like
if I need to implement a large target
interface, I could have a LOT of work on
my hands.

Q:

A:

The Adapter Pattern’s role is to
convert one interface into another. While
most examples of the adapter pattern show
an adapter wrapping one adaptee, we both
know the world is often a bit more messy.
So, you may well have situations where an
adapter holds two or more adaptees that are
needed to implement the target interface.

You certainly could. The job
of implementing an adapter really is
proportional to the size of the interface you
need to support as your target interface.
Think about your options, however. You
could rework all your client-side calls to
the interface, which would result in a lot
of investigative work and code changes.
Or, you can cleanly provide one class that
encapsulates all the changes in one class.

242

Does an adapter always wrap one
and only one class?

A:

This relates to another pattern called the
Facade Pattern; people often confuse the
two. Remind us to revisit this point when we
talk about facades later in this chapter.

Chapter 7
Download at WoweBook.Com

Q:

What if I have old and new parts
of my system, the old parts expect the
old vendor interface, but we’ve already
written the new parts to use the new
vendor interface? It is going to get
confusing using an adapter here and the
unwrapped interface there. Wouldn’t I be
better off just writing my older code and
forgetting the adapter?

A:

Not necessarily. One thing you
can do is create a Two Way Adapter that
supports both interfaces. To create a Two
Way Adapter, just implement both interfaces
involved, so the adapter can act as an old
interface or a new interface.

the adapter pattern

Adapter Pattern defined
Enough ducks, turkeys and AC power adapters; let’s get real and look at the ofﬁcial
deﬁnition of the Adapter Pattern:

The Adapter Pattern converts the interface of a class
into another interface the clients expect. Adapter lets
classes work together that couldn’t otherwise because of
incompatible interfaces.

Now, we know this pattern allows us to use a client with an incompatible interface by
creating an Adapter that does the conversion. This acts to decouple the client from
the implemented interface, and if we expect the interface to change over time, the
adapter encapsulates that change so that the client doesn’t have to be modiﬁed each
time it needs to operate against a different interface.
We’ve taken a look at the runtime behavior of the pattern; let’s take a look at its class
diagram as well:

<<interface>>
Target

Client

request()

The Adapter implements
the Target interface.

The client sees only the
Target interface.
Adaptee

Adapter

specificRequest()

request()

Adapter is composed
with the Adaptee.

All requests get
delegated to the
Adaptee.

The Adapter Pattern is full of good OO design principles: check out the use of object
composition to wrap the adaptee with an altered interface. This approach has the
added advantage that we can use an adapter with any subclass of the adaptee.
Also check out how the pattern binds the client to an interface, not an
implementation; we could use several adapters, each converting a different backend
set of classes. Or, we could add new implementations after the fact, as long as they
adhere to the Target interface.

you are here 4
Download at WoweBook.Com

243

object and class adapters

Object and class adapters
Now despite having deﬁned the pattern, we haven’t told you the whole story yet.
There are actually two kinds of adapters: object adapters and class adapters. This
chapter has covered object adapters and the class diagram on the previous page is a
diagram of an object adapter.
So what’s a class adapter and why haven’t we told you about it? Because you need
multiple inheritance to implement it, which isn’t possible in Java. But, that doesn’t
mean you might not encounter a need for class adapters down the road when using
your favorite multiple inheritance language! Let’s look at the class diagram for
multiple inheritance.

Target

Client

Adaptee

request()

specificRequest()

Adapter
request()

Look familiar? That’s right – the only difference is that with class adapter we
subclass the Target and the Adaptee, while with object adapter we use composition
to pass requests to an Adaptee.

A

brain
power

Object adapters and class adapters use two different means of
adapting the adaptee (composition versus inheritance). How do these
implementation differences affect the ﬂexibility of the adapter?

244

Chapter 7
Download at WoweBook.Com

Instead of using composition to adapt the
Adaptee, the Adapter now
subclasses the Adaptee
and the Target classes.

the adapter pattern

Duck Magnets
Your job is to take the duck and turkey magnets and
drag them over the part of the diagram that describes
the role played by that bird, in our earlier example. (Try
not to ﬂip back through the pages.) Then add your own
annotations to describe how it works.

Class Adapter
Target

Client

Adaptee

request()

specificRequest()

Adapter
request()

Object Adapter
Client

<<interface>>
Target
request()

Adapter
request()

Adaptee
specificRequest()

Drag these onto
to show which partthe class diagram,
represents the Duc of the diagram
represents the Tur k and which
key.

you are here 4
Download at WoweBook.Com

245

exercise answers

Duck Magnets
Answer

Note: the class ad
multiple inheritance,apter uses
can’t do it in Java... so you
Turkey class

Duck class
Class Adapter
Target

Client
request()

Client thinks he
talking to a Duc’sk.

Adaptee
specificRequest()

not
class doesds as
y
e
k
r
e
u
h
T
t
The
et is
etho
The Targss. This
he same mAdapter can
t
e
v
a
h
the
Duck clathe client
Duck, butck method calls e
Adapter
t
a
h
w
.
is
take Du around and invok
thods on
request()
invokes me
and turn on the Turkey.
The Adapter lets the
methods
to requests on a Duck,Turkey respond
BOTH classes (Duck an by extending
d Turkey).

Duck interface.
Object Adapter
Client

Client thinks he
talking to a Duc’sk.

<<interface>>
Target
request()

Adapter,
s
s
la
C
h
it
Just as wget is the Duck nt
the Tar is is what the clie
class. Th ethods on.
Adapter
invokes m
request()

The Turkey class does
interface as the Duck.n’t have the same
Turkeys don’t have qu In other words,
ack() methods, etc.

Adaptee
specificRequest()

The Adapter implement
interface, but when it s the Duck
method call it turns ar gets a
delegates the calls to aound and
Turkey.
246

Turkey
object.

Chapter 7
Download at WoweBook.Com

ey
er, the Turek
t
p
a
d
A
e
h
t
Thanks to will get calls that thface.
(Adaptee) es on the Duck inter
client mak

the adapter pattern

Tonight’s talk: The Object Adapter and Class Adapter
meet face to face.

Object Adapter

Class Adapter

Because I use composition I’ve got a leg up. I can
not only adapt an adaptee class, but any of its
subclasses.

In my part of the world, we like to use
composition over inheritance; you may be
saving a few lines of code, but all I’m doing is
writing a little code to delegate to the adaptee.
We like to keep things ﬂexible.

That’s true, I do have trouble with that because
I am committed to one speciﬁc adaptee class,
but I have a huge advantage because I don’t
have to reimplement my entire adaptee. I can
also override the behavior of my adaptee if I
need to because I’m just subclassing.

Flexible maybe, efﬁcient? No. Using a class
adapter there is just one of me, not an adapter
and an adaptee.

You’re worried about one little object? You
might be able to quickly override a method,
but any behavior I add to my adapter code
works with my adaptee class and all its
subclasses.
Hey, come on, cut me a break, I just need to
compose with the subclass to make that work.

Yeah, but what if a subclass of adaptee adds
some new behavior. Then what?

Sounds messy...
You wanna see messy? Look in the mirror!

you are here 4
Download at WoweBook.Com

247

real world adapters

Real world adapters
Let’s take a look at the use of a simple Adapter in the real world
(something more serious than Ducks at least)...

Old world Enumerators
If you’ve been around Java for a while
you probably remember that the early
collections types (Vector, Stack, Hashtable,
and a few others) implement a method
elements(), which returns an Enumeration.
The Enumeration interface allows you to
step through the elements of a collection
without knowing the speciﬁcs of how they
are managed in the collection.

io

Enumerat
<<interface>>
Enumeration
hasMoreElements()

Tells you if there are any tion.
more elements in the collec

nextElement()

Gives you the next element
in the collection.

New world Iterators
When Sun released their more recent
Collections classes they began using an
Iterator interface that, like Enumeration,
allows you to iterate through a set of items
in a collection, but also adds the ability to
remove items.

erface.

imple int
n has a s

<<interface>
Iterator
hasNext()
next()
remove()

Analogous to hasMoreElement.s()
in the Enumeration interface
This method just tells you if
you’ve looked at all the items in
the collection.

Gives you the next
element in the collection.
Removes an item
from the collection.

And today...
We are often faced with legacy code that exposes the
Enumerator interface, yet we’d like for our new code to use
only Iterators. It looks like we need to build an adapter.

248

Chapter 7
Download at WoweBook.Com

the adapter pattern

Adapting an Enumeration to an Iterator
First we’ll look at the two interfaces to ﬁgure out how the methods map from
one to the other. In other words, we’ll ﬁgure out what to call on the adaptee
when the client invokes a method on the target.

These two methods look easy,
they map straight to hasNext()
and next() in Iterator.

Target interface
<<interface>>
Iterator

<<interface>>
Enumeration
hasMoreElements()
nextElement()

hasNext()
next()
remove()

Adaptee interface
But what about this method
remove() in Iterator? There’s
nothing like that in Enumeration.

Designing the Adapter
Here’s what the classes should look like: we need an adapter that implements
the Target interface and that is composed with an adaptee. The hasNext() and
next() methods are going to be straightforward to map from target to adaptee:
we just pass them right through. But what do you do about remove()? Think
about it for a moment (and we’ll deal with it on the next page). For now, here’s
the class diagram:

Your new code still gets
to use Iterators, even
if there’s really an
Enumeration underneath.

EnumerationIterator
is the adapter.

<<interface>>
Iterator
hasNext()
next()
remove()

We’re making the Enumerations
in your old code look like
Iterators for your new code.

EnumerationIterator
hasNext()
next()
remove()

<<interface>>

A class
implementing
the Enumeration
interface is the
adaptee.

Enumeration

hasMoreElements()
nextElement()

you are here 4
Download at WoweBook.Com

249

enumeration iterator adapter

Dealing with the remove() method
Well, we know Enumeration just doesn’t support remove. It’s a “read only” interface.
There’s no way to implement a fully functioning remove() method on the adapter. The
best we can do is throw a runtime exception. Luckily, the designers of the Iterator
interface foresaw this need and deﬁned the remove() method so that it supports an
UnsupportedOperationException.
This is a case where the adapter isn’t perfect; clients will have to watch out for potential
exceptions, but as long as the client is careful and the adapter is well documented this is
a perfectly reasonable solution.

Writing the EnumerationIterator adapter
Here’s simple but effective code for all those legacy classes still producing Enumerations:

public class EnumerationIterator implements Iterator
{
Enumeration enum;
public EnumerationIterator(Enumeration enum) {
this.enum = enum;
}
public boolean hasNext() {
return enum.hasMoreElements();
}
public Object next() {
return enum.nextElement();
}
public void remove() {
throw new UnsupportedOperationException();
}
}

250

Chapter 7
Download at WoweBook.Com

Since we’re adapting Enumeration
to Iterator, our Adapter
implements the Iterator interface...
it has to look like an Iterator.
The Enumeration we’re adapting.
We’re using composition so we stash
it in an instance variable.
The Iterator’s hasNext() method
is delegated to the Enumeration’s
hasMoreElements() method...
... and the Iterator’s next() method
is delegated to the Enumerations’s
nextElement() method.

Unfortunately, we can’t support
Iterator’s remove() method, so
we have to punt (in other words,
we give up!). Here we just throw
an exception.

the adapter pattern

Exercise

While Java has gone in the direction of the Iterator, there is nevertheless a lot of
legacy client code that depends on the Enumeration interface, so an Adapter
that converts an Iterator to an Enumeration is also quite useful.
Write an Adapter that adapts an Iterator to an Enumeration. You can test your
code by adapting an ArrayList. The ArrayList class supports the Iterator interface
but doesn’t support Enumerations (well, not yet anyway).

A

brain
power
Some AC adapters do more than just change the interface – they add other features like surge
protection, indicator lights and other bells and whistles.
If you were going to implement these kinds of features, what pattern would you use?

you are here 4
Download at WoweBook.Com

251

ﬁreside chats: decorator and adapter

Tonight’s talk: The Decorator Pattern and the Adapter
Pattern discuss their differences.

Decorator

Adapter

I’m important. My job is all about responsibility –
you know that when a Decorator is involved there’s
going to be some new responsibilities or behaviors
added to your design.
You guys want all the glory while us adapters
are down in the trenches doing the dirty work:
converting interfaces. Our jobs may not be
glamorous, but our clients sure do appreciate
us making their lives simpler.
That may be true, but don’t think we don’t
work hard. When we have to decorate a big
interface, whoa, that can take a lot of code.
Try being an adapter when you’ve got to bring
several classes together to provide the interface
your client is expecting. Now that’s tough. But
we have a saying: “an uncoupled client is a
happy client.”
Cute. Don’t think we get all the glory; sometimes
I’m just one decorator that is being wrapped by
who knows how many other decorators. When a
method call gets delegated to you, you have no
idea how many other decorators have already dealt
with it and you don’t know that you’ll ever get
noticed for your efforts servicing the request.
Hey, if adapters are doing their job, our clients
never even know we’re there. It can be a thankless job.
252

Chapter 7
Download at WoweBook.Com

the adapter pattern

Decorator

Adapter
But, the great thing about us adapters is that we
allow clients to make use of new libraries and
subsets without changing any code, they just rely
on us to do the conversion for them. Hey, it’s a
niche, but we’re good at it.

Well us decorators do that as well, only we allow
new behavior to be added to classes without altering
existing code. I still say that adapters are just fancy
decorators – I mean, just like us, you wrap an object.
No, no, no, not at all. We always convert the
interface of what we wrap, you never do. I’d
say a decorator is like an adapter; it is just that
you don’t change the interface!
Uh, no. Our job in life is to extend the
behaviors or responsibilities of the objects we
wrap, we aren’t a simple pass through.
Hey, who are you calling a simple pass
through? Come on down and we’ll see how
long you last converting a few interfaces!
Maybe we should agree to disagree. We seem
to look somewhat similar on paper, but clearly
we are miles apart in our intent.
Oh yeah, I’m with you there.

you are here 4
Download at WoweBook.Com

253

who does what?

And now for something different...
There’s another pattern in this chapter.
You’ve seen how the Adapter Pattern converts the interface of a class into
one that a client is expecting. You also know we achieve this in Java by
wrapping the object that has an incompatible interface with an object that
implements the correct one.
We’re going to look at a pattern now that alters an interface, but for a
different reason: to simplify the interface. It’s aptly named the Facade
Pattern because this pattern hides all the complexity of one or more
classes behind a clean, well-lit facade.

Match each pattern with its intent:

Pattern

Intent

Decorator

Converts one interface to
another

Adapter

Doesn’t alter the interface, but
adds responsibility

Facade
Makes an interface simpler

254

Chapter 7
Download at WoweBook.Com

the adapter pattern

Home Sweet Home Theater
Before we dive into the details of the Facade Pattern, let’s take a look
at a growing national obsession: building your own home theater.
You’ve done your research and you’ve assembled a killer system
complete with a DVD player, a projection video system, an
automated screen, surround sound and even a popcorn popper.
Check out all the components you’ve put together:

Amplifier

Tuner
amplifier
on()
off()
setAm()
setFm()
setFrequency()

tuner
dvdPlayer
cdPlayer
on()
off()
setCd()
setDvd()
setStereoSound()
setSurroundSoud()
setTuner()
setVolume()

CdPlayer
amplifier

DvdPlayer
amplifier
on()
off()
eject()
pause()
play()
play()
setSurroundAudio()
setTwoChannelAudio()
stop()

on()
off()
eject()
pause()
play()
play()
stop()

Screen
up()
down()

That’s a lot of
classes, a lot
of interactions,
and a big set of
interfaces to
learn and use

Projector
dvdPlayer

PopcornPopper
on()
off()
pop()

TheaterLights

on()
off()
tvMode()
wideScreenMode()

on()
off()
dim()

You’ve spent weeks running wire, mounting the projector, making all
the connections and ﬁne tuning. Now it’s time to put it all in motion
and enjoy a movie...

you are here 4
Download at WoweBook.Com

255

tasks to watch a movie

Watching a movie (the hard way)
Pick out a DVD, relax, and get ready for movie magic. Oh,
there’s just one thing – to watch the movie, you need to
perform a few tasks:

256

1

Turn on the popcorn popper

2

Start the popper popping

3

Dim the lights

4

Put the screen down

5

Turn the projector on

6

Set the projector input to DVD

7

Put the projector on wide-screen mode

8

Turn the sound ampliﬁer on

9

Set the ampliﬁer to DVD input

10

Set the ampliﬁer to surround sound

11

Set the ampliﬁer volume to medium (5)

12

Turn the DVD Player on

13

Start the DVD Player playing

Chapter 7
Download at WoweBook.Com

I’m already exhausted
and all I’ve done is turn
everything on!

the adapter pattern

Let’s check out those same tasks in terms of the classes and the
method calls needed to perform them:

start
Turn on the popcorn popper and
popping...
popper.on();
popper.pop();
lights.dim(10);

asses
Six different cl
involved!

screen.down();
projector.on();
projector.setInput(dvd);
projector.wideScreenMode();
amp.on();
amp.setDvd(dvd);
amp.setSurroundSound();
amp.setVolume(5);
dvd.on();
dvd.play(movie);

Dim the lights to 10%...
Put the screen down...
in
Turn on the projector and putvieit
...
mo
the
for
de
wide screen mo
D, put
Turn on the amp, set it to DVset
the
and
de
mo
it in surround sound
volume to 5...
Turn on the DVD player... vie!
and FINALLY, play the mo

But there’s more...

ß When the movie is over, how do you turn everything off ?
Wouldn’t you have to do all of this over again, in reverse?

ß Wouldn’t it be as complex to listen to a CD or the radio?
ß If you decide to upgrade your system, you’re probably going
to have to learn a slightly different procedure.
So what to do? The complexity of using your home theater is becoming apparent!
Let’s see how the Facade Pattern can get us out of this mess so we can enjoy the movie...

you are here 4
Download at WoweBook.Com

257

lights camera facade

Lights, Camera, Facade!
A Facade is just what you need: with the Facade Pattern you can take a complex
subsystem and make it easier to use by implementing a Facade class that
provides one, more reasonable interface. Don’t worry; if you need the power
of the complex subsystem, it’s still there for you to use, but if all you need is a
straightforward interface, the Facade is there for you.
Let’s take a look at how the Facade operates:

1

Ok ay, time to create a
Facade for the home
theater system. To do
ss
this we create a new cla
,
de
HomeTheaterFaca
which exposes a few
simple methods such as
watchMovie().

2 The Facade class treats

the home theater
components as a
subsystem, and calls
on the subsystem
to implement its
watchMovie() method.

The Facade
HomeTheaterFacade
watchMovie()
endMovie()
listenToCd()
endCd()
listenToRadio()
endRadio()

Amplifier
tuner
dvdPlayer
cdPlayer
on()
off()

Tuner

setCd()

DvdPlayer

setDvd()

amplifier

setStereoSound()

on()

amplifier

setSurroundSoud()

off()

setTuner()

setAm()

play(

)

off()

setVolume()

setFm()

on()
eject()
pause()

setFrequency()

play()
play()

CdPlayer
amplifier

Screen

the
The subsystemplifying.
m
si
is
Facade

setTwoChannelAudio()
stop()

on()

up()

off()

down()

eject()
pause()
play()
play()

Projector

stop()
dvdPlayer
on()

PopcornPopper

off()
tvMode()

on()
off()

TheaterLights

pop()
on()
off()
dim()

258

setSurroundAudio()

Chapter 7
Download at WoweBook.Com

wideScreenMode()

on()

the adapter pattern

watchM

A client of the
subsystem facade

ovie()

3

lls
Your client code now ca
ater
the
me
ho
methods on the
em.
yst
bs
su
the
Facade, not on
just
we
vie
mo
a
So now to watch
(),
vie
Mo
tch
wa
d,
call one metho
the
th
wi
tes
ica
and it commun
tor,
lights, DVD player, projec
orn
pc
po
d
an
n,
amplifier, scree
maker for us.

I’ve got to have my
low-level access!

4

of
Formerly president Sc
hool
gh
Hi
re
the Rushmo
.
ub
Cl
A/V Science

The Facade still leaves the subsystem
accessible to be used direc tly. If you
need the advanced functionality
of the subsystem classes, they are
available for your use.

you are here 4
Download at WoweBook.Com

259

facade versus adapter

there are no

Dumb Questions

Q:

If the Facade encapsulates the
subsystem classes, how does a client
that needs lower-level functionality gain
access to them?

Q:

What is the benefit of the facade
other than the fact that I now have a
simpler interface?

A:

A:

Q:

Q:

Facades don’t “encapsulate” the
subsystem classes; they merely provide a
simplified interface to their functionality. The
subsystem classes still remain available
for direct use by clients that need to use
more specific interfaces. This is a nice
property of the Facade Pattern: it provides
a simplified interface while still exposing the
full functionality of the system to those who
may need it.

Does the facade add any
functionality or does it just pass through
each request to the subsystem?

A:

A facade is free to add its own
“smarts” in addition to making use of the
subsystem. For instance, while our home
theater facade doesn’t implement any new
behavior, it is smart enough to know that the
popcorn popper has to be turned on before it
can pop (as well as the details of how to turn
on and stage a movie showing).

Q:

Does each subsystem have only
one facade?

A:

Not necessarily. The pattern
certainly allows for any number of facades to
be created for a given subsystem.

260

The Facade Pattern also allows
you to decouple your client implementation
from any one subsystem. Let’s say for
instance that you get a big raise and decide
to upgrade your home theater to all new
components that have different interfaces.
Well, if you coded your client to the facade
rather than the subsystem, your client code
doesn’t need to change, just the facade
(and hopefully the manufacturer is supplying
that!).
So the way to tell the difference
between the Adapter Pattern and the
Facade Pattern is that the adapter wraps
one class and the facade may represent
many classes?

A:

No! Remember, the Adapter Pattern
changes the interface of one or more
classes into one interface that a client is
expecting. While most textbook examples
show the adapter adapting one class, you
may need to adapt many classes to provide
the interface a client is coded to. Likewise,
a Facade may provide a simplified interface
to a single class with a very complex
interface.
The difference between the two is not in
terms of how many classes they “wrap,” it
is in their intent. The intent of the Adapter
Pattern is to alter an interface so that it
matches one a client is expecting. The
intent of the Facade Pattern is to provide a
simplified interface to a subsystem.

Chapter 7
Download at WoweBook.Com

A facade not
only simplifies
an interface, it
decouples a client
from a subsystem
of components.
Facades and
adapters may
wrap multiple
classes, but a
facade’s intent is
to simplify, while
an adapter’s
is to convert
the interface
to something
different.

the adapter pattern

Constructing your home theater facade
Let’s step through the construction of the HomeTheaterFacade: The
ﬁrst step is to use composition so that the facade has access to all the
components of the subsystem:

public class HomeTheaterFacade {
Ampliﬁer amp;
Tuner tuner;
DvdPlayer dvd;
CdPlayer cd;
Projector projector;
TheaterLights lights;
Screen screen;
PopcornPopper popper;

se
Here’s the composition; thethe
of
s
ent
pon
com
are all the
subsystem we are going to use.

public HomeTheaterFacade(Ampliﬁer amp,
Tuner tuner,
DvdPlayer dvd,
CdPlayer cd,
Projector projector,
Screen screen,
TheaterLights lights,
PopcornPopper popper) {
this.amp = amp;
this.tuner = tuner;
this.dvd = dvd;
this.cd = cd;
this.projector = projector;
this.screen = screen;
this.lights = lights;
this.popper = popper;

The facade is passed a
reference to each component
of the subsystem in its
constructor. The facade
then assigns each to the
corresponding instance variable.

}
// other methods here
}

We’re just about to fi

ll these in...

you are here 4
Download at WoweBook.Com

261

implementing facade

Implementing the simplified interface
Now it’s time to bring the components of the subsystem together into a uniﬁed interface.
Let’s implement the watchMovie() and endMovie() methods:

public void watchMovie(String movie) {
System.out.println(“Get ready to watch a movie...”);
popper.on();
popper.pop();
sequence
lights.dim(10);
watchMovie() follows the sam,e but wraps
screen.down();
we had to do by hand beforet does all
projector.on();
it up in a handy method tha each task we
projector.wideScreenMode();
the work. Notice that for ility to the
amp.on();
are delegating the responsib the subsystem.
amp.setDvd(dvd);
corresponding component in
amp.setSurroundSound();
amp.setVolume(5);
dvd.on();
dvd.play(movie);
}
public void endMovie() {
System.out.println(“Shutting movie theater down...”);
popper.off();
lights.on();
screen.up();
projector.off();
.And endMovie() takes care
amp.off();
of shutting everything down
dvd.stop();
for us. Again, each task is
dvd.eject();
delegated to the appropriate
dvd.off();
com
ponent in the subsystem.
}

A

brain
power
Think about the facades you’ve encountered in the Java API.
Where would you like to have a few new ones?

262

Chapter 7
Download at WoweBook.Com

the adapter pattern

Time to watch a movie (the easy way)
It’s SHOWTIME!

Here we’re creating the components
right in the test drive. Normally the
client is given a facade, it doesn’t have
to construct one itself.

public class HomeTheaterTestDrive {
public static void main(String[] args) {
// instantiate components here

HomeTheaterFacade homeTheater =
new HomeTheaterFacade(amp, tuner, dvd, cd,
projector, screen, lights, popper);
homeTheater.watchMovie(“Raiders of the Lost Ark”);
homeTheater.endMovie();

Use the simplified interface to
first start the movie up, and
then shut it down.

}
}

Here’s the output.
Calling the Facade’s
watchMovie() does all
this work for us...

...and here, we’re done
watching the movie, so
calling endMovie() turns
everything off.

First you instantiate
the Facade with all the
components in the subsystem.

File Edit Window Help SnakesWhy’dItHaveToBeSnakes?

%java HomeTheaterTestDrive
Get ready to watch a movie...
Popcorn Popper on
Popcorn Popper popping popcorn!
Theater Ceiling Lights dimming to 10%
Theater Screen going down
Top-O-Line Projector on
Top-O-Line Projector in widescreen mode (16x9 aspect ratio)
Top-O-Line Ampliﬁer on
Top-O-Line Ampliﬁer setting DVD player to Top-O-Line DVD Player
Top-O-Line Ampliﬁer surround sound on (5 speakers, 1 subwoofer)
Top-O-Line Ampliﬁer setting volume to 5
Top-O-Line DVD Player on
Top-O-Line DVD Player playing “Raiders of the Lost Ark”
Shutting movie theater down...
Popcorn Popper off
Theater Ceiling Lights on
Theater Screen going up
Top-O-Line Projector off
Top-O-Line Ampliﬁer off
Top-O-Line DVD Player stopped “Raiders of the Lost Ark”
Top-O-Line DVD Player eject
Top-O-Line DVD Player off

%
you are here 4
Download at WoweBook.Com

263

facade pattern deﬁned

Facade Pattern defined
To use the Facade Pattern, we create a class that simpliﬁes and uniﬁes a set of more
complex classes that belong to some subsystem. Unlike a lot of patterns, Facade is fairly
straightforward; there are no mind bending abstractions to get your head around. But that
doesn’t make it any less powerful: the Facade Pattern allows us to avoid tight coupling between
clients and subsystems, and, as you will see shortly, also helps us adhere to a new object
oriented principle.
Before we introduce that new principle, let’s take a look at the ofﬁcial deﬁnition of the pattern:

The Facade Pattern provides a uniﬁed interface to a
set of interfaces in a subsytem. Facade deﬁnes a higherlevel interface that makes the subsystem easier to use.

There isn’t a lot here that you don’t already know, but one of the most important things
to remember about a pattern is its intent. This deﬁnition tells us loud and clear that the
purpose of the facade it to make a subsystem easier to use through a simpliﬁed interface.
You can see this in the pattern’s class diagram:

se
Happy client wmho
e
ca
job just be e of
easier becaus
the facade.

Facade

Client

Unified interface
that is easier to use.

subsystem classes

bsystem.

More complex su

That’s it; you’ve got another pattern under your belt! Now, it’s time for that new OO principle.
Watch out, this one can challenge some assumptions!

264

Chapter 7
Download at WoweBook.Com

the adapter pattern

The Principle of Least Knowledge
The Principle of Least Knowledge guides us to reduce the
interactions between objects to just a few close “friends.”
The principle is usually stated as:

Design Principle
Principle of Least Knowledge talk only to your immediate friends.

But what does this mean in real terms? It means when you
are designing a system, for any object, be careful of the
number of classes it interacts with and also how it comes to
interact with those classes.
This principle prevents us from creating designs that have
a large number of classes coupled together so that changes
in one part of the system cascade to other parts. When you
build a lot of dependencies between many classes, you are
building a fragile system that will be costly to maintain and
complex for others to understand.

brain
power

A

How many classes is this code coupled to?

public ﬂoat getTemp() {
return station.getThermometer().getTemperature();
}

you are here 4
Download at WoweBook.Com

265

principle of least knowledge

How NOT to Win Friends and Inﬂuence Objects
Okay, but how do you keep from doing this? The principle
provides some guidelines: take any object; now from any
method in that object, the principle tells us that we should
only invoke methods that belong to:

ß
ß
ß
ß

The object itself
Objects passed in as a parameter to the method
Any object the method creates or instantiates
Any components of the object

s not
lines tell u ere
e
id
u
g
e
s
e
at w
at th
Notice th thods on objects thmethods!!
e
to call m from calling other
returned
that is
nent” as any object
Think of a “compo instance variable. In other
referenced by an is as a HAS-A relationship.
words think of th

This sounds kind of stringent doesn’t it? What’s the harm in
calling the method of an object we get back from another
call? Well, if we were to do that, then we’d be making a
request of another object’s subpart (and increasing the
number of objects we directly know). In such cases, the
principle forces us to ask the object to make the request for us;
that way we don’t have to know about its component objects
(and we keep our circle of friends small). For example:

Without the
Principle

public ﬂoat getTemp() {
Thermometer thermometer = station.getThermometer();
return thermometer.getTemperature();
}

Here we get the thermometer object
from the station and then call the
getTemperature() method ourselves.

With the
Principle

public ﬂoat getTemp() {
return station.getTemperature();
}

When we apply the principle, we add a
method to the Station class that makes
the request to the thermometer for us.
This reduces the number of classes we’re
dependent on.

266

Chapter 7
Download at WoweBook.Com

the adapter pattern

Keeping your method calls in bounds...
Here’s a Car class that demonstrates all the ways you can call methods and still
adhere to the Principle of Least Knowledge:

public class Car {
Engine engine;
// other instance variables

ponent of
Here’s a com e can call
this class. W
its methods.

public Car() {
// initialize engine, etc.
}

Here we’re creating a new
object, its methods are legal.

public void start(Key key) {
Doors doors = new Doors();
boolean authorized = key.turns();
if (authorized) {
engine.start();
updateDashboardDisplay();
doors.lock();
}
}
public void updateDashboardDisplay() {
// update display
}

You can call a method
on an object passed as
a parameter.
hod on a
You can call a met object.
component of the

You can call a local method
within the object.
You can call a method on an
object you create or instantiate.

}

there are no

Q:

There is another principle called
the Law of Demeter; how are they
related?

A:

The two are one and the same
and you’ll encounter these terms being
intermixed. We prefer to use the Principle of
Least Knowledge for a couple of reasons: (1)
the name is more intuitive and (2) the use of
the word “Law” implies we always have to

Dumb Questions
apply this principle. In fact, no principle is a
law, all principles should be used when and
where they are helpful. All design involves
tradeoffs (abstractions versus speed, space
versus time, and so on) and while principles
provide guidance, all factors should be taken
into account before applying them.

Q:

Are there any disadvantages
to applying the Principle of Least
Knowledge?

A:

Yes; while the principle reduces
the dependencies between objects and
studies have shown this reduces software
maintenance, it is also the case that
applying this principle results in more
“wrapper” classes being written to handle
method calls to other components. This
can result in increased complexity and
development time as well as decreased
runtime performance.

you are here 4
Download at WoweBook.Com

267

violating the principle of least knowledge

Sharpen your pencil

Do either of these classes violate the Principle of Least Knowledge?
Why or why not?

public House {
WeatherStation station;
// other methods and constructor
public ﬂoat getTemp() {
return station.getThermometer().getTemperature();
}
}

public House {
WeatherStation station;
// other methods and constructor
public ﬂoat getTemp() {
Thermometer thermometer = station.getThermometer();
return getTempHelper(thermometer);
}
public ﬂoat getTempHelper(Thermometer thermometer) {
return thermometer.getTemperature();
}
}

Hard hat area. watch out
for falling assumptions

A

brain
power
Can you think of a common use of Java that violates the Principle of Least Knowledge?
Should you care?

Answer: How about System.out.println()?

268

Chapter 7
Download at WoweBook.Com

the adapter pattern

The Facade and the Principle of Least Knowledge
end;
ly has one fri
This client on terFacade. In
the HomeTheaing, having only
OO programm a GOOD thing!
one friend is

Client

The HomeTheaterFacade
manages all those subsystem
components for the client.
It keeps the client simple
and flexible.

HomeTheaterFacade
watchMovie()
endMovie()
listenToCd()
endCd()
listenToRadio()
endRadio()

Amplifier

e
ade the hom
We can upgr ponents without
theater comhe client .
affecting t

tuner
dvdPlayer
cdPlayer
on()
off()

Tuner

setCd()

DvdPlayer

setDvd()

amplifier

setStereoSound()

on()

amplifier

setSurroundSoud()

off()

setTuner()

setAm()

off()

setVolume()

setFm()

on()
eject()
pause()

setFrequency()

play()
play()
setSurroundAudio()

CdPlayer
amplifier

stop()

on()

Screen

bsystems adhering
We try to keep su Least Knowledge
to the Principle ofts too complex and
as well. If this geare intermingling, we
too many friends tional facades to
can introduce addibsystems.
form layers of su

setTwoChannelAudio()

up()

off()

down()

eject()
pause()
play()
play()

Projector

stop()
dvdPlayer
on()

PopcornPopper

off()
tvMode()

on()
off()

TheaterLights

pop()

wideScreenMode()

on()
off()
dim()

you are here 4
Download at WoweBook.Com

269

your design toolbox

Tools for your Design Toolbox
Your toolbox is starting to get heavy! In this
chapter we’ve added a couple of patterns that
allow us to alter interfaces and reduce coupling
between clients and the systems they use.

s
OO Principle

OO Basics

BULLET POINTS

ß When you need to use an
existing class and its interface
is not the one you need, use an
adapter.

ß When you need to simplify

Abstraction
n
Encapsulatio
es
ri
va
what
orphism
Encapsulate
itancePolym
er
h
in
er
ov
sition
Favor compo
Inheritance

and unify a large interface or
complex set of interfaces, use a
facade.

ß An adapter changes an
interface into one a client
expects.

erfaces, not

int
Program to
ions
at
t
en
implem
led designs
loosely coup
Strive for
teract
cts that in
between obje
extension
be open for
ld
ou
sh
es
ss
Cla
ion
or modificat
but closed f
. Do not
abstractions
on
d
en
ep
D
ncretions
depend on co
ds
o your frien
Only talk t

OO Patteinresnafsinfames ilya oofneal-gotori-tmhmnas,anly

ß A facade decouples a client
ique
new techn level
a
e
v
a
h
e
w
W
aining a lo
for maint g in our designs.
of couplin , talk only to your
(remember
friends)...

ß Implementing an adapter may
require little work or a great deal
of work depending on the size
and complexity of the target
interface.

ß Implementing a facade requires

...and TWO new patterns.
Each changes an interface,
the adapter to convert
and the facade to unify
ß
and simplify

def de
mitPio
oavimtfdicineaeallnya.n
sddso
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
Adntamtocak
batcjeesohcrttayhe
e
e
eits sof
ahm
d
go
F
b
o
t
al
ll
es
c
y
c
a
t
d
c
e
at
he
,
c
je
n
o
tstgatfeamiltie
t
pulenAdbe stlebrilc. itatSieotcra
encadpseD
yanrnlegeeetatosstbhin
M
o
eg
t
t
y
s
r
a
h
c
o
it
t
dsshcootun,tlybuhas est
n
e
ab
xsubdinibtjergueleuscpatdasactwla.beitje
ofbajece foormvifdocclreieiecnt
le
tnotnha
a
f
reenanspinge
s
e
ootnnF
r
a
eesiraen
inter
g
o
d
E
whch
in
t
r
d
r
endtoetpoif
ro
ctaelaes.ntssgloesbal peoqinu t
lyafsoragpfrecle
endladeenssctinid-gepEfwronohrcviiccaladehpxesu
cnrodeenrelainadntteSeostdrin
inpdeeep
ss
c
varydeD
b
d
s
e
d
s u
n
e
t
n
su
a
e
ss
a
r
o
e
la
c
m
t
c
nleatoaivysu
hae.nireFcinoanctte.,orrftyahceMereeobtfyholedttleinteg yoerent
nlleineybCgcinotstm
auatltomespratetincioicifst
it
e
h
je
h
b
t
t
t
o
.
o
t
y
ia
s
o
d
t
t
t
n
t
li
noanavenarsccaess
tsion with iff
Adaptfeurtnoc-aCanoctolafhessrpadinreatfmeererftainecrsteizgacenlittceehialineoetrnrtlos g requests, and
rface
unified inte em.
a
rks,tqoueu
s
e
a class in tssucblaclassssreeseqs.wuoest
d
s.
n
vi
o
io
r
t
P
a
ebsyst
f oper
expect. Le ’t othersuwpispeorbtecuanudseoaoble Facadt of interfaces in a sul interface
n
se
ve
ld
le
u
a
o
r
to
that c
o use.
ines a highe
interfaces.
Facade def the subsystem easier t
incompatible
that makes

270

from a complex subsystem.

Chapter 7
Download at WoweBook.Com

that we compose the facade
with its subsystem and use
delegation to perform the work
of the facade.
There are two forms of the
Adapter Pattern: object and
class adapters. Class adapters
require multiple inheritance.

ß You can implement more than
one facade for a subsystem.

ß An adapter wraps an object to
change its interface, a decorator
wraps an object to add new
behaviors and responsibilities,
and a facade “wraps” a set of
objects to simplify.

the adapter pattern

Yes, it’s another crossword. All of the solution words are from this chapter.

�

�

�
�

�

�

�

�

�
��

��
��
��

��
��

��
��

��

��

������

����

�� ���� �� ������ �������� ��� ���� ���� ���
������
�� �� ������� ����� �� ���������
�� ����� �� ������� �� ������
��� �� �� ������ ��� ����� ���� ��� �� �����
���� ������
��� ������� ���� ��� ����� ���� ������
��� ������ ����� ����� ��� ����� ������
��� ����� �� �� ������ ���� �������
��� ������������ �� ��� ��������� �� �����
���������� ��� ���� ����������
��� � ��������� ���������� �� ���������
��� ��� �������� ����� ���� ������

�� ��������� ������ ������� ���� �� ������
�� ��� ��������� �� ������
�� ��������� ���� ������ �� ���� �� �� �������
���� ������
�� � ������ ���� ��� ��������
�� ������������ �� � ����
�� ������� ���� �������� ��� ��������� �� �����
���������� �����������������
��� �� ����� �� �������� ������� ����
��� ������� ������ ���� ��� ��������� ���������
��� �� ������� ��� � ��������� ��� �� ���� ��
����� �� ������

you are here 4
Download at WoweBook.Com

271

exercise solutions

Sharpen your pencil

Let’s say we also need an adapter that converts a Duck to a Turkey.
Let’s call it DuckAdapter. Write that class:

keys
adapting Tur
Now we are we implement the
to Ducks, so ace.
Turkey interf

Exercise
solutions

public class DuckAdapter implements Turkey {
Duck duck;
Random rand;
public DuckAdapter(Duck duck) {
this.duck = duck;
rand = new Random();
}
public void gobble() {
duck.quack();
}
public void ﬂy() {
if (rand.nextInt(5)
duck.ﬂy();
}
}

== 0) {

Do either of these classes violate the Principle of Least Knowledge?
For each, why or why not?

public House {
WeatherStation station;
// other methods and constructor
public ﬂoat getTemp() {
return station.getThermometer().getTemperature();
}
}

wledge!
Least Kno
Principle ofhod of an object
e
th
s
te
et
Viola
lling the m
You are cafrom another call.
ed
rn
tu
re

public House {
WeatherStation station;
// other methods and constructor

public ﬂoat getTemp() {
Thermometer thermometer = station.getThermometer();
return getTempHelper(thermometer);
}
public ﬂoat getTempHelper(Thermometer thermometer) {
return thermometer.getTemperature();
}

of Least Knowledge!
Doesn’t violate Principle way around the
This seems like hacking our
really changed since we
principle. Has anything to another method?
call
just moved out the

}

272

We also recreate a random object;
take a look at the fly() method
to see how it is used.

A gobble just becomes a quack.

}

Sharpen your pencil

We stash a reference to the Duck we are adapting.

Chapter 7
Download at WoweBook.Com

er than
Since ducks fly a lot longonly fly the
turkeys, we decided to five times.
duck on average one of

the adapter pattern

Exercise solutions

You’ve seen how to implement an adapter that adapts an Enumeration to an
Iterator; now write an adapter that adapts an Iterator to an Enumaration.
public class IteratorEnumeration implements Enumeration {
Iterator iterator;
public IteratorEnumeration(Iterator iterator) {
this.iterator = iterator;
}
public boolean hasMoreElements() {
return iterator.hasNext();
}
public Object nextElement() {
return iterator.next();
}
}

Match each pattern with its intent:

Pattern

Intent

Decorator

Convert one interface to
another

Adapter

Don’t alter interface, but add
responsibility

Facade

Make interface simpler

you are here 4
Download at WoweBook.Com

273

crossword puzzle solution

Exercise solutions

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

� � � � �

�

�
��

��

�

�

�

�

�

�

�
��

��

�

�

�

� � �

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

��

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

� �

�

�

�

�

�

�

�

�

�

������

����

���������������������������������������������
�������������������������������������������
������ �������
����������������������
�� �� ������� ����� �� ��������� ����������
����������������������������������������
������������������������������
�� ��������� ���� ������ �� ���� �� �� �������
���������������������
�����������������������������
���������������������������������������������
�������������������������������������������
������������������������
�����������������������������������
���������������������������������������
�� ������� ���� �������� ��� ��������� �� �����
��������
���������� ����������������� ���������
Chapter 7
274
��� ������ ����� ����� ��� ����� ������
��������������������������������������
��������
���������
Download at WoweBook.Com
������������������������������������������
��� ������� ������ ���� ��� ���������

8 the Template Method Pattern

h
Encapsulating
g
g
Algorithms

Yeah, he’s a great boss until
it comes to getting down in this
hole, then it ALL becomes MY job.
See what I mean? He’s nowhere
in sight!

We’re on an encapsulation roll; we’ve encapsulated object
creation, method invocation, complex interfaces, ducks,
pizzas... what could be next? We’re going to get down to encapsulating
pieces of algorithms so that subclasses can hook themselves right into a computation
anytime they want. We’re even going to learn about a design principle inspired by
Hollywood.
this is a new chapter
Download at WoweBook.Com

275

coffee and tea recipes are similar

It’s time for some more caffeine
Some people can’t live without their coffee; some
people can’t live without their tea. The common
ingredient? Caffeine of course!
But there’s more; tea and coffee are made in very
similar ways. Let’s check it out:

al
ing Manu
in
a
r
T
a
t
ris
Coffee Ba
Starbuzz
cipes
ese re
es.

g
th
bevera
ollow
ease f
arbuzz
l
t
P
S
g
!
n
as
pari
Barist
en pre
ely wh
s
i
c
e
r
p

cipe
Coffee Re
Starbuzz

r
r
e wate
g wate
il som
boilin
n
i
(1) Bo
e
fe
ew cof
cup
(2) Br
fee in
f
o
c
r
u
o
ilk
P
m
)
d
3
(
gar an
u
s
d
d
(4) A

e
Tea Recip
Starbuzz

r
e wate
water
il som
oiling
b
n
(1) Bo
i
a
eep te
up
(2) St
a in c
e
t
r
u
o
P
)
3
(
n
d lemo
(4) Ad
kept
ld be
d shou
ets an
r
c
e
s
trade
Coffee
tial.
arbuzz
onﬁden
are St
ctly c
i
s
r
e
t
p
s
i
c
All re

276

Chapter 8
Download at WoweBook.Com

The recipe for
coffee looks a lot
like the recipe for
tea, doesn’t it?

the template method pattern

Whipping up some coffee and tea classes
(in Java)
Let’s play “coding barista” and write
some code for creating coffee and tea.
Here’s the coffee:

Here’s our Coffee class

for making coffee.

public class Coffee {

,
pe for coffee
Here’s our reciof the training manual.
straight out
ed
s is implement
ep
st
e
h
t
f
o
Each
hod.
a separate met

void prepareRecipe() {
boilWater();
brewCoffeeGrinds();
pourInCup();
addSugarAndMilk();
}
public void boilWater() {
System.out.println(“Boiling water”);
}

public void brewCoffeeGrinds() {
System.out.println(“Dripping Coffee through ﬁlter”);
}
public void pourInCup() {
System.out.println(“Pouring into cup”);
}

as

Each of these methods
implements one step of
the algorithm. There’s
a method to boil water,
brew the coffee, pour
the coffee in a cup and
add sugar and milk.

public void addSugarAndMilk() {
System.out.println(“Adding Sugar and Milk”);
}
}

you are here 4
Download at WoweBook.Com

277

tea implementation

and now the Tea...
public class Tea {
void prepareRecipe() {
boilWater();
steepTeaBag();
pourInCup();
addLemon();
}

This looks very similar to the
one we just implemented in
Coffee; the second and forth
steps are different, but it’s
basically the same recipe.

public void boilWater() {
System.out.println(“Boiling water”);
}
public void steepTeaBag() {
System.out.println(“Steeping the tea”);
}
public void addLemon() {
System.out.println(“Adding Lemon”);
}
public void pourInCup() {
System.out.println(“Pouring into cup”);
}
}

When we’ve got code
duplication, that’s a good sign
we need to clean up the design. It
seems like here we should abstract
the commonality into a base class
since coffee and tea are so
similar?

278

Chapter 8
Download at WoweBook.Com

These two
methods are
specialized to
Tea.

Notice that
these two
methods are
exactly the
same as they are
in Coffee! So
we definitely
have some code
duplication going
on here.

the template method pattern

Design Puzzle
You’ve seen that the Coffee and Tea classes have a fair bit of code duplication. Take
another look at the Coffee and Tea classes and draw a class diagram showing how you’d
redesign the classes to remove redundancy:

you are here 4
Download at WoweBook.Com

279

ﬁrst cut at abstraction

Sir, may I abstract your Coffee, Tea?
It looks like we’ve got a pretty straightforward design
exercise on our hands with the Coffee and Tea classes.
Your ﬁrst cut might have looked something like this:

urInCup()
The boilWater() and po both subclasses,
methods are shared by the superclass.
so they are defined in

CaffeineBeverage

The prepareRecipe() method
differs in each subclass, so
it is
defined as abstract.

Each subclass
implements its
own recipe.

prepareRecipe()
boilWater()
pourInCup()

Tea

Coffee
prepareRecipe()

prepareRecipe()

brewCoffeeGrinds()

steepTeaBag()

addSugarAndMilk()

addLemon()

Each subclass overrides
the prepareRecipe()
method and implements
its own recipe.

ee
ecific to Coff
The methods spin the subclasses.
and Tea stay

A

brain
power
Did we do a good job on the redesign? Hmmmm, take another look. Are we overlooking some other
commonality? What are other ways that Coffee and Tea are similar?

280

Chapter 8
Download at WoweBook.Com

the template method pattern

Taking the design further...
So what else do Coffee and Tea have in common? Let’s start with
the recipes.

e
ffee Recip
o
C
z
z
u
b
r
Sta

r
ter
e wate
ing wa
il som
n boil
i
(1) Bo
e
e
f
ew cof
in cup
(2) Br
offee
c
r
u
lk
o
(3) P
and mi
Starbuzz Tea Recipe
sugar
d
d
A
(4)
(1) Boil some water
(2) Steep tea in boilin
g water
(3) Pour tea in cup
(4) Add lemon

Notice that both recipes follow the same algorithm:

1

Boil some water.

2

Use the hot water to extract the coffee
or tea.

3

Pour the resulting beverage into a cup.

4

Add the appropriate condiments to the
beverage.

These aren’t
abstracted, but
are the same,
they just apply
to different
beverages.

These two are
already abstracted
into the base class.

So, can we ﬁnd a way to abstract prepareRecipe() too? Yes, let’s ﬁnd out...

you are here 4
Download at WoweBook.Com

281

abstract the algorithm

Abstracting prepareRecipe()
Let’s step through abstracting prepareRecipe()
from each subclass (that is, the Coffee and Tea
classes)...
1

The ﬁrst problem we have is that Coffee uses brewCoffeeGrinds() and
addSugarAndMilk() methods while Tea uses steepTeaBag() and addLemon()
methods.

Tea

Coffee
void prepareRecipe() {
boilWater();
brewCoffeeGrinds();
pourInCup();
addSugarAndMilk();
}

void prepareRecipe() {
boilWater();
steepTeaBag();
pourInCup();
addLemon();
}

Let’s think through this: steeping and brewing aren’t so different; they’re pretty analogous.
So let’s make a new method name, say, brew(), and we’ll use the same name whether
we’re brewing coffee or steeping tea.
Likewise, adding sugar and milk is pretty much the same as adding a lemon: both
are adding condiments to the beverage. Let’s also make up a new method name,
addCondiments(), to handle this. So, our new prepareRecipe() method will look like this:

void prepareRecipe() {
boilWater();
brew();
pourInCup();
addCondiments();
}

2

282

Now we have a new prepareRecipe() method, but we need to ﬁt it into the code.
To do this we are going to start with the CaffeineBeverage superclass:

Chapter 8
Download at WoweBook.Com

the template method pattern

stract, just
CaffeineBeverage is ab
like in the class design.
public abstract class CaffeineBeverage {
ﬁnal void prepareRecipe() {
boilWater();
brew();
pourInCup();
addCondiments();
}

pe() method will be used
Now, the same prepareReci ee. prepareRecipe() is
to make both Tea and Coff n’t want our subclasses
declared final because we domethod and change the
to be able to override thissteps 2 and 4 to brew()
recipe! We’ve generalized nts().
the beverage and addCondime

abstract void brew();
abstract void addCondiments();

Because Coffee and Tea handle these methods
in different ways, they’re going to have to
be declared as abstract. Let the subclasses
worry about that stuff!

void boilWater() {
System.out.println(“Boiling water”);
}
void pourInCup() {
System.out.println(“Pouring into cup”);
}

Remember, we moved these into
the CaffeineBeverage class (back
in our class diagram).

}
3

Finally we need to deal with the Coffee and Tea classes. They now rely on
CaffeineBeverage to handle the recipe, so they just need to handle brewing and
condiments:
public class Tea extends CaffeineBeverage {
public void brew() {
System.out.println(“Steeping the tea”);
}
public void addCondiments() {
System.out.println(“Adding Lemon”);
}
}

As in our design, Tea and Coffee
now extend CaffeineBeverage.

Tea needs to define brew() and
addCondiments() — the two abstract
methods from Beverage.
Same for Coffee, except Coffee deals
with coffee, and sugar and milk instead
of tea bags and lemon.

public class Coffee extends CaffeineBeverage {
public void brew() {
System.out.println(“Dripping Coffee through ﬁlter”);
}
public void addCondiments() {
System.out.println(“Adding Sugar and Milk”);
}
}

you are here 4
Download at WoweBook.Com

283

class diagram for caffeine beverages

Sharpen your pencil

284

Draw the new class diagram now that we’ve moved the
implementation of prepareRecipe() into the CaffeineBeverage class:

Chapter 8
Download at WoweBook.Com

the template method pattern

What have we done?
We’ve recognized
that the two recipes
are essentially the
same, although
some of the steps
require different
implementations. So
we’ve generalized the
recipe and placed it in
the base class.

Te a
te r

1

Boi l some wa

2

Stee p th e te a

3

Po ur te a in a

4

Add lemon

ate r
b ag in th e w

C o f fe e
1
2
3

cup

4

Bo il s om
e wate r
Bre w t h

e c o f fe e

gr inds

e e in a c

up

Po u r c o f
f
Add s ug

ar and m

il k

Caffeine Beverage
generalize

relies on
subclass for

ss

Tea subcla

some steps

2

Stee p th e te ab ag in th e

4

Add lemon

wate r

1

Boil some water

2

Brew

3

Pour beverage in a cup

4

Add condiments

e knows
Caffeine Beverag steps of
and controls the rforms
the recipe, and pe lf, but
steps 1 and 3 itse offee
relies on Tea or C 4.
to do steps 2 and

generalize

relies on
subclass for
some steps

Coffee

2

Bre w th e co ff

4

Add sug a r an

ee gri nds

d mil k

you are here 4
Download at WoweBook.Com

subclass

285

meet the template method pattern

Meet the Template Method
We’ve basically just implemented the Template Method Pattern. What’s that? Let’s look
at the structure of the CaffeineBeverage class; it contains the actual “template method:”

prepareRecipe() is our template method.
Why?
public abstract class CaffeineBeverage {
void ﬁnal prepareRecipe() {
boilWater();

brew();

Because:
(1) It is a method, after all.
(2) It serves as a template for an
algorithm, in this case, an algorithm for
making caffeinated beverages.
In the template, each step of
the algorithm is represented
by a method.

pourInCup();

Some methods are handled
by this class...

addCondiments();
}

...and some are handled
by the subclass.

abstract void brew();
abstract void addCondiments();
void boilWater() {
// implementation
}

The methods that need to
be supplied by a subclass are
declared abstract.

void pourInCup() {
// implementation
}
}

The Template Method defines the steps of an algorithm and allows
subclasses to provide the implementation for one or more steps.
286

Chapter 8
Download at WoweBook.Com

the template method pattern

Let’s make some tea...

Behind
the Scenes

Let’s step through making a tea and trace through
how the template method works. You’ll see that
the template method controls the algorithm; at
certain points in the algorithm, it lets the subclass
supply the implementation of the steps...

1

Okay, ﬁrst we need a Tea object...
Tea myTea = new Tea();

2

boilWater();
brew();
pourInCup();
addCondiments();

Then we call the template method:
myTea.prepareRecipe();
which follows the algorithm for making caffeine
beverages...

3

First we boil water:

The prepareRecipe()
method controls the
algorithm, no one can
change this, and it
counts on subclasses to
provide some or all of
the implementation.
CaffeineBeverage

boilWater();

prepareRecipe()

which happens in CaffeineBeverage.

4

boilWater()
pourInCup()

Next we need to brew the tea, which only the subclass knows
how to do:
brew();
Tea

5

Now we pour the tea in the cup; this is the same for all beverages so it
happens in CaffeineBeverage:

brew()
addCondiments();

pourInCup();

6

Finally, we add the condiments, which are speciﬁc to each beverage, so
the subclass implements this:
addCondiments();

you are here 4
Download at WoweBook.Com

287

what did template method get us?

What did the Template Method get us?

Underpowered Tea & Coffee
implementation

288

New, hip CaffeineBeverage
powered by Template Method

Coffee and Tea are running the show;
they control the algorithm.

The CaffeineBeverage class runs
the show; it has the algorithm, and
protects it.

Code is duplicated across Coffee and
Tea.

The CaffeineBeverage class
maximizes reuse among the
subclasses.

Code changes to the algorithm
require opening the subclasses and
making multiple changes.

The algorithm lives in one place and
code changes only need to be made
there.

Classes are organized in a structure
that requires a lot of work to add a
new caffeine beverage.

The Template Method version provides
a framework that other caffeine
beverages can be plugged into. New
caffeine beverages only need to
implement a couple of methods.

Knowledge of the algorithm and how
to implement it is distributed over
many classes.

The CaffeineBeverage class
concentrates knowledge about the
algorithm and relies on subclasses to
provide complete implementations.

Chapter 8
Download at WoweBook.Com

the template method pattern

Template Method Pattern defined
You’ve seen how the Template Method Pattern works in our Tea and Coffee example;
now, check out the ofﬁcial deﬁnition and nail down all the details:

The Template Method Pattern deﬁnes the skeleton
of an algorithm in a method, deferring some steps to
subclasses. Template Method lets subclasses redeﬁne
certain steps of an algorithm without changing the
algorithm’s structure.

This pattern is all about creating a template for an algorithm. What’s a template?
As you’ve seen it’s just a method; more speciﬁcally, it’s a method that deﬁnes an
algorithm as a set of steps. One or more of these steps is deﬁned to be abstract and
implemented by a subclass. This ensures the algorithm’s structure stays unchanged,
while subclasses provide some part of the implementation.
Let’s check out the class diagram:

The template method makes use of the
primitiveOperations to implement an
algorithm. It is decoupled from the actual
implementation of these operations.
The AbstractClass
contains the template
method.
...and abstract versions
of the operations used
in the template method.

AbstractClass
templateMethod()
primitiveOperation1()

primitiveOperation1();
primitiveOperation2();

primitiveOperation2()

ConcreteClass

ny
ay be ma each
m
e
r
e
h
T
of
Classes,
Concreteting the full set he
n
t
e
implem ns required by
operatio method.
template

primitiveOperation1()
primitiveOperation2()

The ConcreteClass implements
the abstract operations,
which are called when the
templateMethod() needs them.

you are here 4
Download at WoweBook.Com

289

template method pattern up close

Code Up Close
Let’s take a closer look at how the AbstractClass is deﬁned, including the template method
and primitive operations.

ss; it
Here we have our abstract cla to
is declared abstract and meant
provide
be subclassed by classes that ions.
implementations of the operat

It’s
Here’s the template method. classes
sub
t
declared final to preven
of
from reworking the sequence
steps in the algorithm.

abstract class AbstractClass {
ﬁnal void templateMethod() {
primitiveOperation1();
primitiveOperation2();
concreteOperation();
}

The template method
defines the sequence of
steps, each represented
by a method.

abstract void primitiveOperation1();
abstract void primitiveOperation2();

}

void concreteOperation() {
// implementation here
}

We also have a concrete operation defined
in the abstract class. More about these
kinds of methods in a bit...

290

Chapter 8
Download at WoweBook.Com

In this example, two of
the primitive operations
must be implemented by
concrete subclasses.

the template method pattern

Code Way Up Close
Now we’re going to look even

closer at the types of method that can go in the abstract class:

We’ve changed the to include
templateMethod()
a new method call.
abstract class AbstractClass {
ﬁnal void templateMethod() {
primitiveOperation1();
primitiveOperation2();
concreteOperation();
hook();
}
abstract void primitiveOperation1();
abstract void primitiveOperation2();
ﬁnal void concreteOperation() {
// implementation here
}
void hook() {}

We still have our primitive
methods; these are
abstract and implemented
by concrete subclasses.

fined in the
A concrete operation is de declared
is
abstract class. This one ’t override it.
final so that subclasses can late method
It may be used in the tempsses.
directly, or used by subcla

}

A concrete method, but
it does nothing!

We can also have concrete methods that do nothing
by default; we call these “hooks.” Subclasses are free
to override these but don’t have to. We’re going to
see how these are useful on the next page.

you are here 4
Download at WoweBook.Com

291

implement a hook

Hooked on
Template Method...

With a hook, I can override
the method, or not. It’s my choice.
If I don’t, the abstract class
provides a default implementation.

A hook is a method that is declared in the
abstract class, but only given an empty
or default implementation. This gives
subclasses the ability to “hook into” the
algorithm at various points, if they wish; a
subclass is also free to ignore the hook.
There are several uses of hooks; let’s take
a look at one now. We’ll talk about a few
other uses later:

public abstract class CaffeineBeverageWithHook {
ﬁnal void prepareRecipe() {
boilWater();
brew();
pourInCup();
if (customerWantsCondiments()) {
addCondiments();
}
}

ent
e conditional statem
We’ve added a littl s on a concrete
that bases its succesantsCondiments(). If
method, customerWTS condiments, only
the customer WAN ondiments().
then do we call addC

abstract void brew();
abstract void addCondiments();
void boilWater() {
System.out.println(“Boiling water”);
}

a method
Here we’ve defined y default
pt
with a (mostly) em his method just
implementation. T es nothing else.
returns true and do

void pourInCup() {
System.out.println(“Pouring into cup”);
}
boolean customerWantsCondiments() {
return true;
}
}

292

This is a hook because the
subclass can override this
method, but doesn’t have to.

Chapter 8
Download at WoweBook.Com

the template method pattern

Using the hook
To use the hook, we override it in our subclass. Here, the hook controls whether
the CaffeineBeverage evaluates a certain part of the algorithm; that is, whether
it adds a condiment to the beverage.
How do we know whether the customer wants the condiment? Just ask !

public class CoffeeWithHook extends CaffeineBeverageWithHook {
public void brew() {
System.out.println(“Dripping Coffee through ﬁlter”);
}
public void addCondiments() {
System.out.println(“Adding Sugar and Milk”);
}
public boolean customerWantsCondiments() {
String answer = getUserInput();
if (answer.toLowerCase().startsWith(“y”)) {
return true;
} else {
return false;
}
}

erride
Here’s where you ov e your
id
the hook and prov
own functionality.

Get the user’s input on
the condiment decision
and return true or false.
depending on the input.

private String getUserInput() {
String answer = null;
System.out.print(“Would you like milk and sugar with your coffee (y/n)? “);

}

BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
try {
answer = in.readLine();
} catch (IOException ioe) {
System.err.println(“IO error trying to read your answer”);
}
if (answer == null) {
return “no”;
and
if he’d like milk and line.
er
}
us
he
t
ks
as
m
e
m
This cod
m the co
return answer;
ts his input fro

sugar and ge

}
you are here 4
Download at WoweBook.Com

293

test drive

Let’s run the TestDrive
Okay, the water’s boiling... Here’s the test code where
we create a hot tea and a hot coffee

public class BeverageTestDrive {
public static void main(String[] args) {
TeaWithHook teaHook = new TeaWithHook();
CoffeeWithHook coffeeHook = new CoffeeWithHook();
System.out.println(“\nMaking tea...”);
teaHook.prepareRecipe();
System.out.println(“\nMaking coffee...”);
coffeeHook.prepareRecipe();

Create a tea.
A coffee.
And call prepareRecipe() on both!

}
}

And let’s give it a run...
File Edit Window Help send-more-honesttea

%java BeverageTestDrive
Making tea...
Boiling water
A steaming cup of tea, and yes,
Steeping the tea
course we want that lemon!
Pouring into cup
Would you like lemon with your tea (y/n)? y
Adding Lemon

coffee,

of
Making coffee...
And a nice hot cup e waistline
Boiling water
but we’ll pass on thts.
Dripping Coffee through ﬁlter
expanding condimen
Pouring into cup
Would you like milk and sugar with your coffee (y/n)? n
%

294

Chapter 8
Download at WoweBook.Com

of

the template method pattern

Now, I would have thought
that functionality like asking the
customer could have been used by
all subclasses?

You know what? We agree with you. But you
have to admit before you thought of that it was a
pretty cool example of how a hook can be used
to conditionally control the ﬂow of the algorithm
in the abstract class. Right?
We’re sure you can think of many other more
realistic scenarios where you could use the
template method and hooks in your own code.

there are no

Q:

When I’m creating a template
method, how do I know when to use
abstract methods and when to use
hooks?

A:

Use abstract methods when your
subclass MUST provide an implementation
of the method or step in the algorithm.
Use hooks when that part of the algorithm
is optional. With hooks, a subclass may
choose to implement that hook, but it doesn’t
have to.

Dumb Questions
of an algorithm, or if it isn’t important to
the subclass’ implementation, it can skip
it. Another use is to give the subclass
a chance to react to some step in the
template method that is about to happen,
or just happened. For instance, a hook
method like justReOrderedList() allows the
subclass to perform some activity (such as
redisplaying an onscreen representation)
after an internal list is reordered. As you’ve
seen a hook can also provide a subclass
with the ability to make a decision for the
abstract class.

Q:

Q:

A:

A:

What are hooks really supposed
to be used for?

There are a few uses of hooks. As
we just said, a hook may provide a way for
a subclass to implement an optional part

Does a subclass have to
implement all the abstract methods in the
AbstractClass?
Yes, each concrete subclass defines
the entire set of abstract methods and

provides a complete implementation of the
undefined steps of the template method’s
algorithm.

Q:

It seems like I should keep my
abstract methods small in number,
otherwise it will be a big job to implement
them in the subclass.

A:

That’s a good thing to keep in
mind when you write template methods.
Sometimes this can be done by not making
the steps of your algorithm too granular. But
it’s obviously a trade off: the less granularity,
the less flexibility.
Remember, too, that some steps will be
optional; so you can implement these as
hooks rather than abstract methods, easing
the burden on the subclasses of your
abstract class.

you are here 4
Download at WoweBook.Com

295

the hollywood principle

You’ve heard me say it
before, and I’ll say it again:
don’t call me, I’ll call you!

The Hollywood Principle
We’ve got another design principle for you; it’s called the
Hollywood Principle:

The Hollywood Principle
Don’t call us, we’ll call you.

Easy to remember, right? But what has it got to do with OO
design?
The Hollywood principle gives us a way to prevent
“dependency rot.” Dependency rot happens when you have
high-level components depending on low-level components
depending on high-level components depending on sideways
components depending on low-level components, and so on.
When rot sets in, no one can easily understand the way a
system is designed.
With the Hollywood Principle, we allow low-level components
to hook themselves into a system, but the high-level
components determine when they are needed, and how. In
other words, the high-level components give the low-level
components a “don’t call us, we’ll call you” treatment.

High-Level Component

nts
l compone
Low-leveicipate in the
can part ion.
computat

296

Low-Level
Component

Another
Low-Level
Component

Chapter 8
Download at WoweBook.Com

l
But the high-leve l
ro
components cont
when and how.

A low-level component ne
calls a high-level compon ver
ent
directly.

the template method pattern

The Hollywood Principle and Template Method
The connection between the Hollywood Principle and the Template Method Pattern is probably somewhat
apparent: when we design with the Template Method Pattern, we’re telling subclasses, “don’t call us, we’ll call
you.” How? Let’s take another look at our CaffeineBeverage design:

h-level
CaffeineBeverage is our higl over the
component. It has contro and calls on
algorithm for the recipe, ey’re needed
the subclasses only when tha method.
for an implementation of

Clients of bevera
on the CaffeineBges will depend
abstraction rath everage
concrete Tea or er than a
reduces dependen Coffee, which
overall system. cies in the

CaffeineBeverage
prepareRecipe()
boilWater()
pourInCup()
brew()
addCondiments()

Tea

Coffee
brew()
addCondiments()

brew()
addCondiments()

The subclasses ar
provide implemen e used simply to
tation details.

What other patterns make use of the Hollywood Principle?

The Factory Method, Observer; any others?

A

brain
power

never
Tea and Coffee class
ct
ra
call the abst being
directly without
“called” first.

you are here 4
Download at WoweBook.Com

297

who does what

there are no

Dumb Questions

Q:

How does the Hollywood Principle
relate to the Dependency Inversion
Principle that we learned a few chapters
back?

A:

The Dependency Inversion
Principle teaches us to avoid the use of
concrete classes and instead work as
much as possible with abstractions. The
Hollywood Principle is a technique for
building frameworks or components so that
lower-level components can be hooked

into the computation, but without creating
dependencies between the lower-level
components and the higher-level layers. So,
they both have the goal of decoupling, but
the Dependency Inversion Principle makes a
much stronger and general statement about
how to avoid dependencies in design.
The Hollywood Principle gives us a
technique for creating designs that allow
low-level structures to interoperate while
preventing other classes from becoming too
dependent on them.

Q:

Is a low-level component
disallowed from calling a method in a
higher-level component?

A:

Not really. In fact, a low level
component will often end up calling a method
defined above it in the inheritance hierarchy
purely through inheritance. But we want to
avoid creating explicit circular dependencies
between the low-level component and the
high-level ones.

Match each pattern with its description:

298

Pattern

Description

Template Method

Encapsulate interchangeable
behaviors and use delegation to
decide which behavior to use

Strategy

Subclasses decide how
to implement steps in an
algorithm

Factory Method

Subclasses decide which
concrete classes to create

Chapter 8
Download at WoweBook.Com

the template method pattern

Template Methods in the Wild
The Template Method Pattern is a very common pattern and
you’re going to ﬁnd lots of it in the wild. You’ve got to have
a keen eye, though, because there are many implementations
of the template methods that don’t quite look like the
textbook design of the pattern.
This pattern shows up so often because it’s a great design tool
for creating frameworks, where the framework controls how
something gets done, but leaves you (the person using the
framework) to specify your own details about what is actually
happening at each step of the framework’s algorithm.
Let’s take a little safari through a few uses in the wild (well,
okay, in the Java API)...

In training, we study the
classic patterns. However,
when we are out in the real world, we
must learn to recognize the patterns
out of context. We must also learn
to recognize variations of patterns,
because in the real world a square
hole is not always truly square.

you are here 4
Download at WoweBook.Com

299

sorting with template method

Sorting with Template Method
What’s something we often need to do with arrays?
Sort them!
Recognizing that, the designers of the Java Arrays class
have provided us with a handy template method for
sorting. Let’s take a look at how this method operates:

We’ve pared down this
code a little to make it
easier to explain. If you’d
like to see it all, grab
the source from Sun and
check it out...

they act together to
We actually have two methods here and
provide the sort functionality.
hod
just a helper metit along
is
,
()
rt
so
,
d
ho
The first met copy of the array and passes method.
that creates a on array to the mergeSort() d tells
as the destinationg the length of the array an
It also passes al t at the first element.
the sort to star
public static void sort(Object[] a) {
Object aux[] = (Object[])a.clone();
mergeSort(aux, a, 0, a.length, 0);
}

The mergeSort() method contains the sort algorithm, and relies
on an implementation of the compareTo() method to complete the
algorithm. If you’re interested in the nitty gritty of how the
sorting happens, you’ll want to check out the Sun source code.

private static void mergeSort(Object src[], Object dest[],
int low, int high, int off)
{

}

300

Think of this as the
template method.

for (int i=low; i<high; i++){
for (int j=i; j>low &&
((Comparable)dest[j-1]).compareTo((Comparable)dest[j])>0; j--)
{
swap(dest, j, j-1);
}
compareTo() is the method we
This is a concrete method, already
}
need to implement to “fill out”
return;
defined in the Arrays

class.

Chapter 8
Download at WoweBook.Com

the template method.

the template method pattern

We’ve got some ducks to sort...
Let’s say you have an array of ducks that you’d like to sort. How
do you do it? Well, the sort template method in Arrays gives us the
algorithm, but you need to tell it how to compare ducks, which you do by
implementing the compareTo() method... Make sense?

No, it doesn’t. Aren’t
we supposed to be
subclassing something? I thought
that was the point of Template
Method. An array doesn’t subclass
anything, so I don’t get how we’d
use sort().

We’ve got an array of
Ducks we need to sort.

Good point. Here’s the deal: the designers of sort() wanted it
to be useful across all arrays, so they had to make sort() a static
method that could be used from anywhere. But that’s okay,
it works almost the same as if it were in a superclass. Now,
here is one more detail: because sort() really isn’t deﬁned in
our superclass, the sort() method needs to know that you’ve
implemented the compareTo() method, or else you don’t have
the piece needed to complete the sort algorithm.
To handle this, the designers made use of the Comparable
interface. All you have to do is implement this interface, which
has one method (surprise): compareTo().

What is compareTo()?
The compareTo() method compares two objects and returns whether one is less than, greater than,
or equal to the other. sort() uses this as the basis of its comparison of objects in the array.
I don’t know,
that’s what
compareTo() tells us.

Am I greater
than you?

you are here 4
Download at WoweBook.Com

301

implementing comparable

Comparing Ducks and Ducks
Okay, so you know that if you want to sort Ducks,
you’re going to have to implement this compareTo()
method; by doing that you’ll give the Arrays class
what it needs to complete the algorithm and sort your
ducks.
Here’s the duck implementation:

parable
Remember, we need to implement the Comng.
interface since we aren’t really subclassi
public class Duck implements Comparable {
String name;
int weight;
public Duck(String name, int weight) {
this.name = name;
this.weight = weight;
}
public String toString() {
return name + “ weighs “ + weight;
}

Our Ducks have a name and a weight

We’re keepin’ it simple; all Ducks do
is print their name and weight!

Okay, here’s what sort needs...
public int compareTo(Object object) {
Duck otherDuck = (Duck)object;

compareTo() takes another Duck to compare THIS Duck to.

if (this.weight < otherDuck.weight) {
return -1;
} else if (this.weight == otherDuck.weight) {
return 0;
} else { // this.weight > otherDuck.weight
return 1;
}
}
}

302

Chapter 8
Download at WoweBook.Com

Here’s where we specify how Ducks
compare. If THIS Duck weighs less
than otherDuck then we return -1;
if they are equal, we return 0; and if
THIS Duck weighs more, we return 1.

the template method pattern

Let’s sort some Ducks
Here’s the test drive for sorting Ducks...

public class DuckSortTestDrive {
public static void main(String[] args) {
Duck[] ducks = {
new Duck(“Daffy”, 8),
new Duck(“Dewey”, 2),
new Duck(“Howard”, 7),
new Duck(“Louie”, 2),
new Duck(“Donald”, 10),
new Duck(“Huey”, 2)
};

Notice that we
call Arrays’ static
method sort, and
pass it our Ducks.

System.out.println(“Before sorting:”);
display(ducks);
Arrays.sort(ducks);

rray of
We need an a look good.
Ducks; these

Let’s print them to see
their names and weights.

It’s sort time!

System.out.println(“\nAfter sorting:”);
display(ducks);
}

Let’s print them (again) to see
their names and weights.

public static void display(Duck[] ducks) {
for (int i = 0; i < ducks.length; i++) {
System.out.println(ducks[i]);
}
}
}

Let the sorting commence!
File Edit Window Help DonaldNeedsToGoOnADiet

%java DuckSortTestDrive
Before sorting:
Daffy weighs 8
Dewey weighs 2
Howard weighs 7
Louie weighs 2
Donald weighs 10
Huey weighs 2
After sorting:
Dewey weighs 2
Louie weighs 2
Huey weighs 2
Howard weighs 7
Daffy weighs 8
Donald weighs 10

The unsorted Ducks

The sorted Ducks

%

you are here 4
Download at WoweBook.Com

303

behind the scenes: sorting ducks

The making of the sorting duck machine

Behind

Let’s trace through how the Arrays sort() template
the Scenes
method works. We’ll check out how the template
method controls the algorithm, and at certain
points in the algorithm, how it asks our Ducks to
supply the implementation of a step...
for (int i=low; i<high; i++){

1

... compareTo() ...
... swap() ...

First, we need an array of Ducks:

}

Duck[] ducks = {new Duck(“Daffy”, 8), ... };

2

Then we call the sort() template method in the Array
class and pass it our ducks:
Arrays.sort(ducks);
The sort() method (and its helper mergeSort()) control
the sort procedure.

3

The sort() method controls
the algorithm, no class can
change this. sort() counts
on a Comparable class to
provide the implementation of
compareTo()

To sort an array, you need to compare two items one
by one until the entire list is in sorted order.
When it comes to comparing two ducks, the sort
method relies on the Duck’s compareTo() method
to know how to do this. The compareTo() method
is called on the ﬁrst duck and passed the duck to be
compared to:
Duck

ducks[0].compareTo(ducks[1]);

First Duck
4

compareTo()
toString()

Duck to compare it to

No inheritance, unlike
a typical template
method.

If the Ducks are not in sorted order, they’re swapped with
the concrete swap() method in Arrays:
swap()

Arrays
sort()
swap()

5

304

The sort method continues comparing and swapping Ducks
until the array is in the correct order!
Chapter 8
Download at WoweBook.Com

the template method pattern

there are no

Dumb Questions

Q:

The pattern calls for implementing
an algorithm and letting subclasses supply
the implementation of the steps – and the
Arrays sort is clearly not doing that! But,
as we know, patterns in the wild aren’t
always just like the textbook patterns. They
have to be modified to fit the context and
implementation constraints.

So, while it’s not a textbook template
method, this implementation is still in the
spirit of the Template Method Pattern. Also,
by eliminating the requirement that you have
to subclass Arrays to use this algorithm,
they’ve made sorting in some ways more
flexible and useful.

using the Arrays object to sort our array, so
that’s similar to Strategy. But remember,
in Strategy, the class that you compose
with implements the entire algorithm. The
algorithm that Arrays implements for sort
is incomplete; it needs a class to fill in the
missing compareTo() method. So, in that
way, it’s more like Template Method.

Q:

Q:

The designers of the Arrays sort() method
had a few constraints. In general, you can’t
subclass a Java array and they wanted the
sort to be used on all arrays (and each array
is a different class). So they defined a static
method and deferred the comparison part of

A:

the algorithm to the items being sorted.

Is this really the Template
Method Pattern, or are you trying too
hard?

A:

This implementation of sorting
actually seems more like the Strategy
Pattern than the Template Method
Pattern. Why do we consider it
Template Method?

You’re probably thinking that
because the Strategy Pattern uses object
composition. You’re right in a way – we’re

Are there other examples of
template methods in the Java API?

A:

Yes, you’ll find them in a few
places. For example, java.io has a read()
method in InputStream that subclasses
must implement and is used by the tempate
method read(byte b[], int off, int len).

A

brain
power
We know that we should favor composition over inheritance, right? Well, the implementers of the
sort() template method decided not to use inheritance and instead to implement sort() as a static
method that is composed with a Comparable at runtime. How is this better? How is it worse? How
would you approach this problem? Do Java arrays make this particularly tricky?

A

2

brain
power
Think of another pattern that is a specialization of the template method. In this specialization, primitive
operations are used to create and return objects. What pattern is this?

you are here 4
Download at WoweBook.Com

305

the paint hook

Swingin’ with Frames
Up next on our Template Method safari... keep your eye out for swinging JFrames!
If you haven’t encountered JFrame, it’s the most basic Swing container and inherits
a paint() method. By default, paint() does nothing because it’s a hook! By overriding
paint(), you can insert yourself into JFrame’s algorithm for displaying its area of the
screen and have your own graphic output incorporated into the JFrame. Here’s
an embarrassingly simple example of using a JFrame to override the paint() hook
method:
We’re extending JFrame, which contains

public class MyFrame extends JFrame {

a method update() that controls the
algorithm for updating the screen.
We can hook into that algorithm by
overriding the paint() hook method.
Don’t look behind the
curtain! Just some
initialization here...

public MyFrame(String title) {
super(title);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
this.setSize(300,300);
this.setVisible(true);
}

By
JFrame’s update algorithm calls paint(). .
hook
a
default, paint() does nothing... it’s
We’re overriding paint(), and telling the
JFrame to draw a message in the window.

public void paint(Graphics graphics) {
super.paint(graphics);
String msg = “I rule!!”;
graphics.drawString(msg, 100, 100);
}

public static void main(String[] args) {
MyFrame myFrame = new MyFrame(“Head First Design Patterns”);
}
}

Here’s the message that gets
painted in the frame because we’ve
hooked into the paint() method.

306

Chapter 8
Download at WoweBook.Com

the template method pattern

Applets
Our ﬁnal stop on the safari: the applet.
You probably know an applet is a small program that runs in a web page. Any
applet must subclass Applet, and this class provides several hooks. Let’s take a look
at a few of them:

tever
The init hook allows the applet to do what time.
firs
the
et
appl
it wants to initialize the

public class MyApplet extends Applet {
String message;
public void init() {
message = “Hello World, I’m alive!”;
repaint();
}

let
repaint() is a concrete method in the App
know
nts
pone
com
class that lets upper-level
the applet needs to be redrawn.

The start hook allows the applet to do
something when the applet is just about
to be displayed on the web page.

public void start() {
message = “Now I’m starting up...”;
repaint();
}
public void stop() {
message = “Oh, now I’m being stopped...”;
repaint();
}
public void destroy() {
// applet is going away...
}
public void paint(Graphics g) {
g.drawString(message, 5, 15);
}
}

e, the
If the user goes to another paglet can do
app
the
stop hook is used, and
p its actions.
whatever it needs to do to sto
And the destroy hook is used when the applet
is going to be destroyed, say, when the browser
pane is closed. We could try to display
something here, but what would be the point?

Well looky here! Our old friend the
paint() method! Applet also makes
use of this method as a hook.

Concrete applets make extensive use of hooks to supply their
own behaviors. Because these methods are implemented as
hooks, the applet isn’t required to implement them.
you are here 4
Download at WoweBook.Com

307

ﬁreside chats: template method and strategy

Tonight’s talk: Template Method and Strategy
compare methods.

Template Method

Strategy

Factory Method
Hey, I heard
that!

Hey Strategy, what are you doing in my
chapter? I ﬁgured I’d get stuck with someone
boring like Factory Method.

Nope, it’s me, although be careful – you and
Factory Method are related, aren’t you?
I was just kidding! But seriously, what are you
doing here? We haven’t heard from you in eight
chapters!

You might want to remind the reader what
you’re all about, since it’s been so long.

I don’t know, since Chapter 1, people have
been stopping me in the street saying, “Aren’t
you that pattern...” So I think they know who
I am. But for your sake: I deﬁne a family of
algorithms and make them interchangeable.
Since each algorithm is encapsulated, the client
can use different algorithms easily.

Hey, that does sound a lot like what I do. But
my intent’s a little different from yours; my job
is to deﬁne the outline of an algorithm, but
let my subclasses do some of the work. That
way, I can have different implementations of an
algorithm’s individual steps, but keep control
over the algorithm’s structure. Seems like you
have to give up control of your algorithms.

308

I’d heard you were on the ﬁnal draft of your
chapter and I thought I’d swing by to see how
it was going. We have a lot in common, so I
thought I might be able to help...

I’m not sure I’d put it quite like that... and
anyway, I’m not stuck using inheritance for
algorithm implementations. I offer clients a
choice of algorithm implementation through
object composition.

Chapter 8
Download at WoweBook.Com

the template method pattern

Template Method

Strategy

I remember that. But I have more control over
my algorithm and I don’t duplicate code. In fact,
if every part of my algorithm is the same except
for, say, one line, then my classes are much more
efﬁcient than yours. All my duplicated code
gets put into the superclass, so all the subclasses
can share it.

You might be a little more efﬁcient (just a little)
and require fewer objects. And you might also
be a little less complicated in comparison to
my delegation model, but I’m more ﬂexible
because I use object composition. With me,
clients can change their algorithms at runtime
simply by using a different strategy object.
Come on, they didn’t choose me for Chapter 1
for nothing!

Yeah, well, I’m real happy for ya, but don’t
forget I’m the most used pattern around.
Why? Because I provide a fundamental
method for code reuse that allows subclasses to
specify behavior. I’m sure you can see that this
is perfect for creating frameworks.
Yeah, I guess... but, what about dependency?
You’re way more dependent than me.
How’s that? My superclass is abstract.
But you have to depend on methods
implemented in your superclass, which are part
of your algorithm. I don’t depend on anyone;
I can do the entire algorithm myself !
Like I said Strategy, I’m real happy for you.
Thanks for stopping by, but I’ve got to get the
rest of this chapter done.

Okay, okay, don’t get touchy. I’ll let you
work, but let me know if you need my special
techniques anyway, I’m always glad to help.

Got it. Don’t call us, we’ll call you...
you are here 4
Download at WoweBook.Com

309

crossword puzzle

It’s that time again....

�

�

�

�

�

�

�
�
�

�

�

�

�

�

�

�
�

�

��
��

��

��
��

��

��

��
��

��
��

��

��
��

������ ������

��������

�� ��������������
���������
������ ����
�� ���������
���������
����� �����
��� �����������
��������
���� ���������
������ ����
�� ���������
���������
��� �����������
����������������������
�� �������������
���� �������
�� ���� �� ����
����
������
�� �������
������������
�� � ���������������
�� ��
�� ����
�� ��
����
���� �� ������
�� �������
�� � ���������������
�� ��� ������
����
������
�� ��������
�� ��������
������������
�� ���
������
��������
������
���� �� ��������
�� ��������
����� �� �����
�� ��� �����
��� ���������
���� ����
�� ��
����� �� �����
�� ����������
�� ��� ���������
���� ����
�� ��� ������
���������������
����������
������� ����
��������
��� ����������
��� �������
��������
�� ��� ��������
��������
�� ��� ��
����������
��� �������
��������
������������
�� ����� ��������������
�����������
������������
�� ����� ��������������
�� ����� �� �����
�����������
�� �����
����� ���
�����
��� �����
��� �����
��������
������� �������
�� �����
�����
��� �����
��������
�� ������
�� ������ ���
�������� �����
������������
�� ���
�����
��������
��� ���
�����������
��� ���������
�� � ������
�� ��� ��������
����������
���� ����
�� ����� ����
�����
�����
��� �� ���
�� � ������
�� ��� ��������
����������
���� ����
�����������������
�� ��������
��������
�� ������
�����������������
��������� ���������
��������������
�� ��������
��������������
��������
�� ������
� �
��� � �������� ������ ������� ��� ����� �� ��
��������� ������
��� � �������� ������ ������� ��� ����� �� ��
��������� ������
������������
��� ��� ������ �������
������������
��� ��� ���
������
�������
��� �� ���� ������� �� ���� ��� ����
��� �������� ������ ���� �� �����������
��� �� ���� �������
��
����
���
����
���
���
��������
�����������
��������������
�� �����������
�������������
��� ��� ������
��� ��������
�������������
���������
��������
�����
����������
��� ��������
��� ��� �������� ������ �� ������� ����������
�� ��
� ���������
������
��� ��� ��������
�����������
�� ������� ������� �� �� ������ �� � ��������� ������
�����������
�����������
��������� ����� ��� �����
��� �����
��� ����� ���� ����� ��� �����

310

Chapter 8
Download at WoweBook.Com

the template method pattern

Tools for your Design Toolbox
We’ve added Template Method to your toolbox. With
Template Method you can reuse code like a pro while
keeping control of your algorithms.

s
OO Principle

the steps of an algorithm,
deferring to subclasses for the
implementation of those steps.
Pattern gives us an important
technique for code reuse.

Abstraction
n
Encapsulatio
.
es
ri
what va
orphism
Encapsulate
ce. Polym
an
it
er
h
in
sition over
Inheritance
Favor compo

OO Patteinresnafsinfames ilya oofneal-gotori-tmhmnas,anly

ß A “template method” defines

ß The Template Method

OO Basics

not
interfaces,
Program to ions.
implementat
led designs
loosely coup
Strive for jects that interact.
between ob
tension
open for ex
e
b
ld
ou
sh
Classes for modification.
but closed
. Do not
abstractions
Depend on ncrete classes.
depend on co
ds.
o your frien
Only talk t
u.
, we’ll call yo
Don’t call us

BULLET POINTS

ß The template method’s
abstract class may define
concrete methods, abstract
methods and hooks.

ß Abstract methods are
implemented by subclasses.

ß Hooks are methods that do
ds
ciple remin
in
r
p
t
s
e
w
s
Our ne your superclasse
you that g the show, so let n
are runnin your subclasses whe
them call eded, just like they
they’re ne wood.
do in Holly
And our newest pattern
lets classes implementing
an algorithm defer some
steps to subclasses.

def de
mitPio
oavimtfdicineaeallnya.n
sddso
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
Adntamtocak
batcjeesohcrttayhe
e
e
eits sof
ahm
d
go
F
b
o
t
al
ll
es
c
y
c
a
t
d
c
e
at
he
,
c
je
n
o
tstgatfeamiltie
t
pulenAdbe stlebrilc. itatSieotcra
encadpseD
yanrnlegeeetatosstbhin
M
o
eg
t
t
y
s
r
a
h
c
o
it
t
dsshcootun,tlybuhas est
n
e
c
ab
xsubdinibtjergueleuscpatdasactwla.beitje
ofbajece foormvifdoclreieiecnt
le
tnotnha
a
f
reenanspinge
s
e
ootnnF
r
a
eesiraen
inter
g
o
d
E
whch
in
t
r
d
r
endtoetpoif
ro
ctaelaes.ntssgloesbal peoqinuqtuest
lyafsoragpfrecle
endladeenssctinid-gepEfwronohrcviiccaladehpxesu
cnrodeenrelainadntteSeostdrin
inpdeeep
ss
c
varydeD
b
d
s
e
d
n
e
t
n
su
a
e
ss
a
r
o
e
la
c
m
t
c
c
n
eineybCginotstm
aenir co c ror-yhEeMrnecebatyphsuoledlatletinetsgs ayorue ou uest
aictifoaivysu
n
le
h
ll
r
e
n
lt
t
a
a
y qt
m
o
c
t
au spteiniost
otaitet., tt,iattEhioetnrncseawbtpyoit
yia.Ated. oabtpFje
suhletlahtdeteifsinfgae rfeenryeonutine the
n
n
t
e
a
func noaaflintatscdcaaeesnfssF
c
li
c
e
st
je
b
e
d
in
o
if
a
iz
in
r
d
n
c
r
e
t
srreewebqitytuehhlestots,d a-gndDaneedfrenotperation,
a classparamaetameentqeuorebizujepeeclaotcr,tlietloenhgteM
m
a
a
e
r
s,
T queberleuizeeoopfcreliraloeangttaiosrlgenwoqs.rituitehsthdms,ifinfs,aanndsses.
subclassreeqps.uaeasts est
nms,deoletaton le ooprerloasttgioerpness.qtueostsubcla
u
r
q
a
e
t
p
r
suppor uask
ufns,edrorqainubeguesome erattiosns.subclasses redefine
suprpeoqrutdeest
hout
oableetohpod le
suppToremt pulandte Mps of an algorithm wit e.
r
e
certain st e algorithm’s structu
changing th

nothing or default behavior in
the abstract class, but may be
overridden in the subclass.

ß To prevent subclasses from
changing the algorithm in the
template method, declare the
template method as final.

ß The Hollywood Principle guides
us to put decision-making in
high-level modules that can
decide how and when to call
low level modules.

ß You’ll see lots of uses of the
Template Method Pattern in
real world code, but don’t
expect it all (like any pattern) to
be designed “by the book.”

ß The Strategy and Template
Method Patterns both
encapsulate algorithms, one
by inheritance and one by
composition.

ß The Factory Method is a
specialization of Template
Method.
you are here 4

Download at WoweBook.Com

311

exercise solutions

Sharpen your pencil

Exercise
solutions

Draw the new class diagram now that we’ve moved
prepareRecipe() into the CaffeineBeverage class:

CaffeineBeverage
prepareRecipe()
boilWater()
pourInCup()
brew()
addCondiments()

Coffee
brew()
addCondiments()

Tea
brew()
addCondiments()

Match each pattern with its description:

312

Pattern

Description

Template Method

Encapsulate interchangable
behaviors and use delegation to
decide which behavior to use

Strategy

Subclasses decide how
to implement steps in an
algorithm

Factory Method

Subclasses decide which
concrete classes to create

Chapter 8
Download at WoweBook.Com

the template method pattern

Exercise solutions

�

�

�

�

�

� �

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
�

�

�

�
�

�

�

�

�

�

�
�

�

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

� � �

�

�

�

�

�
��

�

�

�

�

��

�

�

�

�

�

�

�

�

�

� �

�
��

��

�

�

�

�

�

�

�

�

�

�

�
��

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

�

�

�

�

�

�

�

�

�

�

������

�

�

����

�� �������� ���� ��������� ������ ����
�� ��������� ��������� ����� ���
��������������������������
���������������������������������������
�������������������������������������������
�� ������� ������ �� � ��������������� ��
�������������������������������������������
���������������������������������
�� ����� �� ����� �������
�������������������������������������������
������������������������������������
���������������������������������������
������������ �� ����� �������������� ��
�������� ����������� ����������
you are here 4 313
����� ������� �������������
�� ����� ����� ��� ����� ��� ����� ��������
�� ������ ��� ����� ����� Download at WoweBook.Com�������������
�� ����� ���� ��� ����� ���� ��� �� ����� �� ���
��������������������������������������������

Download at WoweBook.Com

9 the Iterator and Composite Patterns

g

Well-Managed h
Collections

g

You
bet I keep my
collections well
encapsulated!

There are lots of ways to stuff objects into a collection. Put them
in an Array, a Stack, a List, a Hashtable, take your pick. Each has its own advantages and
tradeoffs. But at some point your client is going to want to iterate over those objects, and
when he does, are you going to show him your implementation? We certainly hope not!
That just wouldn’t be professional. Well, you don’t have to risk your career; you’re going
to see how you can allow your clients to iterate through your objects without ever getting
a peek at how you store your objects. You’re also going to learn how to create some
super collections of objects that can leap over some impressive data structures in a single
bound. And if that’s not enough, you’re also going to learn a thing or two about object
responsibility.
this is a new chapter
Download at WoweBook.Com

315

big news

Breaking News: Object ville Diner and
Object ville Pancake House Merge
That’s great news! Now we can get those delicious pancake breakfasts at the
Pancake House and those yummy lunches at the Diner all in one place. But,
there seems to be a slight problem...

... but we can’t agree on
how to implement our menus.
That joker over there used an
ArrayList to hold his menu items, and
I used an Array. Neither one of us is
willing to change our implementations...
we just have too much code written
that depends on them.

They want to use
my Pancake House
menu as the breakfast menu
and the Diner’s menu as the
lunch menu. We’ve agreed on
an implementation for the
menu items...

Lou

316

Mel

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Check out the Menu Items
At least Lou and Mel agree on the
implementation of the MenuItems.
Let’s check out the items on each
menu, and also take a look at the
implementation.

Objectville Diner

Vegetarian BL
T
(Fakin’) Bacon
with lettuce &
2.99
tomato on
whole wheat
BLT
Bacon with let
tuce & tomato
2.99
Soup of the da
on whole whe
at
y
A bowl of the
soup of the daK&B’
s Pancake Br 3.29
y, with
a side of pota
ea
to salad
Pancakes with kfast
Hot Dog
2.99
scrambled eg
gs, and toast
A hot dog, with
3.
05
saurkraut, re
Re
lisgu
h, la
topped with ch
onrioPa
nsnc
, ake Breakfast
Pancakes with
Steamed Vegg eese
2.99
fried eggs, saus
ies and Brow
age
n
Rice
A medley of ste
3.99
amed vegeta
Blbl
ue
esbe
ovrrery br
Paow
ncnakes
Pancakes mad rice
3.49
e with fresh bl
ueberries,
and blueberry
syrup

Objectville Pancake H
ouse

lunch items,
The Diner menu has lots of consists of
while the Pancake House m has a
nu ite
breakfast items. Every me , and a price
ion
ipt
scr
de
name, a

Wafﬂes
Wafﬂes, with
your
or strawberries choice of blueberries

public class MenuItem {
String name;
String description;
boolean vegetarian;
double price;
public MenuItem(String name,
String description,
boolean vegetarian,
double price)
{
this.name = name;
this.description = description;
this.vegetarian = vegetarian;
this.price = price;
}
public String getName() {
return name;
}
public String getDescription() {
return description;
}

3.59

A MenuItem consists
a flag to indicate if of a name, a description,
and a price. You pa the item is vegetarian,
constructor to initialss all these values into the
ize the MenuItem.

These getter methods
let you access the fields
of the menu item.

public double getPrice() {
return price;
}
public boolean isVegetarian() {
return vegetarian;
}
}
you are here 4
Download at WoweBook.Com

317

two menus

Lou and Mel’s Menu implementations
I used an ArrayList
so I can easily
expand my menu.

Now let’s take a look at what Lou and Mel are
arguing about. They both have lots of time and
code invested in the way they store their menu
items in a menu, and lots of other code that
depends on it.

the
Here’s Lou’s implementation of
u.
Pancake House men

public class PancakeHouseMenu {implements Menu {
ArrayList menuItems;
public PancakeHouseMenu() {
menuItems = new ArrayList();

Lou’s using an ArrayList to store
his menu items

addItem(“K&B’s Pancake Breakfast”,
“Pancakes with scrambled eggs, and toast”,
true,
2.99);
addItem(“Regular Pancake Breakfast”,
“Pancakes with fried eggs, sausage”,
false,
2.99);

Each menu item is added to the
ArrayList here, in the constructor
a
Each MenuItem has a name, it’s a
not
description, whether or ce
vegetarian item, and the pri

addItem(“Blueberry Pancakes”,
“Pancakes made with fresh blueberries”,
true,
3.49);
addItem(“Wafﬂes”,
“Wafﬂes, with your choice of blueberries or strawberries”,
true,
3.59);

ew

u creates a n

,
em, Lo
}
dd a menu it passing in each argument
a
o
T
public void addItem(String name, String description,
,
t
c
je
b
o
t
MenuItem s it to the ArrayLis
boolean vegetarian, double price)
and then add
{
MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
menuItems.add(menuItem);
}
public ArrayList getMenuItems() {
return menuItems;
}
// other menu methods here
}

318

The getMenuItems() method returns the list of

e that depends
Lou has a bunch of other menu cod He doesn’t want
on the ArrayList implementation.
to have to rewrite all that code!

Chapter 9
Download at WoweBook.Com

menu items

the iterator and composite patterns
Haah! An Arraylist... I
used a REAL Array so I can
control the maximum size of my menu
and get my MenuItems without
having to use a cast.

implementation
And here’s Mel’s
public class DinerMenu {implements Menu {
static ﬁnal int MAX_ITEMS = 6;
int numberOfItems = 0;
MenuItem[] menuItems;

u.

of the Diner men

g an Array so he
Mel takes a different approach; he’s usin
and retrieve menu
can control the max size of the menu cts.
items out without having to cast his obje

public DinerMenu() {
menuItems = new MenuItem[MAX_ITEMS];

Like Lou, Mel creates his menu items in the
constructor, using the addItem() helper method.

addItem(“Vegetarian BLT”,
“(Fakin’) Bacon with lettuce & tomato on whole wheat”, true, 2.99);
addItem(“BLT”,
“Bacon with lettuce & tomato on whole wheat”, false, 2.99);
addItem(“Soup of the day”,
“Soup of the day, with a side of potato salad”, false, 3.29);
addItem(“Hotdog”,
“A hot dog, with saurkraut, relish, onions, topped with cheese”,
false, 3.05);
// a couple of other Diner Menu items added here

addItem() takes all the parameters
necessary to create a MenuItem and e
instantiates one. It also checks to mak
t.
sure we haven’t hit the menu size limi

}

public void addItem(String name, String description,
boolean vegetarian, double price)
{
MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
if (numberOfItems >= MAX_ITEMS) {
System.err.println(“Sorry, menu is full! Can’t add item to menu”);
} else {
Mel specifically wants to keep his menu under a
menuItems[numberOfItems] = menuItem;
numberOfItems = numberOfItems + 1;
certain size (presumably so he doesn’t have to
}
remember too many recipes).
}
public MenuItem[] getMenuItems() {
return menuItems;
}
// other menu methods here
}

getMenuItems() returns the array of menu items.

Like Lou, Mel has a bunch of code that depends on the implementation of
his menu being an Array. He’s too busy cooking to rewrite all of this.
you are here 4

Download at WoweBook.Com

319

java enabled waitress

What’s the problem with having t wo different
menu representations?
ress is
The WaitJava-enabled.
getting

To see why having two different menu representations complicates
things, let’s try implementing a client that uses the two menus.
Imagine you have been hired by the new company formed by the
merger of the Diner and the Pancake House to create a Java-enabled
waitress (this is Objectville, after all). The spec for the Java-enabled
waitress speciﬁes that she can print a custom menu for customers on
demand, and even tell you if a menu item is vegetarian without having
to ask the cook – now that’s an innovation!
Let’s check out the spec, and then step through what it might take to
implement her...

The Java-Enabled Waitress Specification
”
-name “Alice
itress: code
Wa
ed
bl
na
-E
Java
e menu
printMenu()
y item on th
- prints ever
stMenu()
printBreakfa
t items
just breakfas
ts
in
- pr
nu()
printLunchMe
ems
just lunch it
ts
in
- pr
ianMenu()
nu items
printVegetar
vegetarian me
- prints all
rian(name)
returns true
isItemVegeta
of an item,
me
na
e
th
n
, otherwise,
- give
is vegetarian
if the items
e
returns fals

320

Chapter 9
Download at WoweBook.Com

The spec for
the Waitress

the iterator and composite patterns

Let’s start by stepping through how we’d implement the printMenu() method:

1

To print all the items on each menu, you’ll need to call the getMenuItem()
method on the PancakeHouseMenu and the DinerMenu to retrieve their
respective menu items. Note that each returns a different type:

The method looks
the same, but the
calls are returning
different types.

PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
ArrayList breakfastItems = pancakeHouseMenu.getMenuItems();
DinerMenu dinerMenu = new DinerMenu();
MenuItem[] lunchItems = dinerMenu.getMenuItems();

2

The implementation
is showing through,
breakfast items are
in an ArrayList, lunch
items are in an Array.

Now, to print out the items from the PancakeHouseMenu, we’ll loop through the
items on the breakfastItems ArrayList. And to print out the Diner items we’ll
loop through the Array.
for (int i = 0; i < breakfastItems.size(); i++) {
MenuItem menuItem = (MenuItem)breakfastItems.get(i);
System.out.print(menuItem.getName() + “ “);
System.out.println(menuItem.getPrice() + “ “);
System.out.println(menuItem.getDescription());
}
for (int i = 0; i < lunchItems.length; i++) {
MenuItem menuItem = lunchItems[i];
System.out.print(menuItem.getName() + “ “);
System.out.println(menuItem.getPrice() + “ “);
System.out.println(menuItem.getDescription());
}

3

Now, we have to
implement two different
loops to step through
the two implementations
of the menu items...
...one loop for the
ArrayList...
and another for
the Array.

Implementing every other method in the Waitress is going to be a variation of
this theme. We’re always going to need to get both menus and use two loops to
iterate through their items. If another restaurant with a different implementation
is acquired then we’ll have three loops.

you are here 4
Download at WoweBook.Com

321

what’s the goal

Sharpen your pencil
Based on our implementation of printMenu(), which of the following apply?

❏ D. The Waitress needs to know how each

❏ A. We are coding to the
PancakeHouseMenu and DinerMenu
concrete implementations, not to an
interface.

❏ B. The Waitress doesn’t implement the
Java Waitress API and so she isn’t
adhering to a standard.

❏ C. If we decided to switch from using
DinerMenu to another type of menu
that implemented its list of menu items
with a Hashtable, we’d have to modify
a lot of code in the Waitress.

menu represents its internal collection of
menu items; this violates encapsulation.

❏ E. We have duplicate code: the printMenu()
method needs two separate loops to
iterate over the two different kinds of
menus. And if we added a third menu,
we’d have yet another loop.

❏ F. The implementation isn’t based on
MXML (Menu XML) and so isn’t as
interoperable as it should be.

What now?
Mel and Lou are putting us in a difﬁcult position. They don’t want to change their
implementations because it would mean rewriting a lot of code that is in each respective menu
class. But if one of them doesn’t give in, then we’re going to have the job of implementing a
Waitress that is going to be hard to maintain and extend.
It would really be nice if we could ﬁnd a way to allow them to implement the same interface for
their menus (they’re already close, except for the return type of the getMenuItems() method).
That way we can minimize the concrete references in the Waitress code and also hopefully get
rid of the multiple loops required to iterate over both menus.
Sound good? Well, how are we going to do that?

322

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Can we encapsulate the iteration?
If we’ve learned one thing in this book, it’s encapsulate what varies. It’s obvious
what is changing here: the iteration caused by different collections of objects
being returned from the menus. But can we encapsulate this? Let’s work
through the idea...
1

To iterate through the breakfast items we use the size() and get()
methods on the ArrayList:

for (int i = 0; i < breakfastItems.size(); i++) {
MenuItem menuItem = (MenuItem)breakfastItems.get(i);
}
get(2)

get(1)
get(0)

get() helps us step
through each item.

get(3)

ArrayList

2

Me
nuItem

Me
nuItem

1

2

Me
nuItem

3

Men

uItem

4

An ArrayList
of MenuItems

And to iterate through the lunch items we use the Array length ﬁeld and
the array subscript notation on the MenuItem Array.

Array

lunchItems[0]

for (int i = 0; i < lunchItems.length; i++) {
MenuItem menuItem = lunchItems[i];
}

1

lunchIte
lunch

lunc

We use the array
subscripts to step
through items.

ms[1]

I te m s

h I te

[2]

ms[3

Me
nuItem

2
Me
nuItem

3
Me
nuItem

]
4

Men

uItem

An Array of
MenuItems.
you are here 4

Download at WoweBook.Com

323

encapsulating iteration

Now what if we create an object, let’s call it an Iterator,
that encapsulates the way we iterate through a
collection of objects? Let’s try this on the ArrayList

3

We ask the breakfastMenu
for an iterator of its
Iterator iterator = breakfastMenu.createIterator();MenuItems.
And while there are more items left...
while (iterator.hasNext()) {
MenuItem menuItem = (MenuItem)iterator.next();
}
next()
We get the next item.

get(2)

get(3)

r

Iterato

The client just calls hasNext() and
next(); behind the scenes the iterator
calls get() on the ArrayList.

get(1)

ArrayList

get(0)

Me
nuItem

Me
nuItem

1

2

Me
nuItem

Men

3

uItem

4

Let’s try that on the Array too:

4

Iterator iterator = lunchMenu.createIterator();
while (iterator.hasNext()) {
MenuItem menuItem = (MenuItem)iterator.next();
}
Wow, this code
is exactly the
same as the
breakfastMenu
code.

lunchItems[0]
1

lunchIte
Iterato

r

Same situation here: the client just calls
hasNext() and next(); behind the scenes,
the iterator indexes into the Array.

Array

next()

lunch

lunc

ms[1]

I te m s

h I te

[2]

ms[3

Me
nuItem

2
Me
nuItem

3
Me
nuItem

]
4

Men

324

Chapter 9
Download at WoweBook.Com

uItem

the iterator and composite patterns

Meet the Iterator Pattern
Well, it looks like our plan of encapsulating iteration just might
actually work; and as you’ve probably already guessed, it is a
Design Pattern called the Iterator Pattern.
The ﬁrst thing you need to know about the Iterator Pattern is
that it relies on an interface called Iterator. Here’s one possible
Iterator interface:

<<interface>>
Iterator
hasNext()

The hasNext() method
tells us if there are
more elements in the
aggregate to iterate
through.

next()

The next() method
returns the next
object in the aggregate.
Now, once we have this interface, we can implement Iterators for
any kind of collection of objects: arrays, lists, hashtables, ...pick
your favorite collection of objects. Let’s say we wanted to
implement the Iterator for the Array used in the DinerMenu. It
would look like this:

<<interface>>
Iterator
hasNext()
next()

DinerMenuIterator
hasNext()
next()

When we say
COLLECTION we just
mean a group of objects. They
might be stored in very different
data structures like lists, arrays,
hashtables, but they’re
still collections. We also
sometimes call these
AGGREGATES.

DinerMenuIterator is an
implementation of Iterator
that knows how to iterate
over an array of MenuItems.

Let’s go ahead and implement this Iterator and hook it into the
DinerMenu to see how this works...

you are here 4
Download at WoweBook.Com

325

make an iterator

Adding an Iterator to DinerMenu
To add an Iterator to the DinerMenu we ﬁrst need to deﬁne the
Iterator Interface:

public interface Iterator {
boolean hasNext();
Object next();
}

Here’s our two methods:
boolean
The hasNext() method returns a are more
re
the
not
or
indicating whether
elements to iterate over...
...and the next() meth
returns the next ele od
ment.

And now we need to implement a concrete Iterator that works
for the Diner menu:

We implement the
Iterator interface.

public class DinerMenuIterator implements Iterator {
MenuItem[] items;
int position = 0;
public DinerMenuIterator(MenuItem[] items) {
this.items = items;
}
public Object next() {
MenuItem menuItem = items[position];
position = position + 1;
return menuItem;
}

ns the
position maintai of the
current position e array.
iteration over th

The constructor takes the
array of menu items we are
going to iterate over.
The next() method returns the
next item in the array and
increments the position.

public boolean hasNext() {
if (position >= items.length || items[position] == null) {
return false;
} else {
return true;
}
}

The hasNext() method checks to
see if we’ve seen all the elements
of the array and returns true if
there are more to iterate through.

}

326

Chapter 9
Download at WoweBook.Com

Because the diner chef went ahead and
allocated a max sized array, we need to
check not only if we are at the end of
the array, but also if the next item is
null, which indicates there are no more
items.

the iterator and composite patterns

Reworking the Diner Menu with Iterator
Okay, we’ve got the iterator. Time to work it into the
DinerMenu; all we need to do is add one method to create a
DinerMenuIterator and return it to the client:

public class DinerMenu {implements Menu {
static ﬁnal int MAX_ITEMS = 6;
int numberOfItems = 0;
MenuItem[] menuItems;
// constructor here
// addItem here
public MenuItem[] getMenuItems() {
return menuItems;
}

We’re not going to need the getMenuItems()
method anymore and in fact, we don’t want it
because it exposes our internal implementation!

public Iterator createIterator() {
return new DinerMenuIterator(menuItems);
}
// other menu methods here
}

Here’s the createIterator() method.
It creates a DinerMenuIterator
from the menuItems array and
returns it to the client.

We’re returning the Iterator interface. The client
doesn’t need to know how the menuItems are maintained
in the DinerMenu, nor does it need to know how the
DinerMenuIterator is implemented. It just needs to use the
iterators to step through the items in the menu.

Exercise
Go ahead and implement the PancakeHouseIterator yourself and make the changes
needed to incorporate it into the PancakeHouseMenu.

you are here 4
Download at WoweBook.Com

327

the waitress iterates

Fixing up the Waitress code
Now we need to integrate the iterator code
into the Waitress. We should be able to get
rid of some of the redundancy in the process.
Integration is pretty straightforward: ﬁrst we
create a printMenu() method that takes an
Iterator, then we use the createIterator() method
on each menu to retrieve the Iterator and pass it
to the new method.

public class Waitress {
PancakeHouseMenu pancakeHouseMenu;
DinerMenu dinerMenu;

New and improved
with Iterator.

In the constructor the Waitress
takes the two menus.

public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {
this.pancakeHouseMenu = pancakeHouseMenu;
The printMenu()
this.dinerMenu = dinerMenu;
method now
}

creates two

public void printMenu() {
iterators, one for
Iterator pancakeIterator = pancakeHouseMenu.createIterator(); each menu.
Iterator dinerIterator = dinerMenu.createIterator();
System.out.println(“MENU\n----\nBREAKFAST”);
And then calls the
printMenu(pancakeIterator);
overloaded printMenu()
System.out.println(“\nLUNCH”);
printMenu(dinerIterator);
with each iterator.
}

Test if there are

private void printMenu(Iterator iterator) {
any more items.
while (iterator.hasNext()) {
MenuItem menuItem = (MenuItem)iterator.next();
System.out.print(menuItem.getName() + “, “);
System.out.print(menuItem.getPrice() + “ -- “);
System.out.println(menuItem.getDescription());
}
}
// other methods here
}

328

Note that we’re down
to one loop.

Chapter 9
Download at WoweBook.Com

Get the
next item.

Use the item to
get name, price
and description
and print them.

The overloaded
printMenu()
method uses
the Iterator to
step through the
menu items and
print them.

the iterator and composite patterns

Testing our code
It’s time to put everything to a test. Let’s write some
test drive code and see how the Waitress works...

First we create the new menus.
public class MenuTestDrive {
public static void main(String args[]) {
PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
DinerMenu dinerMenu = new DinerMenu();
Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu);
waitress.printMenu();
}
}

Then we create a
Waitress and pass
her the menus.

Then we print them.

Here’s the test run...
File Edit Window Help GreenEggs&Ham

% java DinerMenuTestDrive

First we iterate

MENU
through the pancake
---menu.
BREAKFAST
And then
K&B’s Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs, and toast
the lunch
Regular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage
menu, all
Blueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries
the
with
Wafﬂes, 3.59 -- Wafﬂes, with your choice of blueberries or strawberries

same

LUNCH
iteration
Vegetarian BLT, 2.99 -- (Fakin’) Bacon with lettuce & tomato on whole wheat code.
BLT, 2.99 -- Bacon with lettuce & tomato on whole wheat
Soup of the day, 3.29 -- Soup of the day, with a side of potato salad
Hotdog, 3.05 -- A hot dog, with saurkraut, relish, onions, topped with cheese
Steamed Veggies and Brown Rice, 3.99 -- Steamed vegetables over brown rice
Pasta, 3.89 -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
%

you are here 4
Download at WoweBook.Com

329

iterator advantages

What have we done so far?
For starters, we’ve made our Objectville cooks
very happy. They settled their differences and
kept their own implementations. Once we
gave them a PancakeHouseMenuIterator and a
DinerMenuIterator, all they had to do was add a
createIterator() method and they were ﬁnished.

Woohoo! No
code changes other
than adding the
createIterator() method.

We’ve also helped ourselves in the process. The
Waitress will be much easier to maintain and
extend down the road. Let’s go through exactly
what we did and think about the consequences:

Veggie burger

Hard to Maintain
Waitress Implementation

330

New, Hip
Waitress Powered by Iterator

The Menus are not well
encapsulated; we can see the Diner
is using an Array and the Pancake
House an ArrayList.

The Menu implementations are now
encapsulated. The Waitress has
no idea how the Menus hold their
collection of menu items.

We need two loops to iterate through
the MenuItems.

All we need is a loop that
polymorphically handles any
collection of items as long as it
implements Iterator.

The Waitress is bound to concrete
classes (MenuItem[] and ArrayList).

The Waitress now uses an interface
(Iterator).

The Waitress is bound to two different
concrete Menu classes, despite their
interfaces being almost identical.

The Menu interfaces are now exactly
the same and, uh oh, we still don’t
have a common interface, which
means the Waitress is still bound to
two concrete Menu classes. We’d
better ﬁx that.

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

What we have so far...
Before we clean things up, let’s get a bird’s eye view of our current design.

ment the
These two menus implethods, but
same exact set of me the same
they aren’t implementingto fix this
Interface. We’re going from any
and free the Waitress te Menus.
dependencies on concre

PancakeHouseMenu
menuItems

We’re now
using a common
Iterator
interface
and we’ve
implemented
two concrete
classes.

The Iterator allows the Waitress to be decoupled
from the actual implementation of the concrete
classes. She doesn’t need to know if a Menu is
implemented with an Array, an ArrayList, or with
PostIt™ notes. All she cares is that she can get an
Iterator to do her iterating.

<<interface>>
Iterator

Waitress
printMenu()

hasNext()

createIterator()

next()

DinerMenu
menuItems
createIterator()

PancakeHouseMenuIterator

DinerMenuIterator

hasNext()

hasNext()

next()

next()

Note that the iterator give us a way to step
through the elements of an aggregate with
out
forcing the aggregate to clutter its own inte
with a bunch of methods to support traversa rface
elements. It also allows the implementation l of its
iterator to live outside of the aggregate; of the
words, we’ve encapsulated the interation. in other

ement
and DinerMenu impl are
u
en
M
se
ou
eH
ak
nc
Pa
ator() method; they
the new createIter ting the iterator for their
responsible for crea s implementations.
respective menu item

you are here 4
Download at WoweBook.Com

331

improve the iterator

Making some improvements...
Okay, we know the interfaces of PancakeHouseMenu and DinerMenu are exactly the same
and yet we haven’t deﬁned a common interface for them. So, we’re going to do that and
clean up the Waitress a little more.
You may be wondering why we’re not using the Java Iterator interface – we did that so you
could see how to build an iterator from scratch. Now that we’ve done that, we’re going to
switch to using the Java Iterator interface, because we’ll get a lot of leverage by implementing
that instead of our home grown Iterator interface. What kind of leverage? You’ll soon see.
First, let’s check out the java.util.Iterator interface:

This looks just like our previous definition.

<<interface>>
Iterator
hasNext()
next()

Except we have an additional method that
allows us to remove the last item returned by
the next() method from the aggregate.

remove()

This is going to be a piece of cake: We just need to change the interface that both
PancakeHouseMenuIterator and DinerMenuIterator extend, right? Almost... actually, it’s
even easier than that. Not only does java.util have its own Iterator interface, but ArrayList has
an iterator() method that returns an iterator. In other words, we never needed to implement
our own iterator for ArrayList. However, we’ll still need our implementation for the
DinerMenu because it relies on an Array, which doesn’t support the iterator() method (or any
other way to create an array iterator).

there are no

Dumb Questions

Q:

What if I don’t want to provide
the ability to remove something from the
underlying collection of objects?

A:

The remove() method is considered
optional. You don’t have to provide remove
functionality. But, obviously you do need to
provide the method because it’s part of the
Iterator interface. If you’re not going to allow
remove() in your iterator you’llwant to throw

332

Q:

How does remove() behave
under multiple threads that may be
using different iterators over the same
collection of objects?

the runtime exception
java.lang.UnsupportedOperationException.
The Iterator API documentation specifies that
this exception may be thrown from remove()
and any client that is a good citizen will
check for this exception when calling the
remove() method.

Chapter 9
Download at WoweBook.Com

A:

The behavior of the remove() is
unspecified if the collection changes while
you are iterating over it. So you should be
careful in designing your own multithreaded
code when accessing a collection
concurrently.

the iterator and composite patterns

Cleaning things up with java.util.Iterator
Let’s start with the PancakeHouseMenu, changing it over to java.util.Iterator is
going to be easy. We just delete the PancakeHouseMenuIterator class, add an
import java.util.Iterator to the top of PancakeHouseMenu and change one line
of the PancakeHouseMenu:

Instead of creating our own iterator
now, we just call the iterator() method
on the menuItems ArrayList.

public Iterator createIterator() {
return menuItems.iterator();
}

And that’s it, PancakeHouseMenu is done.
Now we need to make the changes to allow the DinerMenu to work with java.util.Iterator.

import java.util.Iterator;
public class DinerMenuIterator implements Iterator {
MenuItem[] list;
int position = 0;
public DinerMenuIterator(MenuItem[] list) {
this.list = list;
}
public Object next() {
//implementation here
}
public boolean hasNext() {
//implementation here
}

First we import java.util.Iterator, the
interface we’re going to implement.

None of our current
implementation changes...
...but we do need to implement remove().
Here, because the chef is using a fixed
sized Array, we just shift all the
elements up one when remove() is called.

public void remove() {
if (position <= 0) {
throw new IllegalStateException
(“You can’t remove an item until you’ve done at least one next()”);
}
if (list[position-1] != null) {
for (int i = position-1; i < (list.length-1); i++) {
list[i] = list[i+1];
}
list[list.length-1] = null;
}
}
}
you are here 4
Download at WoweBook.Com

333

decouple the waitress from the menus

We are almost there...
We just need to give the Menus a common interface and rework the Waitress
a little. The Menu interface is quite simple: we might want to add a few more
methods to it eventually, like addItem(), but for now we will let the chefs control
their menus by keeping that method out of the public interface:

This is a simple interface that just
lets clients get an iterator for
the items in the menu.

public interface Menu {
public Iterator createIterator();
}

Now we need to add an implements Menu to both the
PancakeHouseMenu and the DinerMenu class deﬁnitions and
update the Waitress:
import java.util.Iterator;

Now the Waitress uses the java.util.Iterator as well.

public class Waitress {
Menu pancakeHouseMenu;
Menu dinerMenu;
public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {
this.pancakeHouseMenu = pancakeHouseMenu;
this.dinerMenu = dinerMenu;
}

We need to replace the
concrete Menu classes
with the Menu Interface.

public void printMenu() {
Iterator pancakeIterator = pancakeHouseMenu.createIterator();
Iterator dinerIterator = dinerMenu.createIterator();
System.out.println(“MENU\n----\nBREAKFAST”);
printMenu(pancakeIterator);
System.out.println(“\nLUNCH”);
printMenu(dinerIterator);
}
private void printMenu(Iterator iterator) {
while (iterator.hasNext()) {
MenuItem menuItem = (MenuItem)iterator.next();
System.out.print(menuItem.getName() + “, “);
System.out.print(menuItem.getPrice() + “ -- “);
System.out.println(menuItem.getDescription());
}
}
// other methods here
}

334

Chapter 9
Download at WoweBook.Com

Nothing changes
here.

the iterator and composite patterns

What does this get us?
of
This solves the problem on
ing
the Waitress depend
the concrete Menus.

The PancakeHouseMenu and DinerMenu classes implement an interface,
Menu. Waitress can refer to each menu object using the interface rather than
the concrete class. So, we’re reducing the dependency between the Waitress and
the concrete classes by “programming to an interface, not an implementation.”
The new Menu interface has one method, createIterator(), that is implemented
by PancakeHouseMenu and DinerMenu. Each menu class assumes the
responsibility of creating a concrete Iterator that is appropriate for its internal
implementation of the menu items.

aitress from the
We’ve decoupled W the menus, so now
implementation of ator to iterate
we can use an Itermenu items without
over any list of out how the list
having to know ab ented.
of items is implem

Now, Waitress
only needs to
be concerned
with Menus and
Iterators.

Here’s our new Menu interface.
It specifies the new method,
createIterator().
<<interface>>
Menu

This solves the problem of
the Waitress depending on
the implementation of the
MenuItems.

<<interface>>
Iterator

Waitress
printMenu()

hasNext()

createIterator()
createIterator()

next()
remove()

PancakeHouseMenu

DinerMenu

menuItems

menuItems

createIterator()

createIterator()

PancakeHouseMenu and DinerMenu now
the Menu interface, which means the implement
y need to
implement the new createIterator() met
hod.

DinerMenuIterator

PancakeHouseMenuIterator
hasNext()

hasNext()

next()

next()

remove()

remove()

We’re now using the ArrayList
iterator supplied by java.util.
We don’t need this anymore.

Each concrete Menu is responsible
for creating the appropriate
concrete Iterator class.

DinerMenu returns an
DinerMenuIterator
from its
createIterator()
method because that’s
the kind of iterator
required to iterate
over its Array of
menu items.

you are here 4
Download at WoweBook.Com

335

iterator pattern deﬁned

Iterator Pattern defined
You’ve already seen how to implement the Iterator
Pattern with your very own iterator. You’ve also seen
how Java supports iterators in some of its collection
oriented classes (the ArrayList). Now it’s time to check
out the ofﬁcial deﬁnition of the pattern:

The Iterator Pattern provides a way to
access the elements of an aggregate object
sequentially without exposing its underlying
representation.

This makes a lot of sense: the pattern gives you a way
to step through the elements of an aggregate without
having to know how things are represented under the
covers. You’ve seen that with the two implementations
of Menus. But the effect of using iterators in your
design is just as important: once you have a uniform way
of accessing the elements of all your aggregate objects,
you can write polymorphic code that works with any
of these aggregates – just like the printMenu() method,
which doesn’t care if the menu items are held in an
Array or ArrayList (or anything else that can create an
Iterator), as long as it can get hold of an Iterator.
The other important impact on your design is that the
Iterator Pattern takes the responsibility of traversing
elements and gives that responsibility to the iterator
object, not the aggregate object. This not only keeps
the aggregate interface and implementation simpler,
it removes the responsibility for iteration from the
aggregate and keeps the aggregate focused on the
things it should be focused on (managing a collection of
objects), not on iteration.

The Iterator Pattern allows
traversal of the elements
of an aggregate without
exposing the underlying
implementation.
It also places the task of
traversal on the iterator
object, not on the aggregate,
which simplifies the
aggregate interface and
implementation, and places
the responsibility where it
should be.

Let’s check out the class diagram to put all the pieces in
context...

336

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Having a common interface for your
aggregates is handy for your client;
it decouples your client from the
implementation of your collection of objects.
<<interface>>
Aggregate

<<interface>>
Iterator

Client

createIterator()

hasNext()
next()
remove()

The Iterator interface
provides the interface
that all iterators
must implement, and
a set of methods
for traversing over
elements of a collection.
Here we’re using the
java.util.Iterator. If you
don’t want to use Java’s
Iterator interface, you
can always create your
own.

ConcreteIterator

ConcreteAggregate

hasNext()

createIterator()

next()

The ConcreteAggregate
has a collection of
objects and implements
the method that
returns an Iterator
for its collection.

Each ConcreteAggregate
is responsible for
instantiating a
ConcreteIterator that
can iterate over its
collection of objects.

remove()

The ConcreteIterator is
responsible for managing
the current position of
the iteration.

A

brain
power
The class diagram for the Iterator Pattern looks very similar to another Pattern you’ve studied; can you
think of what it is? Hint: A subclass decides which object to create.

you are here 4
Download at WoweBook.Com

337

q&a about iterator

there are no

Dumb Questions

Q:

I’ve seen other books show the
Iterator class diagram with the methods
first(), next(), isDone() and currentItem().
Why are these methods different?

A:

Those are the “classic” method
names that have been used. These names
have changed over time and we now have
next(), hasNext() and even remove() in
java.util.Iterator.
Let’s look at the classic methods. The
next() and currentItem() have been merged
into one method in java.util. The isDone()
method has obviously become hasNext();
but we have no method corresponding to
first(). That’s because in Java we tend to
just get a new iterator whenever we need to
start the traversal over. Nevertheless, you
can see there is very little difference in these
interfaces. In fact, there is a whole range
of behaviors you can give your iterators.
The remove() method is an example of an
extension in java.util.Iterator.

Q:

I’ve heard about “internal”
iterators and “external” iterators. What
are they? Which kind did we implement
in the example?

A:

We implemented an external iterator,
which means that the client controls the
iteration by calling next() to get the next
element. An internal iterator is controlled
by the iterator itself. In that case, because
it’s the iterator that’s stepping through the
elements, you have to tell the iterator what
to do with those elements as it goes through
them. That means you need a way to pass
an operation to an iterator. Internal iterators
are less flexible that external iterators
because the client doesn’t have control of
the iteration. However, some might argue

338

that they are easier to use because you just
hand them an operation and tell them to
iterate, and they do all the work for you.

Q:

Could I implement an Iterator that
can go backwards as well as forwards?

A:

Definitely. In that case, you’d
probably want to add two methods, one to
get to the previous element, and one to tell
you when you’re at the beginning of the
collection of elements. Java’s Collection
Framework provides another type of iterator
interface called ListIterator. This iterator
adds previous() and a few other methods
to the standard Iterator interface. It is
supported by any Collection that implements
the List interface.

collection as long as it supports Iterator.
We don’t care about how the collection
is implemented, we can still write code to
iterate over it.

Q:

If I’m using Java, won’t I always
want to use the java.util.Iterator
interface so I can use my own iterator
implementations with classes that are
already using the Java iterators?

A:

Probably. If you have a common
Iterator interface, it will certainly make it
easier for you to mix and match your own
aggregates with Java aggregates like
ArrayList and Vector. But remember, if you
need to add functionality to your Iterator
interface for your aggregates, you can
always extend the Iterator interface.

Q:

Q:

A:

A:

Who defines the ordering of the
iteration in a collection like Hashtable,
which are inherently unordered?
Iterators imply no ordering. The
underlying collections may be unordered as
in a hashtable or in a bag; they may even
contain duplicates. So ordering is related
to both the properties of the underlying
collection and to the implementation. In
general, you should make no assumptions
about ordering unless the Collection
documentation indicates otherwise.

Q:

You said we can write
“polymorphic code” using an iterator;
can you explain that more?

A:

When we write methods that take
Iterators as parameters, we are using
polymorphic iteration. That means we are
creating code that can iterate over any

Chapter 9
Download at WoweBook.Com

I’ve seen an Enumeration
interface in Java; does that implement
the Iterator Pattern?
We talked about this in the Adapter
Chapter. Remember? The java.util.
Enumeration is an older implementation
of Iterator that has since been replaced
by java.util.Iterator. Enumeration has
two methods, hasMoreElements(),
corresponding to hasNext(), and
nextElement(), corresponding to next().
However, you’ll probably want to use Iterator
over Enumeration as more Java classes
support it. If you need to convert from one
to another, review the Adapter Chapter
again where you implemented the adapter
for Enumeration and Iterator.

the iterator and composite patterns

Single Responsibility
What if we allowed our aggregates to
implement their internal collections and
related operations AND the iteration
methods? Well, we already know that
would expand the number of methods in
the aggregate, but so what? Why is that
so bad?
Well, to see why, you ﬁrst need to recognize that when we allow
a class to not only take care of its own business (managing
some kind of aggregate) but also take on more responsibilities
(like iteration) then we’ve given the class two reasons to change.
Two? Yup, two: it can change if the collection changes in
some way, and it can change if the way we iterate changes. So
once again our friend CHANGE is at the center of another
design principle:

Every responsibility of a
class is an area of potential
change. More than one
responsibility means more
than one area of change.
This principle guides us to
keep each class to a single
responsibility.

Design Principle
A class should have only one
reason to change.

Cohesion is a term you’ll

st
Head Fir

We know we want to avoid change in a class like the plague
– modifying code provides all sorts of opportunities for
problems to creep in. Having two ways to change increases
the probability the class will change in the future, and when
it does, it’s going to affect two aspects of your design.
The solution? The principle guides us to assign each
responsibility to one class, and only one class.
That’s right, it’s as easy as that, and then again it’s not:
separating responsibility in design is one of the most
difﬁcult things to do. Our brains are just too good at seeing
a set of behaviors and grouping them together even when
there are actually two or more responsibilities. The only
way to succeed is to be diligent in examining your designs
and to watch out for signals that a class is changing in more
than one way as your system grows.

OO Glue

hear used as a measure of
how closely a class or a
module supports a single
purpose or responsibility.

We say that a module or
class has high cohesion
when it is designed around a set of
related functions, and we say it has low
cohesion when it is designed around a
set of unrelated functions.
Cohesion is a more general concept
than the Single Responsibility Principle,
but the two are closely related.
Classes that adhere to the principle
tend to have high cohesion and are
more maintainable than classes that
take on multiple responsibilities and
have low cohesion.

you are here 4
Download at WoweBook.Com

339

multiple responsibilities

A

brain
power
Examine these classes and determine which ones have multiple responsibilities.
GumballMachine

Person

getCount()

setName()

Game

Phone

setAddress()

login()

setPhoneNumber()

signup()

talk()

load()

fire()

getLocation()

hangUp()

save()

move()

getState()

dial()

sendData()

rest()

flash()

Iterator
DeckOfCards

hasNext()

ShoppingCart

hasNext()
next()

add()

remove()

remove()

addCard()

checkOut()

removeCard()

saveForLater()

next()
remove()

shuffle()

Hard hat area, watch out
for falling assumptions

2

A

brain
power

Determine if these classes have low or high cohesion.
PlayerActions

Game
login()
signup()
move()
fire()

GameSession
login()

move()

getHighScore()

rest()

getName()

signup()

rest()
getHighScore()
getName()

340

Player

fire()

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Good thing you’re learning
about the Iterator pattern
because I just heard that Objectville
Mergers and Acquisitions has done
another deal... we’re merging with
Objectville Café and adopting their
dinner menu.

Wow, and we thought things
were already complicated.
Now what are we going to do?
Come on,
think positively, I’m
sure we can ﬁnd a way to
work them into the
Iterator Pattern.

you are here 4
Download at WoweBook.Com

341

a new menu

Taking a look at the Café Menu
Here’s the Café Menu. It doesn’t look like too much trouble to integrate the
Cafe Menu into our framework... let’s check it out.

Menu
plement our new
im
t
n’
es
do
u
en
CafeM
is is easily fixed.
s in a Hashtable.
interface, but th
The Café is storing their menu item see shortly...
public class CafeMenu {implements Menu {
Does that support Iterator? We’ll
Hashtable menuItems = new Hashtable();

nus, the menu items are

Like the other Me
public CafeMenu() {
initialized in the constructor.
addItem(“Veggie Burger and Air Fries”,
“Veggie burger on a whole wheat bun, lettuce, tomato, and fries”,
true, 3.99);
addItem(“Soup of the day”,
“A cup of the soup of the day, with a side salad”,
false, 3.69);
addItem(“Burrito”,
“A large burrito, with whole pinto beans, salsa, guacamole”,
true, 4.29);
}

em
Here’s where we create a new MenuItble.
hta
and add it to the menuItems has

public void addItem(String name, String description,
boolean vegetarian, double price)
{
MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
menuItems.put(menuItem.getName(), menuItem);
}

the key is

public Hashtable getItems() {
return menuItems;
}
}

the item n

ame.

the value is the menuItem object.

We’re not going to need this anymor

e.

Sharpen your pencil
Before looking at the next page, quickly jot down the three things
we have to do to this code to ﬁt it into our framework:

1.
2.
3.
342

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Reworking the Café Menu code
Integrating the Cafe Menu into our framework is easy. Why? Because
Hashtable is one of those Java collections that supports Iterator. But it’s not
quite the same as ArrayList...

public class CafeMenu implements Menu {
Hashtable menuItems = new Hashtable();

CafeMenu implements the Menu
interface, so the Waitress can use
it just like the other two Menus.
We’re using Hashtable because it’s a
common data structure for storing values;
you could also use the newer HashMap.

public CafeMenu() {
// constructor code here
}

public void addItem(String name, String description,
boolean vegetarian, double price)
{
MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
menuItems.put(menuItem.getName(), menuItem);
}
public Hashtable getItems() {
return menuItems;
}

getItems() so we don’t
Just like before, we can get rid of ms to the Waitress.
expose the implementation of menuIte

public Iterator createIterator() {
return menuItems.values().iterator();
}
}

Code Up Close

And here’s where we implement the createIterator()
method. Notice that we’re not getting an Iterator
for the whole Hashtable, just for the values.

Hashtable is a little more complex than the ArrayList because it
supports both keys and values, but we can still get an Iterator
for the values (which are the MenuItems).

public Iterator createIterator() {
return menuItems.values().iterator();
}

First we get the values of the Hashtable,
which is just a collection of all the
objects in the hashtable.

Luckily that collection supports the
iterator() method, which returns
object of type java.util.Iterator. a
you are here 4

Download at WoweBook.Com

343

test drive the new menu

Adding the Café Menu to the Waitress
That was easy; how about modifying the Waitress to support our new Menu?
Now that the Waitress expects Iterators, that should be easy too.

public class Waitress {
Menu pancakeHouseMenu;
Menu dinerMenu;
Menu cafeMenu;

The Café menu is passed into the Waitress in
the constructor with the other menus, and we
stash it in an instance variable.

public Waitress(Menu pancakeHouseMenu, Menu dinerMenu, Menu cafeMenu) {
this.pancakeHouseMenu = pancakeHouseMenu;
this.dinerMenu = dinerMenu;
this.cafeMenu = cafeMenu;
}
public void printMenu() {
Iterator pancakeIterator = pancakeHouseMenu.createIterator();
Iterator dinerIterator = dinerMenu.createIterator();
Iterator cafeIterator = cafeMenu.createIterator();
We’re using the Café’s
System.out.println(“MENU\n----\nBREAKFAST”);
menu for our dinner menu.
printMenu(pancakeIterator);
we have to do to print
All
System.out.println(“\nLUNCH”);
it is create the iterator,
printMenu(dinerIterator);
System.out.println(“\nDINNER”);
and pass it to printMenu().
printMenu(cafeIterator);
That’s it!
}
private void printMenu(Iterator iterator) {
while (iterator.hasNext()) {
MenuItem menuItem = (MenuItem)iterator.next();
System.out.print(menuItem.getName() + “, “);
System.out.print(menuItem.getPrice() + “ -- “);
System.out.println(menuItem.getDescription());
}
}
}

344

Chapter 9
Download at WoweBook.Com

Nothing changes here

the iterator and composite patterns

Breakfast, lunch AND dinner
Let’s update our test drive to make sure this all works.

public class MenuTestDrive {
public static void main(String args[]) {
PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
DinerMenu dinerMenu = new DinerMenu();
CafeMenu cafeMenu = new CafeMenu();

Create a CafeMenu...
... and pass it to the waitress.

Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu, cafeMenu);
waitress.printMenu();
}

Now, when we print we should see all three menu

s.

Here’s the test run; check out the new dinner menu from the Café!
File Edit Window Help Kathy&BertLikePancakes

% java DinerMenuTestDrive

First we iterate

MENU
through the pancake
---menu.
BREAKFAST
K&B’s Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs, and toast
Regular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage
Blueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries
And then
Wafﬂes, 3.59 -- Wafﬂes, with your choice of blueberries or strawberries

the diner

menu.
LUNCH
Vegetarian BLT, 2.99 -- (Fakin’) Bacon with lettuce & tomato on whole wheat
BLT, 2.99 -- Bacon with lettuce & tomato on whole wheat
Soup of the day, 3.29 -- Soup of the day, with a side of potato salad
Hotdog, 3.05 -- A hot dog, with saurkraut, relish, onions, topped with cheese
Steamed Veggies and Brown Rice, 3.99 -- Steamed vegetables over brown rice
Pasta, 3.89 -- Spaghetti with Marinara Sauce, and a slice of sourdough bread

DINNER
And finally the
Soup of the day, 3.69 -- A cup of the soup of the day, with a side salad
new café menu,
Burrito, 4.29 -- A large burrito, with whole pinto beans, salsa, guacamole
with the
all
Veggie Burger and Air Fries, 3.99 -- Veggie burger on a whole wheat bun,

same iteration
code.

lettuce, tomato, and fries

%

you are here 4
Download at WoweBook.Com

345

what did we do?

What did we do?

ArrayList

We wanted to give the
Waitress an easy way to
iterate over menu items...

d two
Our menu items haentations
different implem t
and two differenerating.
interfaces for it

Me
nuItem

Me
nuItem

1

2

Me
nuItem

3

Men

uItem

4

Array
1

... and we didn’t want her to
know about how the menu
items are implemented.

Me
nuItem

2
Me
nuItem

3
Me
nuItem

4
Men

uItem

We decoupled the Waitress....
So we gave the Waitress an
Iterator for each kind of
group of objects she needed
... one for
to iterate over...
ArrayList...

ArrayList has a
built in iterator... ArrayList

next()
Iterator

next()

... and one for
Array.

Me
nuItem

Me
nuItem

1

2

... Array doesn’t
have a built in
Iterator so we
built our own.

Me
nuItem

3

Array
1
Me
nuItem

2
Me
nuItem

Iterator

Now she doesn’t have to worry about which
implementation we used; she always uses the same
interface - Iterator - to iterate over menu items.
She’s been decoupled from the implementation.
346

Chapter 9
Download at WoweBook.Com

3
Me
nuItem

4
Men

uItem

Men

uItem

4

the iterator and composite patterns

... and we made the Waitress more extensible
We easily added
another implementation
of menu items, and
since we provided an
Iterator, the Waitress
Hashtable knew what to do.

By giving her an Iterator
we have decoupled her from
the implementation of the
menu items, so we can easily
add new Menus if we want.
next()

Me
nuItem

k ey

Me
nuItem

k ey

Me
nuItem

r

Iterato
Which is better fo
because now she ca r her,
same code to iter n use the
any group of obje ate over
it’s better for us cts. And
the implementation because
details
aren’t exposed.

k ey

Men

k ey

uItem

Making an Iterator
for the Hashtable
values was easy; when
you call
values.iterator()
you get an
Iterator.

But there’s more!
Java gives you a lot of
“collection” classes that allow
you to store and retrieve
groups of objects. For example,
Vector and LinkedList.

LinkedList

Vector

Most have different
interfaces.
But almost all of
them support a
way to obtain an
Iterator.

Me
nuItem

Me
nuItem

Me
nuItem

1

2

Me
nuItem

3

Men

Me
nuItem

Me
nuItem

Men

uItem

uItem

4

e!

.. .a n d mo r

And if they don’t support
Iterator, that’s ok, because now
you know how to build your own.
you are here 4
Download at WoweBook.Com

347

iterators and collections

Iterators and Collections
We’ve been using a couple of classes that are part of the Java Collections Framework.
This “framework” is just a set of classes and interfaces, including ArrayList, which we’ve
been using, and many others like Vector, LinkedList, Stack, and PriorityQueue. Each
of these classes implements the java.util.Collection interface, which contains a bunch of
useful methods for manipulating groups of objects.
Let’s take a quick look at the interface:

<<interface>>
Collection
add()
addAll()
clear()
contains()

all kinds of good
As you can see, there’s d and remove
stuff here. You can ad ction without
elements from your colleplemented.
even knowing how it’s im

containsAll()
equals()
hashCode()
isEmpty()
iterator()
remove()
removeAll()
retainAll()

Here’s our old friend, the iterator()
method. With this method, you can get
an Iterator for any class that implements
the Collection interface.

size()
toArray()

Other handy methods include siz
to get the number of elements e(),
and toArray() to turn your ,
collection into an array.

The nice thing about Collections and
Iterator is that each Collection object
knows how to create its own Iterator.
Calling iterator() on an ArrayList returns a
concrete Iterator made for ArrayLists, but
you never need to see or worry about the
concrete class it uses; you just use the
Iterator interface.

348

Chapter 9
Download at WoweBook.Com

Hashtable is one of a few
classes that indirectly
supports Iterator. As you saw
when we implemented the
CafeMenu, you could get an
Iterator from it, but only by
ﬁrst retrieving its Collection
called values. If you think
about it, this makes sense:
the Hashtable holds two
sets of objects: keys and
values. If we want to iterate
over its values, we ﬁrst need
to retrieve them from the
Hashtable, and then obtain
the iterator.

the iterator and composite patterns

Iterators and Collections
in Java 5

Check this out, in
Java 5 they’ve added
support for iterating
over Collections so that
you don’t even have to
ask for an iterator.

Java 5 includes a new form of the for statement, called
for/in, that lets you iterate over a collection or an array
without creating an iterator explicitly.
To use for/in, you use a for statement that looks like:

Iterates over
each object in
the collection.

obj is assigned to the next
element in the collection
each time through the loop.

for (Object obj: collection) {
...
}
Here’s how you iterate over an ArrayList using for/in:

Load up an
ArrayList of
MenuItems.

ArrayList items = new ArrayList();
items.add(new MenuItem(“Pancakes”, “delicious pancakes”, true, 1.59);
items.add(new MenuItem(“Wafﬂes”, “yummy wafﬂes”, true, 1.99);
items.add(new MenuItem(“Toast”, “perfect toast”, true, 0.59);
for (MenuItem item: items) {
System.out.println(“Breakfast item: “ + item);
}

Iterate over the list and print
each item.
You need to use Java 5’s new
generics feature to ensure for/
in type safety. Make sure you
read up on the details before
using generics and for/in.
you are here 4
Download at WoweBook.Com

349

code magnets

Code Magnets
The Chefs have decided that they want to be able to alternate their lunch menu items; in other words,
they will offer some items on Monday, Wednesday, Friday and Sunday, and other items on Tuesday,
Thursday, and Saturday. Someone already wrote the code for a new “Alternating” DinerMenu Iterator
so that it alternates the menu items, but they scrambled it up and put it on the fridge in the Diner as a
joke. Can you put it back together? Some of the curly braces fell on the ﬂoor and they were too small
to pick up, so feel free to add as many of those as you need.

MenuItem menuItem = items[position];
position = position + 2;
return menuItem;

import java.util.Iterator;
import java.util.Calendar;
}

public Object
next() {

uItem[] items)
public AlternatingDinerMenuIterator(Men
this.items = items;
Calendar rightNow = Calendar.getInst
ance();
position = rightNow.get(Calendar.DA
Y_OF_WEEK) % 2;

implemen
ts Itera
tor

public void remove() {

MenuItem[] items;
int position;
}

public class AlternatingDinerMenuIterator

public boolean hasNext() {
throw new UnsupportedOperationException(
“Alternating Diner Menu Iterator does not support remove
()”);

null) {
if (position >= items.length || items[position] ==
return false;
} else {
return true;
}

350

Chapter 9
Download at WoweBook.Com

}

the iterator and composite patterns

Is the Waitress ready for prime time?
The Waitress has come a long way, but you’ve gotta admit
those three calls to printMenu() are looking kind of ugly.
Let’s be real, every time we add a new menu we are going to
have to open up the Waitress implementation and add more
code. Can you say “violating the Open Closed Principle?”

Three createIterator() calls.
public void printMenu() {
Iterator pancakeIterator = pancakeHouseMenu.createIterator();
Iterator dinerIterator = dinerMenu.createIterator();
Iterator cafeIterator = cafeMenu.createIterator();
System.out.println(“MENU\n----\nBREAKFAST”);
printMenu(pancakeIterator);
System.out.println(“\nLUNCH”);
printMenu(dinerIterator);

Three calls to printMenu.

System.out.println(“\nDINNER”);
printMenu(cafeIterator);
}

Everytime we add or remove a menu we’re going
to have to open this code up for changes.
It’s not the Waitress’ fault. We have done a great job of decoupling the menu implementation and
extracting the iteration into an iterator. But we still are handling the menus with separate, independent
objects – we need a way to manage them together.

A

brain
power
The Waitress still needs to make three calls to printMenu(), one for each menu. Can you think of a
way to combine the menus so that only one call needs to be made? Or perhaps so that one Iterator is
passed to the Waitress to iterate over all the menus?

you are here 4
Download at WoweBook.Com

351

a new design?

This isn’t so bad, all we
need to do is package
the menus up into an ArrayList
and then get its iterator to iterate
through each Menu. The code in the
Waitress is going to be simple
and it will handle any number of
menus.

Sounds like the chef is on to something. Let’s give it a try:

Now we just take an
ArrayList of menus.

public class Waitress {
ArrayList menus;
public Waitress(ArrayList menus) {
this.menus = menus;
}

public void printMenu() {
Iterator menuIterator = menus.iterator();
while(menuIterator.hasNext()) {
Menu menu = (Menu)menuIterator.next();
printMenu(menu.createIterator());
}
}
void printMenu(Iterator iterator) {
while (iterator.hasNext()) {
MenuItem menuItem = (MenuItem)iterator.next();
System.out.print(menuItem.getName() + “, “);
System.out.print(menuItem.getPrice() + “ -- “);
System.out.println(menuItem.getDescription());
}
}
}

This looks pretty good, although we’ve lost the names of the menus,
but we could add the names to each menu.

352

Chapter 9
Download at WoweBook.Com

And we iterate
through the
menus, passing each
menu’s iterator
to the overloaded
printMenu() method.

No code
changes here.

the iterator and composite patterns

Just when we thought it was safe...
Now they want to add a dessert submenu.

I just heard the
Diner is going to be
creating a dessert menu that
is going to be an insert into
their regular menu.

Okay, now what? Now we have to support not only multiple
menus, but menus within menus.
It would be nice if we could just make the dessert menu an
element of the DinerMenu collection, but that won’t work as
it is now implemented.

What we want (something like this):

nu

All Menus
Pa

eM
e

nc
ake us
Ho

Di
ner nu
Me

1

Ca
feMenu

2

Café Menu

Pancake Menu

Diner Menu
Me
nuItem

Me
nuItem

1

2

Me
nuItem

Men

3

Here’s our Arraylist
that holds the menus
of each restaurant.

3

uItem

4

Array

1

k ey

Me
nuItem

k ey

Me
nuItem

k ey

Me
nuItem

Me
nuItem

2
Me
nuItem

ArrayList

Dessert Menu

Men

uItem

Me
nuItem

4

1
Me
nuItem

2
Me
nuItem

3
Me
nuItem

4
Men

this k!
But ’t wor
n
wo

k ey

3

Hashtable

uItem

Men

uItem

We need for Diner Menu to hold a submenu, but
we can’t actually assign a menu to a MenuItem
array because the types are different, so this
isn’t going to work.

We can’t assign a dessert menu to
a MenuItem array.
Time for a change!
you are here 4
Download at WoweBook.Com

353

time to refactor

What do we need?
The time has come to make an executive decision to
rework the chef ’s implementation into something that
is general enough to work over all the menus (and
now sub menus). That’s right, we’re going to tell the
chefs that the time as come for us to reimplement their
menus.
The reality is that we’ve reached a level of complexity
such that if we don’t rework the design now, we’re
never going to have a design that can accommodate
further acquisitions or submenus.
So, what is it we really need out of our new design?

ß We need some kind of a tree shaped structure that
will accommodate menus, submenus and menu
items.

ß We need to make sure we maintain a way to
traverse the items in each menu that is at least
as convenient as what we are doing now with
iterators.

ß We may need to be able to traverse the items in
a more ﬂexible manner. For instance, we might
need to iterate over only the Diner’s dessert menu,
or we might need to iterate over the Diner’s entire
menu, including the dessert submenu.

354

Chapter 9
Download at WoweBook.Com

There comes a time
when we must refactor
our code in order for it to grow.
To not do so would leave us with
rigid, inﬂexible code that has
no hope of ever sprouting
new life.

the iterator and composite patterns

Din

e

ca
ke Hous

Me

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

u
er Men

Me

nuItem

Me

De

nuItem

Me

nuItem

Me

ssert Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

Me

s
Menu

u
er Men

Me

nuItem

Me

Ca

De

nuItem

nuItem

Me

nuItem

Me

ssert Me

Me

nuItem

Me

De

fe Men

nuItem

u

e

Me

Me

nuItem

Me

nuItem

...and menu items.

We also need to
traverse more f be able to
instance over o lexibly, for
ne menu.

nu

M
e nu

n
Pa

Din

ca
ke Hous

fe Men

nuItem

nuItem

le
We still need to be abems
it
e
to traverse all th
in the tree.
All

Ca

... and sub menus...

Me

nuItem

Me

nu

n
Pa

M
e nu

We need to
accomodate Menus...

s
Menu

u

All

nu

present
Because we need to re s and
menus, nested sub menuturally fit
menu items, we can na ructure.
them in a tree-like st

ssert Me

nuItem

Me
nuItem

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

A

brain
power
How would you handle this new wrinkle to our design requirements? Think about it before turning the page.

you are here 4
Download at WoweBook.Com

355

composite pattern deﬁned

The Composite Pattern defined
Here’s a tree struct

ure

Elements with
child elements
are called nodes.

We’re not going to beat around the bush on this pattern,
we’re going to go ahead and roll out the ofﬁcial deﬁnition
now:

Let’s think about this in terms of our menus: this pattern
gives us a way to create a tree structure that can handle
a nested group of menus and menu items in the same
structure. By putting menus and items in the same
structure we create a part-whole hierarchy; that is, a tree of
objects that is made of parts (menus and menu items) but
that can be treated as a whole, like one big über menu.
Once we have our über menu, we can use this pattern
to treat “individual objects and compositions uniformly.”
What does that mean? It means if we have a tree structure
of menus, submenus, and perhaps subsubmenus along with
menu items, then any menu is a “composition” because
it can contain both other menus and menu items. The
individual objects are just the menu items – they don’t hold
other objects. As you’ll see, using a design that follows the
Composite Pattern is going to allow us to write some simple
code that can apply the same operation (like printing!) over
the entire menu structure.

L e af

Leaf

L eaf

Elements without children
are called leaves.

We can represent
our Menu and
MenuItems in a
tree structure.
Menu

Me

MenuIt

em

The Composite Pattern allows you to
compose objects into tree structures to
represent part-whole hierarchies. Composite
lets clients treat individual objects and
compositions of objects uniformly.

Node

Me
n u I te m

Menus are nodes and
MenuItems are leaves.

356

Chapter 9
Download at WoweBook.Com

nuIte

m

That’s right, we’re going to introduce another pattern
to solve this problem. We didn’t give up on Iterator – it
will still be part of our solution – however, the problem
of managing menus has taken on a new dimension that
Iterator doesn’t solve. So, we’re going to step back and
solve it with the Composite Pattern.

the iterator and composite patterns

y

We can create arbitraril
complex trees.

e

Me

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

MenuItems

Submenu

u
er Men

Me

De

nuItem

Me

nuItem

Ca

Me

ssert Me

Me

nuItem

Me

nuItem

fe Men

u

Din

ca
ke Hous

Menus

s
Menu

nu

n
Pa

M
e nu

All

Me

nuItem

Me

nuItem

The Composite Pattern
allows us to build structures
of objects in the form of
trees that contain both
compositions of objects and
individual objects as nodes.

nuItem

nuItem

ole...

And treat them as a wh

e

Me

nuItem

Me

Me

nuItem

nuItem

Me

nuItem

Me

Me

nuItem

MenuItems

Submenu

u
er Men

Me

De

nuItem

Me

nuItem

Ca

Me

ssert Me

Me

nuItem

nuItem

Me

Using a composite structure,
we can apply the same
operations over both
composites and individual
objects. In other words, in
most cases we can ignore
the differences between
compositions of objects and
individual objects.

fe Men

u

Din

ca
ke Hous

Menus

s
Menu

nu

n
Pa

M
e nu

All

Me

nuItem

nuItem

Me

nuItem

nuItem

....or as parts.

an be
Operations che whole.
t
applied to

print()

e

Me

nuItem

Me

nuItem

MenuItems

Me

nuItem

Me

nuItem

Me

u
er Men

Me

nuItem

Me

Submenu
De

nuItem

nuItem

Me

nuItem

Ca

Me

ssert Me

Me

nuItem

Me

nuItem

fe Men

nuItem

u

Din

ca
ke Hous

Menus

s
Menu

nu

n
Pa

M
e nu

All

Me

nuItem

Me

print()

nuItem

arts.

Or the p

you are here 4
Download at WoweBook.Com

357

composite pattern class diagram

The Client uses the e to
Component interfaccts in the
manipulate the obje
composition.

fines an
The Component de jects in
interface for all obth the
the composition: bo leaf nodes.
composite and the

The Component may imple
default behavior for ad ment a
getChild() and its operatd(), remove(),
ions.

Component

Client

operation()
add(Component)

Note that the Leaf als
inherits methods like ad o
remove() and getChild(),d(),
don’t necessarily make a which
sense for a leaf node. Welot of
going to come back to th ’re
is issue.

remove(Component)
getChild(int)

Leaf

site also
The Compo the Leafoperation()
implements erations.
related op some of
Note that not make
these may Composite,
sense on a case an
ne
defi
to
is
role
e’s
The Composit
so in that might be
nts
pone
com
the
behavior of
exception
child
e
stor
to
and
ren
having child
generated.
components.
remove(Component)

A Leaf has no
children.

getChild(int)

A Leaf defines the behavior for the
elements in the composition. It does
this by implementing the operations
the Composite supports.

there are no

Q:

Component, Composite, Trees?
I’m confused.

A:

A composite contains components.
Components come in two flavors:
composites and leaf elements. Sound
recursive? It is. A composite holds a set
of children, those children may be other
composites or leaf elements.

358

Composite
add(Component)

operation()

Dumb Questions
When you organize data in this way you end
up with a tree structure (actually an upside
down tree structure) with a composite at the
root and branches of composites growing up
to leaf nodes.

Q:

How does this relate to iterators?

Chapter 9
Download at WoweBook.Com

A:

Remember, we’re taking a new
approach. We’re going to re-implement the
menus with a new solution: the Composite
Pattern. So don’t look for some magical
transformation from an iterator to a
composite. That said, the two work very
nicely together. You’ll soon see that we
can use iterators in a couple of ways in the
composite implementation.

the iterator and composite patterns

Designing Menus with Composite
So, how do we apply the Composite Pattern to our menus? To start with, we need to create a
component interface; this acts as the common interface for both menus and menu items and allows
us to treat them uniformly. In other words we can call the same method on menus or menu items.
Now, it may not make sense to call some of the methods on a menu item or a menu, but we can deal
with that, and we will in just a moment. But for now, let’s take a look at a sketch of how the menus
are going to ﬁt into a Composite Pattern structure:

MenuComponent represents the interface for
both MenuItem and Menu. We’ve used an abstract
class here because we want to provide default
implementations for these methods.

he
oing to use t access
g
is
ss
e
r
it
a
e to
The W
ent interfac
MenuCompon and MenuItems.
both Menus

MenuComponent

Waitress

getName()
getDescription()
getPrice()
isVegetarian()
print()
add(Component)
remove(Component)

Here are the methods for
manipulating the components.
The components are
MenuItem and Menu.

Both MenuItem and Men
us
override print().

getChild(int)

Menu

MenuItem
getName()

menuComponents

getDescription()

getName()

getPrice()

getDescription()

isVegetarian()

print()

print()

add(Component)

We have some of the
same methods you’ll
remember from our
previous versions of
MenuItem and Menu,
and we’ve added print(),
add(), remove() and
getChild(). We’ll describe
these soon, when we
implement our new Menu
and MenuItem classes.

remove(Component)
getChild(int)

MenuItem overrides the
me
sense, and uses the default thods that make
MenuComponent for those implementations in
sense (like add() - it doesnthat don’t make
add a component to a M ’t make sense to
add components to a Men enuItem... we can only
u).

ds that make
Menu also overrides the methoremove menu items
and
sense, like a way to add
nuComponents.
(or other menus!) from its meName() and
get
In addition, we’ll use the
return the name
getDescription() methods to
and description of the menu.
you are here 4

Download at WoweBook.Com

359

implementing composite menus

Implementing the Menu Component
Okay, we’re going to start with the
MenuComponent abstract class; remember, the
role of the menu component is to provide an
interface for the leaf nodes and the composite
nodes. Now you might be asking, “Isn’t the
MenuComponent playing two roles?” It might
well be and we’ll come back to that point.
However, for now we’re going to provide a default
implementation of the methods so that if the
MenuItem (the leaf) or the Menu (the composite)
doesn’t want to implement some of the methods
(like getChild() for a leaf node) they can fall back
on some basic behavior:

ault
MenuComponent provides def thod.
me
ry
eve
r
fo
implementations
public abstract class MenuComponent {
public void add(MenuComponent menuComponent) {
throw new UnsupportedOperationException();
}
public void remove(MenuComponent menuComponent) {
throw new UnsupportedOperationException();
}
public MenuComponent getChild(int i) {
throw new UnsupportedOperationException();
}
public String getName() {
throw new UnsupportedOperationException();
}
public String getDescription() {
throw new UnsupportedOperationException();
}
public double getPrice() {
throw new UnsupportedOperationException();
}
public boolean isVegetarian() {
throw new UnsupportedOperationException();
}
public void print() {
throw new UnsupportedOperationException();
}
}

360

Chapter 9
Download at WoweBook.Com

All components must implement
the MenuComponent interface;
however, because leaves and
nodes have different roles we
can’t always deﬁne a default
implementation for each
method that makes sense.
Sometimes the best you can do
is throw a runtime exception.

Because some of these methods only make sense
for MenuItems, and some only make sense for
Menus, the default implementation is
UnsupportedOperationException. That way,
if MenuItem or Menu doesn’t support an
operation, they don’t have to do anything,
they can just inherit the
default implementation.

We’ve grouped together the
“composite” methods - that is,
methods to add, remove and get
MenuComponents.
ds;
Here are the “operation” metho s.
tem
these are used by the MenuI a
It turns out we can also use as
couple of them in Menu too, when
you’ll see in a couple of pages
we show the Menu code.

print() is an “operation” method
that both our Menus and MenuItems
will implement, but we provide a
default operation here.

the iterator and composite patterns

Implementing the Menu Item

I’m glad we’re going in
this direction, I’m thinking this is
going to give me the ﬂexibility I need
to implement that crêpe menu I’ve
always wanted.

Okay, let’s give the MenuItem class a shot. Remember,
this is the leaf class in the Composite diagram and it
implements the behavior of the elements of the composite.

public class MenuItem extends MenuComponent {
String name;
String description;
boolean vegetarian;
double price;
public MenuItem(String name,
String description,
boolean vegetarian,
double price)
{
this.name = name;
this.description = description;
this.vegetarian = vegetarian;
this.price = price;
}
public String getName() {
return name;
}
public String getDescription() {
return description;
}
public double getPrice() {
return price;
}
public boolean isVegetarian() {
return vegetarian;
}

First we need to extend
the MenuComponent
interface.

The constructor just takes
the name, description, etc. and
keeps a reference to them all.
This is pretty much like our old
menu item implementation.

Here’s our getter methods - just
like our previous implementation.

This is different from the previous implementation.
Here we’re overriding the print() method in the
MenuComponent class. For MenuItem this method
prints the complete menu entry: name, description,
price and whether or not it’s veggie.

public void print() {
System.out.print(“ “ + getName());
if (isVegetarian()) {
System.out.print(“(v)”);
}
System.out.println(“, “ + getPrice());
System.out.println(“
-- “ + getDescription());
}
}

you are here 4
Download at WoweBook.Com

361

composite structure

Implementing the Composite Menu
Now that we have the MenuItem, we just need the composite class, which we’re
calling Menu. Remember, the composite class can hold MenuItems or other Menus.
There’s a couple of methods from MenuComponent this class doesn’t implement:
getPrice() and isVegetarian(), because those don’t make a lot of sense for a Menu.

Menu is also a MenuComponent,
just like MenuItem.

children
Menu can have any number of use an
of type MenuComponent, we’ll se.
internal ArrayList to hold the

public class Menu extends MenuComponent {
ArrayList menuComponents = new ArrayList();
String name;
String description;
public Menu(String name, String description) {
this.name = name;
this.description = description;
}
public void add(MenuComponent menuComponent) {
menuComponents.add(menuComponent);
}
public void remove(MenuComponent menuComponent) {
menuComponents.remove(menuComponent);
}
public MenuComponent getChild(int i) {
return (MenuComponent)menuComponents.get(i);
}
public String getName() {
return name;
}
public String getDescription() {
return description;
}

Here’s how you add MenuItems or
other Menus to a Menu. Because
both MenuItems and Menus are
MenuComponents, we just need one
method to do both.
You can also remove a MenuComponent
or get a MenuComponent.

Here are the getter methods for getting the name and
description.
Notice, we aren’t overriding getPrice() or isVegetarian()
because those methods don’t make sense for a Menu
(although you could argue that isVegetarian() might make
sense). If someone tries to call those methods on a Menu,
they’ll get an UnsupportedOperationException.

public void print() {
System.out.print(“\n” + getName());
System.out.println(“, “ + getDescription());
System.out.println(“---------------------”);
}
}

362

This is different than our old implementation:
we’re going to give each Menu a name and a
description. Before, we just relied on having
different classes for each menu.

Chapter 9
Download at WoweBook.Com

To print the Menu, we print the
Menu’s name and description.

the iterator and composite patterns

Wait a sec, I don’t understand the
implementation of print(). I thought I was
supposed to be able to apply the same operations to a
composite that I could to a leaf. If I apply print() to a
composite with this implementation, all I get is a
simple menu name and description. I don’t get a
printout of the COMPOSITE.

Excellent catch. Because menu is a composite and contains
both Menu Items and other Menus, its print() method should
print everything it contains. If it didn’t we’d have to iterate
through the entire composite and print each item ourselves.
That kind of defeats the purpose of having a composite
structure.
As you’re going to see, implementing print() correctly is easy
because we can rely on each component to be able to print
itself. It’s all wonderfully recursive and groovy. Check it out:

Fixing the print() method
public class Menu extends MenuComponent {
ArrayList menuComponents = new ArrayList();
String name;
String description;
// constructor code here
// other methods here
public void print() {
System.out.print(“\n” + getName());
System.out.println(“, “ + getDescription());
System.out.println(“---------------------”);
Iterator iterator = menuComponents.iterator();
while (iterator.hasNext()) {
MenuComponent menuComponent =
(MenuComponent)iterator.next();
menuComponent.print();
}
}
}

ange the print() method
All we need to do is ch ly the information about
to make it print not on is Menu’s components:
this Menu, but all of th ems.
other Menus and MenuIt

Look! We get to use an Iterator. We
use it to iterate through all the Menu’s
components... those could be other Menus,
or they could be MenuItems. Since both
Menus and MenuItems implement print(), we
just call print() and the rest is up to them.

NOTE: If, during this iteration, we encounter another Menu
object, its print() method will start another iteration, and so on.
you are here 4
Download at WoweBook.Com

363

test drive the menu composite

Getting ready for a test drive...
It’s about time we took this code for a test drive, but we need to update the Waitress code before
we do – after all she’s the main client of this code:

public class Waitress {
MenuComponent allMenus;
public Waitress(MenuComponent allMenus) {
this.allMenus = allMenus;
}

is this simple.
Yup! The Waitress code really level menu
Now we just hand her the top ns all the
component, the one that contait allMenus.
other menus. We’ve called tha
All she has to do to print the entire menu
hierarchy - all the menus, and all the menu
items - is call print() on the top level menu.

public void printMenu() {
allMenus.print();
}
}

We’re gonna have one happy Wa

itress.

Okay, one last thing before we write our test drive. Let’s get an idea of what the menu
composite is going to look like at runtime:

The top level menu ho
lds all
menus and items.

Composite

Composite

n
Pa

M
e nu

Each Menu
holds items...
...or items and
other menus.

e

ca
ke Hous

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

Din

Me

s
Menu

Composite

u
er Men

Me

nuItem

De

nuItem

Ca

Me

ssert Me

fe Men

nuItem

u

All

nu

Every Menu and
MenuItem implements the
MenuComponent interface.

Me

nuItem

Leaf
Leaf

Me

nuItem

Me

nuItem

Me

nuItem

Me

nuItem

Leaf
364

Chapter 9
Download at WoweBook.Com

Leaf

Me

nuItem

the iterator and composite patterns

Now for the test drive...
Okay, now we just need a test drive. Unlike our previous version, we’re going to
handle all the menu creation in the test drive. We could ask each chef to give us
his new menu, but let’s get it all tested ﬁrst. Here’s the code:

public class MenuTestDrive {
public static void main(String args[]) {
MenuComponent pancakeHouseMenu =
new Menu(“PANCAKE HOUSE MENU”, “Breakfast”);
MenuComponent dinerMenu =
new Menu(“DINER MENU”, “Lunch”);
MenuComponent cafeMenu =
new Menu(“CAFE MENU”, “Dinner”);
MenuComponent dessertMenu =
new Menu(“DESSERT MENU”, “Dessert of course!”);

Let’s first create all
the menu objects.
We also need two top
level menu now that we’ll
name allMenus.

MenuComponent allMenus = new Menu(“ALL MENUS”, “All menus combined”);
allMenus.add(pancakeHouseMenu);
allMenus.add(dinerMenu);
allMenus.add(cafeMenu);
// add menu items here

We’re using the Composite add() method to add
each menu to the top level menu, allMenus.
Now we need to add all
the menu items, here’s one
example, for the rest, look
at the complete source code.

dinerMenu.add(new MenuItem(
“Pasta”,
“Spaghetti with Marinara Sauce, and a slice of sourdough bread”,
true,
3.89));
And we’re also adding a menu to
dinerMenu.add(dessertMenu);

a
t
menu. All dinerMenu cares abou is that
everything it holds, whether it’s a menu
item or a menu, is a MenuComponent.

dessertMenu.add(new MenuItem(
“Apple Pie”,
“Apple pie with a ﬂakey crust, topped with vanilla icecream”,
true,
1.59));
pie to
// add more menu items here
Waitress waitress = new Waitress(allMenus);
waitress.printMenu();
}
}

Add some apple
dessert menu...

the

Once we’ve constructed our entire
menu hierarchy, we hand the whole
thing to the Waitress, and as
you’ve seen, it’s easy as apple pie
for her to print it out.
you are here 4

Download at WoweBook.Com

365

composite responsibilities

Getting ready for a test drive...

NOTE: this output is based on the complete source.

File Edit Window Help GreenEggs&Spam

% java MenuTestDrive
ALL MENUS, All menus combined
---------------------

Here’s all our menus... we printed all this

PANCAKE HOUSE MENU, Breakfast
just by calling print() on the top level menu
--------------------K&B’s Pancake Breakfast(v), 2.99
-- Pancakes with scrambled eggs, and toast
Regular Pancake Breakfast, 2.99
-- Pancakes with fried eggs, sausage
Blueberry Pancakes(v), 3.49
-- Pancakes made with fresh blueberries, and blueberry syrup
Wafﬂes(v), 3.59
-- Wafﬂes, with your choice of blueberries or strawberries
DINER MENU, Lunch
--------------------Vegetarian BLT(v), 2.99
-- (Fakin’) Bacon with lettuce & tomato on whole wheat
BLT, 2.99
-- Bacon with lettuce & tomato on whole wheat
Soup of the day, 3.29
-- A bowl of the soup of the day, with a side of potato salad
Hotdog, 3.05
-- A hot dog, with saurkraut, relish, onions, topped with cheese
Steamed Veggies and Brown Rice(v), 3.99
-- Steamed vegetables over brown rice
Pasta(v), 3.89
-- Spaghetti with Marinara Sauce, and a slice of sourdough bread
DESSERT MENU, Dessert of course!
--------------------Apple Pie(v), 1.59
-- Apple pie with a ﬂakey crust, topped with vanilla icecream
Cheesecake(v), 1.99
-- Creamy New York cheesecake, with a chocolate graham crust
Sorbet(v), 1.89
-- A scoop of raspberry and a scoop of lime
CAFE MENU, Dinner
--------------------Veggie Burger and Air Fries(v), 3.99
-- Veggie burger on a whole wheat bun, lettuce, tomato, and fries
Soup of the day, 3.69
-- A cup of the soup of the day, with a side salad
Burrito(v), 4.29
-- A large burrito, with whole pinto beans, salsa, guacamole
%
366

Chapter 9
Download at WoweBook.Com

The new dessert
menu is printed
when we are
printing all the
Diner menu
components

the iterator and composite patterns

What’s the story? First you tell us
One Class, One Responsibility, and now you
are giving us a pattern with two responsibilities
in one class. The Composite Pattern manages
a hierarchy AND it performs operations
related to Menus.

There is some truth to that observation. We could say that the
Composite Pattern takes the Single Responsibility design principle and
trades it for transparency. What’s transparency? Well, by allowing the
Component interface to contain the child management operations and
the leaf operations, a client can treat both composites and leaf nodes
uniformly; so whether an element is a composite or leaf node becomes
transparent to the client.
Now given we have both types of operations in the Component
class, we lose a bit of safety because a client might try to do something
inappropriate or meaningless on an element (like try to add a menu
to a menu item). This is a design decision; we could take the design in
the other direction and separate out the responsibilities into interfaces.
This would make our design safe, in the sense that any inappropriate
calls on elements would be caught at compile time or runtime, but we’d
lose transparency and our code would have to use conditionals and the
instanceof operator.
So, to return to your question, this is a classic case of tradeoff. We are
guided by design principles, but we always need to observe the effect
they have on our designs. Sometimes we purposely do things in a way
that seems to violate the principle. In some cases, however, this is a
matter of perspective; for instance, it might seem incorrect to have
child management operations in the leaf nodes (like add(), remove() and
getChild()), but then again you can always shift your perspective and see
a leaf as a node with zero children.

you are here 4
Download at WoweBook.Com

367

ﬂashback to iterator

Flashback to Iterator
We promised you a few pages back that we’d show you how to use Iterator
with a Composite. You know that we are already using Iterator in our internal
implementation of the print() method, but we can also allow the Waitress to
iterate over an entire composite if she needs to, for instance, if she wants to go
through the entire menu and pull out vegetarian items.
To implement a Composite iterator, let’s add a createIterator() method in every
component. We’ll start with the abstract MenuComponent class:
MenuComponent
getName()
getDescription()
getPrice()
isVegetarian()
print()
add(Component)
remove(Component)
getChild(int)
createIterator()

We’ve added a createIterator() method
to the MenuComponent. This means
that each Menu and MenuItem will
need to implement this method. It also
means that calling createIterator() on
a composite should apply to all children
of the composite.

Now we need to implement this method in the Menu and MenuItem classes:
public class Menu extends MenuComponent {
Iterator iterator = null;
// other code here doesn’t change

We only need one
iterator per Menu.

Here we’re using a new iterator called
CompositeIterator. It knows how to
iterate over any composite.

We pass it the current
iterator.

public Iterator createIterator() {
composite’s
if (iterator == null) {
iterator = new CompositeIterator(menuComponents.iterator());
}
return iterator;
}
}
public class MenuItem extends MenuComponent {
// other code here doesn’t change
public Iterator createIterator() {
return new NullIterator();
}

Now for the MenuItem...

Whoa! What’s this NullIterator?
You’ll see in two pages.

}

368

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

The Composite Iterator
The CompositeIterator is a SERIOUS iterator. It’s got the job of iterating
over the MenuItems in the component, and of making sure all the child
Menus (and child child Menus, and so on) are included.
Here’s the code. Watch out, this isn’t a lot of code, but it can be a little mind
bending. Just repeat to yourself as you go through it “recursion is my friend,
recursion is my friend.”
import java.util.*;

Watch Out:
Recursion
Zone Ahead

Like all iterators, we’re
implementing the java.util.Iterator
interface.

public class CompositeIterator implements Iterator {
Stack stack = new Stack();
public CompositeIterator(Iterator iterator) {
stack.push(iterator);
}

The iterator of the top level
composite we’re going to iterate over
is passed in. We throw that in a
stack data structure.
Okay, when the client wants

to get the next element we
public Object next() {
first make sure there is one
if (hasNext()) {
Iterator iterator = (Iterator) stack.peek();
by calling hasNext()...
MenuComponent component = (MenuComponent) iterator.next();
if (component instanceof Menu) {
stack.push(component.createIterator());
If there is a next element, we
}
return component;
get the current iterator off the
} else {
stack and get its next element.
return null;
}
If that element is a menu, we have
}
another composite that needs to
be included in the iteration, so we

public boolean hasNext() {
throw it on the stack. In either
if (stack.empty()) {
case, we return the component.
return false;
} else {
To see if there is a next element,
Iterator iterator = (Iterator) stack.peek();
we check to see if the stack is
if (!iterator.hasNext()) {
empty; if so, there isn’t.
stack.pop();
Otherwise, we get the iterator
return hasNext();
off the top of the stack and see
} else {
if it has a next element. If it
return true;
element
next
a
is
there
Otherwise
doesn’t we pop it off the stack
}
and we return true.
}
and call hasNext() recursively.
}
public void remove() {
throw new UnsupportedOperationException();
}
}

We’re not supporting
remove, just traversal.
you are here 4

Download at WoweBook.Com

369

internal and external

That is serious code... I’m trying
to understand why iterating over
a composite like this is more difﬁcult
than the iteration code we wrote for
print() in the MenuComponent class?

When we wrote the print() method in the
MenuComponent class we used an iterator to
step through each item in the component and if
that item was a Menu (rather than a MenuItem),
then we recursively called the print() method to
handle it. In other words, the MenuComponent
handled the iteration itself, internally.
With this code we are implementing an external
iterator so there is a lot more to keep track of.
For starters, an external iterator must maintain its
position in the iteration so that an outside client
can drive the iteration by calling hasNext() and
next(). But in this case, our code also needs to
maintain that position over a composite, recursive
structure. That’s why we use stacks to maintain
our position as we move up and down the
composite hierarchy.

370

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

A

brain
power
Draw a diagram of the Menus and MenuItems. Then pretend you are the CompositeIterator, and your job is
to handle calls to hasNext() and next(). Trace the way the CompositeIterator traverses the structure as this
code is executed:
public void testCompositeIterator(MenuComponent component) {
CompositeIterator iterator = new CompositeIterator(component.iterator);
while(iterator.hasNext()) {
MenuComponent component = iterator.next();
}
}

you are here 4
Download at WoweBook.Com

371

the null iterator

The Null Iterator
Okay, now what is this Null Iterator all about? Think about it this way: a
MenuItem has nothing to iterate over, right? So how do we handle the
implementation of its createIterator() method? Well, we have two choices:

Choice one:

ample of the
NOTE: Another exn Pattern.”
Null Object “Desig

Return null
We could return null from createIterator(), but then we’d
need conditional code in the client to see if null was
returned or not.

Choice two:
Return an iterator that always returns
false when hasNext() is called
This seems like a better plan. We can still return an iterator, but
the client doesn’t have to worry about whether or not null is ever
returned. In effect, we’re creating an iterator that is a “no op”.

The second choice certainly seems better. Let’s call it NullIterator and
implement it.
import java.util.Iterator;

This is the laziest Iterator you’ve
ever seen, at every step of the
way it punts.

public class NullIterator implements Iterator {
public Object next() {
return null;
}

When next() is called, we return null.

public boolean hasNext() {
return false;
}
public void remove() {
throw new UnsupportedOperationException();
}
}

372

Chapter 9
Download at WoweBook.Com

Most importantly when hasNext() is
called we always return false.

And the NullIterator wouldn’t think
of supporting remove.

the iterator and composite patterns

Give me the vegetarian menu
Now we’ve got a way to iterate over every item of the Menu. Let’s
take that and give our Waitress a method that can tell us exactly
which items are vegetarian.

public class Waitress {
MenuComponent allMenus;
public Waitress(MenuComponent allMenus) {
this.allMenus = allMenus;
}
public void printMenu() {
allMenus.print();
}
public void printVegetarianMenu() {
Iterator iterator = allMenus.createIterator();
System.out.println(“\nVEGETARIAN MENU\n----”);
while (iterator.hasNext()) {
MenuComponent menuComponent =
(MenuComponent)iterator.next();
try {
if (menuComponent.isVegetarian()) {
menuComponent.print();
}
} catch (UnsupportedOperationException e) {}
}
}
}

We implemented isVegetarian() on the
Menus to always throw an exception. If
that happens we catch the exception, but
continue with our iteration.

The printVegetarianMenu() method
takes the allMenu’s composite and
gets its iterator. That will be our
CompositeIterator.
Iterate through
every element of the
composite.

Call each element’s
isVegetarian() method
and if true, we call its
print() method.
print() is
only called on
MenuItems, never
composites. Can you
see why?

you are here 4
Download at WoweBook.Com

373

magic of iterator and composite

The magic of Iterator & Composite together...
Whooo! It’s been quite a development effort to get our code to this point. Now we’ve got a general
menu structure that should last the growing Diner empire for some time. Now it’s time to sit back and
order up some veggie food:

File Edit Window Help HaveUhuggedYurIteratorToday?

% java MenuTestDrive
VEGETARIAN MENU
The Vegetarian Menu consists of the
---vegetarian items from every menu.
K&B’s Pancake Breakfast(v), 2.99
-- Pancakes with scrambled eggs, and toast
Blueberry Pancakes(v), 3.49
-- Pancakes made with fresh blueberries, and blueberry syrup
Wafﬂes(v), 3.59
-- Wafﬂes, with your choice of blueberries or strawberries
Vegetarian BLT(v), 2.99
-- (Fakin’) Bacon with lettuce & tomato on whole wheat
Steamed Veggies and Brown Rice(v), 3.99
-- Steamed vegetables over brown rice
Pasta(v), 3.89
-- Spaghetti with Marinara Sauce, and a slice of sourdough bread
Apple Pie(v), 1.59
-- Apple pie with a ﬂakey crust, topped with vanilla icecream
Cheesecake(v), 1.99
-- Creamy New York cheesecake, with a chocolate graham crust
Sorbet(v), 1.89
-- A scoop of raspberry and a scoop of lime
Apple Pie(v), 1.59
-- Apple pie with a ﬂakey crust, topped with vanilla icecream
Cheesecake(v), 1.99
-- Creamy New York cheesecake, with a chocolate graham crust
Sorbet(v), 1.89
-- A scoop of raspberry and a scoop of lime
Veggie Burger and Air Fries(v), 3.99
-- Veggie burger on a whole wheat bun, lettuce, tomato, and fries
Burrito(v), 4.29
-- A large burrito, with whole pinto beans, salsa, guacamole
%

374

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

I noticed in your
printVegetarianMenu() method that you
used the try/catch to handle the logic of the
Menus not supporting the isVegetarian() method.
I’ve always heard that isn’t good programming
form.

Let’s take a look at what you’re talking about:
try {
if (menuComponent.isVegetarian()) {
menuComponent.print();
}
} catch (UnsupportedOperationException) {}

n() on all
We call isVegetaria t Menus
bu
s,
MenuComponent because they
throw an exceptionoperation.
don’t support the

If the menu component doesn’t support the
operation, we just throw away the exception
and ignore it.
In general we agree; try/catch is meant for error handling,
not program logic. What are our other options? We could
have checked the runtime type of the menu component with
instanceof to make sure it’s a MenuItem before making the
call to isVegetarian(). But in the process we’d lose transparency
because we wouldn’t be treating Menus and MenuItems
uniformly.
We could also change isVegetarian() in the Menus so that it
returns false. This provides a simple solution and we keep our
transparency.
In our solution we are going for clarity: we really want to
communicate that this is an unsupported operation on the
Menu (which is different than saying isVegetarian() is false). It
also allows for someone to come along and actually implement
a reasonable isVegetarian() method for Menu and have it work
with the existing code.
That’s our story and we’re stickin’ to it.

you are here 4
Download at WoweBook.Com

375

interview with composite

Patterns Exposed
This week’s interview:
The Composite Pattern, on Implementation issues
HeadFirst: We’re here tonight speaking with the
Composite Pattern. Why don’t you tell us a little about
yourself, Composite?
Composite: Sure... I’m the pattern to use when you
have collections of objects with whole-part relationships
and you want to be able to treat those objects uniformly.
HeadFirst: Okay, let’s dive right in here... what do you
mean by whole-part relationships?
Composite: Imagine a graphical user interface; there
you’ll often ﬁnd a top level component like a Frame or
a Panel, containing other components, like menus, text
panes, scrollbars and buttons. So your GUI consists
of several parts, but when you display it, you generally
think of it as a whole. You tell the top level component
to display, and count on that component to display all
its parts. We call the components that contain other
components, composite objects, and components that
don’t contain other components, leaf objects.

Composite: Well there’s a couple of ways to handle
it; sometimes you can just do nothing, or return null or
false – whatever makes sense in your application. Other
times you’ll want to be more proactive and throw an
exception. Of course, then the client has to be willing to
do a little work and make sure that the method call didn’t
do something unexpected.
HeadFirst: But if the client doesn’t know which kind
of object they’re dealing with, how would they ever know
which calls to make without checking the type?
Composite: If you’re a little creative you can structure
your methods so that the default implementations do
something that does make sense. For instance, if the
client is calling getChild(), on the composite this makes
sense. And it makes sense on a leaf too, if you think of
the leaf as an object with no children.

HeadFirst: Is that what you mean by treating the
objects uniformly? Having common methods you can
call on composites and leaves?

HeadFirst: Ah... smart. But, I’ve heard some clients
are so worried about this issue, that they require separate
interfaces for different objects so they aren’t allowed
to make nonsensical method calls. Is that still the
Composite Pattern?

Composite: Right. I can tell a composite object to
display or a leaf object to display and they will do the
right thing. The composite object will display by telling
all its components to display.

Composite: Yes. It’s a much safer version of the
Composite Pattern, but it requires the client to check the
type of every object before making a call so the object
can be cast correctly.

HeadFirst: That implies that every object has the same
interface. What if you have objects in your composite
that do different things?

HeadFirst: Tell us a little more about how these
composite and leaf objects are structured.

Composite: Well, in order for the composite to work
transparently to the client, you must implement the same
interface for all objects in the composite, otherwise, the
client has to worry about which interface each object
is implementing, which kind of defeats the purpose.
Obviously that means that at times you’ll have objects for
which some of the method calls don’t make sense.
HeadFirst: So how do you handle that?
376

Composite: Usually it’s a tree structure, some kind of
hierarchy. The root is the top level composite, and all its
children are either composites or leaf nodes.
HeadFirst: Do children ever point back up to their
parents?
Composite: Yes, a component can have a pointer to a
parent to make traversal of the structure easier. And, if
you have a reference to a child, and you need to delete it,
you’ll need to get the parent to remove the child. Having
the parent reference makes that easier too.

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

HeadFirst: There’s really quite a lot to consider in your
implementation. Are there other issues we should think
about when implementing the Composite Pattern?
Composite: Actually there are... one is the ordering
of children. What if you have a composite that needs to
keep its children in a particular order? Then you’ll need
a more sophisticated management scheme for adding and
removing children, and you’ll have to be careful about
how you traverse the hierarchy.
HeadFirst: A good point I hadn’t thought of.
Composite: And did you think about caching?
HeadFirst: Caching?
Composite: Yeah, caching. Sometimes, if the
composite structure is complex or expensive to traverse,
it’s helpful to implement caching of the composite nodes.
For instance, if you are constantly traversing a composite
and all its children to compute some result, you could
implement a cache that stores the result temporarily to
save traversals.
HeadFirst: Well, there’s a lot more to the Composite
Patterns than I ever would have guessed. Before we
wrap this up, one more question: What do you consider
your greatest strength?
Composite: I think I’d deﬁnitely have to say
simplifying life for my clients. My clients don’t have to
worry about whether they’re dealing with a composite
object or a leaf object, so they don’t have to write if
statements everywhere to make sure they’re calling the
right methods on the right objects. Often, they can make
one method call and execute an operation over an entire
structure.
HeadFirst: That does sound like an important beneﬁt.
There’s no doubt you’re a useful pattern to have around
for collecting and managing objects. And, with that,
we’re out of time... Thanks so much for joining us and
come back soon for another Patterns Exposed.

you are here 4
Download at WoweBook.Com

377

crossword puzzle

It’s that time again....
�

�
�

�

�
�

�
�

�
��

��

��

��

��

��

��

��

378

������

����

�� ���� ��������� �������� ����� ��� ���� �������
��� ����� �����������
�� ���������� ��� �������� ��� �� ���� �������
�� �� ������������ �����
�� � �������� ������ ���� ��� �������� �
�����������
��� ������ ���� ��� ������
��� ��� �� ���������
��� ���� �� ��������� ���� ������ ���� ���
�������������� ��� ������
��� ����� ������� ���������
��� � ����� ������ ���� ���� ��� ������ �� ��
�����
��� ���� ����� ���������� �������� ���������
��� ���� ���� ������ �� �� ������ ��� ������
���������������

�� � ��������� ����� �����
�� �� ������������ ����
�� �� ������� ������������������������
������� ���� ����� ������� �������� �� ���������
�� ��� �������� ������� ��������� ��� ������ ����
��� ���������� ����������
�� ����������������� ���� � ��� �� �����
�� ��������� ��� ������� ������� ����� ����
��������
�� � ��������� ��� �� � ��������� �� �����
��� ��������� ��� ��������� ���� ��������� ����
����������

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Match each pattern with its description:

Pattern
Strategy

Adapter

Iterator

Facade
Composite

Observer

Description
Clients treat collections of
objects and individual objects
uniformly
Provides a way to traverse a
collection of objects without
exposing the collection’s
implementation
Simpliﬁes the interface of a
group of classes
Changes the interface of one
or more classes
Allows a group of objects to
be notiﬁed when some state
changes
Encapsulates interchangeable
behaviors and uses delegation
to decide which one to uses

you are here 4
Download at WoweBook.Com

379

your design toolbox

Tools for your Design Toolbox
Two new patterns for your toolbox – two great ways
to deal with collections of objects.

BULLET POINTS

ß An Iterator allows access to an
aggregate’s elements without
exposing its internal structure.

les OO Basics
p
i
c
n
i
r
P
O
O what varies
n

ß An Iterator takes the job of

ractio
ce. Abst
an
it
er
h
in
n
sition over
Encapsulatio
Favor compo
t
no
m
interfaces,
Polymorphis
Program to ions.
ce
implementat
esigns Inheritan

Encapsulate

led d
loosely coup
Strive for jects that interact.
between ob
or
ld be open f
Classes shou ut closed for
extension b n.
modificatio
. Do not
abstractions
Depend on ncrete classes.
depend on co
ds.
o your frien
Only talk t
u.
, we’ll call yo
Don’t call us
reason
ave only one
h
ld
ou
sh
s
A clas
to change.

OO Patteinresnafsinfames ilya oofneal-gotori-tmhmnas,anly

iterating over an aggregate
and encapsulates it in another
object.

ß When using an Iterator, we
relieve the aggregate of the
responsibility of supporting
operations for traversing its
data.

ß An Iterator provides a common
le
ant princip
t
r
o
p
im
r
e
Yet anothchange in a design.
based on

ß We should strive to assign
only one responsibility to each
class.

Another two-for-one
Chapter.

def de
mitPio
oavimtfdicineaeallnya.n
sddso
atcjeesohcrttayhe
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
dntamtocak
A
b
e
e
e sof
tahm
d
go
F
b
o
t
al
ll
es
c
y
c
a
t
d
c
e
at
he
,
c
je
n
o
e
t
ul
b
e
a
D
h
t
o
s
d
ps
r
a
il
t
t
n
stg famenieitoits.bje
encadepe Abst ilc. it
yanrnlegeeeastin
oM
t, butas
ttcreg
y
s
ra
r
a
ie
t
h
o
S
t
t
b
c
c
le
a
a
si
le
us
t
n
je
ab
F
g
ib
o
o
a
b
t
xsubdinjeruecptdas cwlaeitdsshcooinunttlygo rheoqinuetst
tnotnha
reenanspinge
sfeEale
otneerofacseapfcfrroeomoviftodoclifrenieiecnt
r
a
inter
d
whch
d
n
ss
e
t
la
n
t
c
e
e
lyaforgrelendteped inge fwonhrcviicadehpxesuaes.tglosbal p uest
cnrodeenrelainadntteneSeostdrin
inpdeeep
varydeD
bnirsccalaedcneossadcnnid
sshsuaeem
cd-rerp-EtyreoEMrcnelacebatssyphsuoledlattleinetsgs ayorueq
iv
su
nleatoaynlleineybCgtcinolaotstm
e
a
t
F
p
c
a
.
auatltomespratetincioicifst
it
e
je
d
letlasshtdeteifsinfgaeryeonqutuenstt e the
yia.At obto tr.,onttth,iaettEhntioetnorncseawbtcpycoit
h
e
su
e
y
a
func noaaflintatscdcaaeesnfssoF
c
li
a
c
e
st
je
inob adew
odtds,tifin-afgneDdrayfenoefadurnineonpteration,
srrceeewtbqtityuhehlest
nbhgtM
colarssp-arParmeaervintadeceeratizeom
e
e
je
li
a
c
t
o
lo
e
,
e
t
e
t
r
t
t
a
c
iz
o
a
r
la
g
je
e
e
p
e
b
u
r
e
It subecnlatssrs eeoqps.fuaerastasnms,Tangqegu e ocresliarloenangtatiolgsrenowqs.rituitehsthmds,ifin
fp
the elem suwpitrpehoqopruuatetrstsk
sus,bcalanssodmeps.ose objects into
uaenms,exdelepoqtotauesiboernleuizgboeoleit
atgeioprnses.qtuoest
r
e
lo
p
st
o
r
o
y
m
ll
e
u
so
ia
a
e
t
o
e
u
g
n
d
seque
fuiones,nrrqin Chooopmderpleaottsiositnsus.bc-laCssteos reprhemsent partsu
repserpeonqrtdutaetst
p
e
r
g
in
oaMbleet
ures orit
ly
r
e
und
supTpoermtplauntde certtarinee ststerpusctofchaien s.alg’sComposite lets d
r
e
a
r
in
ie
f
rede
wginhoglethhe algotritinhdmividual objects an
n
a
h
c
t
u
o
h
wit
clients treas of objects uniformly
e
r
u
t
c
u
r
st
composition

380

interface for traversing the
items of an aggregate, allowing
you to use polymorphism when
writing code that makes use of
the items of the aggregate.

Chapter 9
Download at WoweBook.Com

ß The Composite Pattern
provides a structure to hold
both individual objects and
composites.

ß The Composite Pattern allows
clients to treat composites and
individual objects uniformly.

ß A Component is any object
in a Composite structure.
Components may be other
composites or leaf nodes.

ß There are many design
tradeoffs in implementing
Composite. You need to
balance transparency and
safety with your needs.

the iterator and composite patterns

Exercise solutions

Sharpen your pencil
Based on our implementation of printMenu(), which of the following apply?

❏ D. The Waitress needs to know how each

❏ A. We are coding to the
PancakeHouseMenu and DinerMenu
concrete implementations, not to an
interface.

❏ B. The Waitress doesn’t implement the
Java Waitress API and so isn’t adhering
to a standard.

❏ C. If we decided to switch from using
DinerMenu to another type of menu
that implemented its list of menu items
with a Hashtable, we’d have to modify
a lot of code in the Waitress.

menu represents its internal collection of
menu items is implemented, this violates
encapsulation.

❏ E. We have duplicate code: the printMenu()
method needs two separate loop
implementations to iterate over the two
different kinds of menus. And if we
added a third menu, we might have to
add yet another loop.

❏ F. The implementation isn’t based on
MXML (Menu XML) and so isn’t as
interoperable as it should be.

Sharpen your pencil
Before turning the page, quickly jot down the three things we have
to do to this code to ﬁt it into our framework:

1. implement the Menu interface
2. get rid of getItems()
3. add createIterator() and return an Iterator that can step through the Hashtable values

you are here 4
Download at WoweBook.Com

381

exercise solutions

Code Magnets Solution
The unscrambled “Alternating” DinerMenu Iterator

import java.util.Iterator;
import java.util.Calendar;

implemen
ts Itera
tor

}

public class AlternatingDinerMenuIterator

MenuItem[] items;
int position;
}

uItem[] items)
public AlternatingDinerMenuIterator(Men
this.items = items;
Calendar rightNow = Calendar.getInst
ance();
position = rightNow.get(Calendar.DA
Y_OF_WEEK) % 2;
}

public boolean hasNext() {

null) {
if (position >= items.length || items[position] ==
return false;
} else {
return true;
}
}

public Object
next() {

MenuItem menuItem = items[position];
position = position + 2;
return menuItem;

Notice that this Iterator
implementation does not
support remove()

}

public void remove() {

throw new UnsupportedOperationException(
“Alternating Diner Menu Iterator does not support remove
()”);
}

382

}

Chapter 9
Download at WoweBook.Com

the iterator and composite patterns

Match each pattern with its description:

Pattern
Strategy

Adapter

Iterator

Facade
Composite

Observer

Description
Clients treat collections of
objects and individual objects
uniformly
Provides a way to traverse a
collection of objects without
exposing the collection’s
implementation
Simpliﬁes the interface of a
group of classes
Changes the interface of one
or more classes
Allows a group of objects to
be notiﬁed when some state
changes
Encapsulates interchangeable
behaviors and uses delegation
to decide which one to uses

you are here 4
Download at WoweBook.Com

383

crossword puzzle solution

Exercise solutions
�

�

�

� �

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

��

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�
��

�

������

�

����

������������������������������������������
����������������������������������������
������������������������������������������
�����������������������������������
�� ���������� ��� �������� ��� �� ���� �������
���������������������������������������
�����������
���������������������������������������
�� �� ������������ ����� �����������
��������� �����������
�����������������������������������������
���������������������������������������������
����������� ����������
���� ��� ���������� ����������
������������������������������������������
����������������
����������������������������
�����������������������������������������
�������������������������������������������
�����������
��������������
�� ��������� ��� ������� ������� ����� ����
Chapter 9��� ������ ����������������������
384
�����������������������������������
�������������������������
Download at WoweBook.Com
����������������������������������������������
�������������������������������������������

10 the State Pattern

g

h

The State of Things g
I thought things in Objectville
were going to be so easy, but now
every time I turn around there’s
another change request coming in.
I’m to the breaking point! Oh, maybe
I should have been going to Betty’s
Wednesday night patterns group all
along. I’m in such a state!

A little known fact: the Strategy and State Patterns were twins
separated at birth. As you know, the Strategy Pattern went on to create a wildly
successful business around interchangeable algorithms. State, however, took the perhaps
more noble path of helping objects to control their behavior by changing their internal
state. He’s often overheard telling his object clients, “Just repeat after me: I’m good
enough, I’m smart enough, and doggonit...”

this is a new chapter
Download at WoweBook.Com

385

meet mighty gumball

va
Jaw Breakers
Java toasters are so ‘90s. Today people are building Java into
real devices, like gumball machines. That’s right, gumball
machines have gone high tech; the major manufacturers have
found that by putting CPUs into their machines, they can
increase sales, monitor inventory over the network and measure
customer satisfaction more accurately.
But these manufacturers are gumball machine experts, not
software developers, and they’ve asked for your help:

Where the Gumball Machine
is Never Half Empty

to
ll machine controller needs
ba
gum
e
th
ink
th
we
y
wa
e
We
th
s
Here’
va for us!
can implement this in Jayo
work. We’re hoping you ha
u need to keep
so
re,
tu
e fu
th
in
r
vio
be
re
mo
g
din
ad
be
may
ainable as possible!
the design as flexible and maint
- Mighty Gumball Engineers

gumba

lls =

386

bal

0

ls >

ns

cra

uarter

inserts q

No
r
Quarte
gum

tur

Has r
Quarte

uarter

Out obfalls
Gum

0

ejects q

Mighty Gumball, Inc.

y – we
t’s their stor h the
At least tha
wit
st got bored
think they ju hnology and needed
tec
circa 1800’s
ir jobs
to make the
ay
w
a
to find
g.
more excitin

dispenslel
gumba

Chapter 10
Download at WoweBook.Com

ll
Gumba
Sold

nk

the state pattern

Cubicle Conversation
Let’s take a look
at this diagram and see
what the Mighty Gumball
guys want...

Anne: This diagram looks like a state diagram.
Joe: Right, each of those circles is a state...
Anne: ... and each of the arrows is a state transition.
Frank: Slow down, you two, it’s been too long since I studied state diagrams.
Can you remind me what they’re all about?

Joe

Anne

Frank

Anne: Sure, Frank. Look at the circles; those are states. “No Quarter” is
probably the starting state for the gumball machine because it’s just sitting
there waiting for you to put your quarter in. All states are just different
conﬁgurations of the machine that behave in a certain way and need some
action to take them to another state.

Joe: Right. See, to go to another state, you need to do something like put a quarter in the machine. See the arrow
from “No Quarter” to “Has Quarter?”
Frank: Yes...
Joe: That just means that if the gumball machine is in the “No Quarter” state and you put a quarter in, it will
change to the “Has Quarter” state. That’s the state transition.
Frank: Oh, I see! And if I’m in the “Has Quarter” state, I can turn the crank and change to the “Gumball Sold”
state, or eject the quarter and change back to the “No Quarter” state.
Anne: You got it!
Frank: This doesn’t look too bad then. We’ve obviously got four states, and I think we also have four actions: “inserts
quarter,” “ejects quarter,” “turns crank” and “dispense.” But... when we dispense, we test for zero or more gumballs
in the “Gumball Sold” state, and then either go to the “Out of Gumballs” state or the “No Quarter” state. So we
actually have ﬁve transitions from one state to another.
Anne: That test for zero or more gumballs also implies we’ve got to keep track of the number of gumballs too. Any
time the machine gives you a gumball, it might be the last one, and if it is, we need to transition to the “Out of
Gumballs” state.
Joe: Also, don’t forget that you could do nonsensical things, like try to eject the quarter when the gumball machine
is in the “No Quarter” state, or insert two quarters.
Frank: Oh, I didn’t think of that; we’ll have to take care of those too.
Joe: For every possible action we’ll just have to check to see which state we’re in and act appropriately. We can do
this! Let’s start mapping the state diagram to code...
you are here 4
Download at WoweBook.Com

387

review of state machines

State machines 101
How are we going to get from that state diagram to actual code? Here’s a quick
introduction to implementing state machines:
1

First, gather up your states:

No
r
Quarte

2

Has r
Quarte

Out obfalls
Gum

ll
Gumba
Sold

Next, create an instance variable to hold the current state, and deﬁne values for each of the states:

Let’s just call “Out of Gumballs”
“Sold Out” for short.
ﬁnal
ﬁnal
ﬁnal
ﬁnal

static
static
static
static

int
int
int
int

SOLD_OUT = 0;
NO_QUARTER = 1;
HAS_QUARTER = 2;
SOLD = 3;

int state = SOLD_OUT;

3

Here’s each state represented
as a unique integer...

...and here’s an instance variable that holds the
current state. We’ll go ahead and set it to
“Sold Out” since the machine will be unfilled when
it’s first taken out of its box and turned on.

Now we gather up all the actions that can happen in the system:

turns crank
inserts quarter
ejects quarter
dispense
of these
Looking at the diagram, invoking any
actions causes a state transition.
388

al.

Here are the states - four in tot

These actions are
the gumball machine’s
interface - the things
you can do with it.

Dispense is more of an internal
action the machine invokes on itself.

Chapter 10
Download at WoweBook.Com

the state pattern
4

Now we create a class that acts as the state machine. For each action,
we create a method that uses conditional statements to determine
what behavior is appropriate in each state. For instance, for the insert
quarter action, we might write a method like this:

public void insertQuarter() {
if (state == HAS_QUARTER) {
System.out.println(“You can’t insert another quarter”);
} else if (state == SOLD_OUT) {

Each possible
state is checked
with a conditional
statement...

System.out.println(“You can’t insert a quarter, the machine is sold out”);
} else if (state == SOLD) {
System.out.println(“Please wait, we’re already giving you a gumball”);
} else if (state == NO_QUARTER) {
state = HAS_QUARTER;
System.out.println(“You inserted a quarter”);

e appropriate
...and exhibits thch possible state...
behavior for ea

}
}

...but can also transition to other
states, just as depicted in the diagram.
Here we’re talking
about a common technique:
modeling state within an object
by creating an instance variable to hold
the state values and writing conditional
code within our methods to handle
the various states.

With that quick review, let’s go implement the Gumball Machine!
you are here 4
Download at WoweBook.Com

389

implement the gumball machine

Writing the code
It’s time to implement the Gumball Machine. We know we’re going to have an instance
variable that holds the current state. From there, we just need to handle all the actions,
behaviors and state transitions that can happen. For actions, we need to implement inserting
a quarter, removing a quarter, turning the crank and dispensing a gumball; we also have the
empty gumball condition to implement as well.

public class GumballMachine {
ﬁnal
ﬁnal
ﬁnal
ﬁnal

static
static
static
static

int
int
int
int

SOLD_OUT = 0;
NO_QUARTER = 1;
HAS_QUARTER = 2;
SOLD = 3;

the
states; they match
Here are the fourGumball’s state diagram.
states in Mighty
going to
Here’s the instance variable that is re in.
we’
keep track of the current state
We start in the SOLD_OUT state.

int state = SOLD_OUT;
int count = 0;
public GumballMachine(int count) {
this.count = count;
if (count > 0) {
state = NO_QUARTER;
}
}

We have a second instance variable that
keeps track of the number of gumballs in
the machine.
The constructor takes an initial
inventory of gumballs. If the inventory
isn’t zero, the machine enters state
NO_QUARTER, meaning it is waiting for
someone to insert a quarter, otherwise it
stays in the SOLD_OUT state.

nting
Now we start impleme s....
od
th
me
the actions as

When a quarter is inserted, if....
a quarter is already inserted
public void insertQuarter() {
we tell the customer;
if (state == HAS_QUARTER) {
System.out.println(“You can’t insert another quarter”);
otherwise we accept the
} else if (state == NO_QUARTER) {
quarter and transition to the
state = HAS_QUARTER;
HAS_QUARTER state.
System.out.println(“You inserted a quarter”);
} else if (state == SOLD_OUT) {
System.out.println(“You can’t insert a quarter, the machine is sold out”);
} else if (state == SOLD) {
System.out.println(“Please wait, we’re already giving you a gumball”);
}
}

390

If the customer just bought a
gumball he needs to wait until the
transaction is complete before
inserting another quarter.
Chapter 10
Download at WoweBook.Com

and if the machine is sold
out, we reject the quarter.

the state pattern

customer tries to remove the quarter...

Now, if the
public void ejectQuarter() {
If there is a quarter, we
if (state == HAS_QUARTER) {
return it and go back to
System.out.println(“Quarter returned”);
the NO_QUARTER state.
state = NO_QUARTER;
} else if (state == NO_QUARTER) {
Otherwise, if there isn’t
System.out.println(“You haven’t inserted a quarter”);
one we can’t give it back.
} else if (state == SOLD) {
System.out.println(“Sorry, you already turned the crank”);
} else if (state == SOLD_OUT) {
System.out.println(“You can’t eject, you haven’t inserted a quarter yet”);
}
}
You can’t eject if the machine is sold
If the customer just

out, it doesn’t accept quarters!

The customer tries to turn the crank...

turned the crank, we can’t
give a refund; he already
has the gumball!

public void turnCrank() {
Someone’s trying to cheat the machine.
if (state == SOLD) {
System.out.println(“Turning twice doesn’t get you another gumball!”);
} else if (state == NO_QUARTER) {
We need a
System.out.println(“You turned but there’s no quarter”);
first.
quarter
} else if (state == SOLD_OUT) {
System.out.println(“You turned, but there are no gumballs”);
We can’t deliver
} else if (state == HAS_QUARTER) {
gumballs; there
System.out.println(“You turned...”);
state = SOLD;
are none.
dispense();
Success! They get a gumball. Change
}
state to SOLD and call the
the
}
dispense a gumball.

Called to

machine’s dispense() method.

public void dispense() {
We’re in the ve
if (state == SOLD) {
SOLD state; gi
System.out.println(“A gumball comes rolling out the slot”);
‘em a gumball!
count = count - 1;
if (count == 0) {
e handle the
System.out.println(“Oops, out of gumballs!”);
Here’s where w ” condition:
state = SOLD_OUT;
“out of gumballs last one, we
} else {
If this was the ’s state to
state = NO_QUARTER;
set the machine herwise, we’re
}
SOLD_OUT; otving a quarter.
} else if (state == NO_QUARTER) {
back to not ha
System.out.println(“You need to pay ﬁrst”);
} else if (state == SOLD_OUT) {
None of these should
System.out.println(“No gumball dispensed”);
ever happen, but if
} else if (state == HAS_QUARTER) {
they
do, we give ‘em an
System.out.println(“No gumball dispensed”);
error,
not a gumball.
}
}
// other methods here like toString() and reﬁll()
}
you are here 4
Download at WoweBook.Com

391

test the gumball machine

In-house testing
That feels like a nice solid design using a well-thought out methodology doesn’t
it? Let’s do a little in-house testing before we hand it off to Mighty Gumball to
be loaded into their actual gumball machines. Here’s our test harness:

Load it up with
gumballs total.

public class GumballMachineTestDrive {
five
public static void main(String[] args) {
GumballMachine gumballMachine = new GumballMachine(5);
System.out.println(gumballMachine);
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
System.out.println(gumballMachine);
gumballMachine.insertQuarter();
gumballMachine.ejectQuarter();
gumballMachine.turnCrank();
System.out.println(gumballMachine);
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
gumballMachine.ejectQuarter();

Print out the state of the machine.
Throw a quarter in...
Turn the crank; we should get our gumball.

Print out the state of the machine, again.
Throw a quarter in...
Ask for it back.
Turn the crank; we shouldn’t get our gumball.
Print out the state of the machine, again.
Throw a quarter in...
Turn the crank; we should get our gumball
Throw a quarter in...
Turn the crank; we should get our gumball
Ask for a quarter back we didn’t put in.

System.out.println(gumballMachine);
gumballMachine.insertQuarter();
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
System.out.println(gumballMachine);

Print out the state of the machine, again.
Throw TWO quarters in...
Turn the crank; we should get our gumball.
Now for the stress testing...
Print that machine state one more time.

}
}

392

Chapter 10
Download at WoweBook.Com

the state pattern

File Edit Window Help mightygumball.com

%java GumballMachineTestDrive
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 5 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
A gumball comes rolling out the slot
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 4 gumballs
Machine is waiting for quarter
You inserted a quarter
Quarter returned
You turned but there’s no quarter
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 4 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
A gumball comes rolling out the slot
You inserted a quarter
You turned...
A gumball comes rolling out the slot
You haven’t inserted a quarter
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 2 gumballs
Machine is waiting for quarter
You inserted a quarter
You can’t insert another quarter
You turned...
A gumball comes rolling out the slot
You inserted a quarter
You turned...
A gumball comes rolling out the slot
Oops, out of gumballs!
You can’t insert a quarter, the machine is sold out
You turned, but there are no gumballs
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 0 gumballs
Machine is sold out

you are here 4
Download at WoweBook.Com

393

gumball buying game

You knew it was coming... a change request!
Mighty Gumball, Inc. has loaded your code into their newest machine and their quality assurance experts are putting
it through its paces. So far, everything’s looking great from
their perspective.
In fact, things have gone so smoothly they’d like to take
things to the next level...

We think that by turning
“gumball buying” into a game we
can signiﬁcantly increase our
sales. We’re going to put one of
these stickers on every machine.
We’re so glad we’ve got Java
in the machines because this is
going to be easy, right?

ner!
Be a WinTen
One in E
get a FRE L
GUMBAL

nner!
i
W
a
Be
Ten
One in E
RE
get a F L
AL
GUMB
CEO, Mighty
Gumball, Inc.
JawBreaker or
Gumdrop?
Gumballs
394

e,
10% of the tim
k
an
when the cr
is turned, the two
customer gets
gumballs instead
of one.

Chapter 10
Download at WoweBook.Com

the state pattern

Design Puzzle
Draw a state diagram for a Gumball Machine that handles the 1 in 10
contest. In this contest, 10% of the time the Sold state leads to two
balls being released, not one. Check your answer with ours (at the
end of the chapter) to make sure we agree before you go further...

Mighty Gumball, Inc.
Where the Gumball Machine
is Never Half Empty

Use Mighty Gumball’s stationary to draw your state diagram.

you are here 4
Download at WoweBook.Com

395

things get messy

The messy STATE of things...
Just because you’ve written your gumball machine using a well-thought out methodology doesn’t
mean it’s going to be easy to extend. In fact, when you go back and look at your code and think
about what you’ll have to do to modify it, well...

ﬁnal
ﬁnal
ﬁnal
ﬁnal

static
static
static
static

int
int
int
int

SOLD_OUT = 0;
NO_QUARTER = 1;
HAS_QUARTER = 2;
SOLD = 3;

public void insertQuarter() {
// insert quarter code here
}
public void ejectQuarter() {
// eject quarter code here
}
public void turnCrank() {
// turn crank code here
}

NER state
First, you’d have to add a new WIN
here. That isn’t too bad...

in
... but then, you’d have to add a new conditional e;
stat
every single method to handle the WINNER
that’s a lot of code to modify.

turnCrank() will get especially messy, because
you’d have to add code to check to see whether
you’ve got a WINNER and then switch to either
the WINNER state or the SOLD state.

public void dispense() {
// dispense code here
}

Sharpen your pencil
Which of the following describe the state of our implementation?
(Choose all that apply.)

❏ A. This code certainly isn’t adhering to the
Open Closed Principle.

❏ B. This code would make a FORTRAN
programmer proud.

❏ C. This design isn’t even very object
oriented.

❏ C. State transitions aren’t explicit; they
are buried in the middle of a bunch of
conditional statements.

❏ D. We haven’t encapsulated anything that
varies here.

❏ E. Further additions are likely to cause bugs
in working code.

396

Chapter 10
Download at WoweBook.Com

the state pattern

Okay, this isn’t good. I think
our ﬁrst version was great, but
it isn’t going to hold up over time as Mighty
Gumball keeps asking for new behavior. The
rate of bugs is just going to make us look
bad, not to mention that CEO will drive
us crazy.

Joe: You’re right about that! We need to refactor this code so that it’s easy
to maintain and modify.
Anne: We really should try to localize the behavior for each state so that if
we make changes to one state, we don’t run the risk of messing up the other
code.
Joe: Right; in other words, follow that ol’ “encapsulate what varies”
principle.
Anne: Exactly.
Joe: If we put each state’s behavior in its own class, then every state just
implements its own actions.
Anne: Right. And maybe the Gumball Machine can just delegate to the
state object that represents the current state.
Joe: Ah, you’re good: favor composition... more principles at work.
Anne: Cute. Well, I’m not 100% sure how this is going to work, but I think
we’re on to something.
Joe: I wonder if this will this make it easier to add new states?
Anne: I think so... We’ll still have to change code, but the changes will be
much more limited in scope because adding a new state will mean we just
have to add a new class and maybe change a few transitions here and there.
Joe: I like the sound of that. Let’s start hashing out this new design!

you are here 4
Download at WoweBook.Com

397

a new state design

The new design
It looks like we’ve got a new plan: instead of maintaining our existing code, we’re going to
rework it to encapsulate state objects in their own classes and then delegate to the current
state when an action occurs.
We’re following our design principles here, so we should end up with a design that is easier to
maintain down the road. Here’s how we’re going to do it:
1

First, we’re going to deﬁne a State interface that
contains a method for every action in the Gumball
Machine.

2

Then we’re going to implement a State class for
every state of the machine. These classes will be
responsible for the behavior of the machine when it
is in the corresponding state.

3

Finally, we’re going to get rid of all of our conditional
code and instead delegate to the state class to do
the work for us.

Not only are we following design principles, as you’ll see, we’re actually implementing the
State Pattern. But we’ll get to all the ofﬁcial State Pattern stuff after we rework our code...

Now we’re going
put all the behavior of a
state into one class. That way,
we’re localizing the behavior and
making things a lot easier to
change and understand.

398

Chapter 10
Download at WoweBook.Com

the state pattern

Defining the State interfaces and classes
First let’s create an interface for State, which all our states implement:
map directly
Here’s the interface for all states. The methodshine (these are
Mac
to actions that could happen to the Gumball
the same methods as in the previous code).

<<interface>>

Then take each state in our design
and encapsulate it in a class that
implements the State interface.

To figure out what
states we need, we look
at our previous code...

State
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

SoldState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

public class GumballMachine {
ﬁnal
ﬁnal
ﬁnal
ﬁnal

static
static
static
static

int
int
int
int

SOLD_OUT = 0;
NO_QUARTER = 1;
HAS_QUARTER = 2;
SOLD = 3;

int state = SOLD_OUT;
int count = 0;

NoQuarterState

SoldOutState

insertQuarter()
ejectQuarter()
turnCrank()
dispense()

insertQuarter()
ejectQuarter()
turnCrank()
dispense()

HasQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

... and we map each state
directly to a class.

Don’t forget, we need a new “winner” state too
that implements the state interface. We’ll come
back to this after we reimplement the first
version of the Gumball Machine.
WinnerState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

you are here 4
Download at WoweBook.Com

399

what are all the states?

Sharpen your pencil

To implement our states, we ﬁrst need to specify the behavior of the classes
when each action is called. Annotate the diagram below with the behavior of
each action in each class; we’ve already ﬁlled in a few for you.

Go to HasQuarterState
Tell the customer, “You haven’t inserted a quarter.”

NoQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

HasQuarterState
insertQuarter()
ejectQuarter()

Go to SoldState

turnCrank()
dispense()

Tell the customer, “Please wait, we’re already giving you a gumball.”

SoldState
insertQuarter()
ejectQuarter()

Dispense one gumball. Check number of gumballs; if > 0, go
to NoQuarterState, otherwise, go to SoldOutState

turnCrank()
dispense()

SoldOutState

Tell the customer, “There are no gumballs.”

insertQuarter()
ejectQuarter()
turnCrank()
dispense()

WinnerState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

Go ahead and fill this out even though we’re implementing it later.
400

Chapter 10
Download at WoweBook.Com

the state pattern

Implementing our State classes
Time to implement a state: we know what behaviors we want; we just need to get it down in code. We’re going to
closely follow the state machine code we wrote, but this time everything is broken out into different classes.
Let’s start with the NoQuarterState:

rface.

ement the State inte

First we need to impl

public class NoQuarterState implements State {
GumballMachine gumballMachine;

We get passed a reference to
the Gumball Machine through the
constructor. We’re just going to
stash this in an instance variable.

If someone inserts a quarter,
we print a message saying the
quarter was accepted and then
change the machine’s state to
the HasQuarterState.

public NoQuarterState(GumballMachine gumballMachine) {
this.gumballMachine = gumballMachine;
}

public void insertQuarter() {
System.out.println(“You inserted a quarter”);
gumballMachine.setState(gumballMachine.getHasQuarterState());
}
public void ejectQuarter() {
System.out.println(“You haven’t inserted a quarter”);
}
public void turnCrank() {
System.out.println(“You turned, but there’s no quarter”);
}
public void dispense() {
System.out.println(“You need to pay ﬁrst”);
}
}

You’ll see how these
work in just a sec...

You can’t get money
back if you never gave
it to us!
And, you can’t get a gumball
if you don’t pay us.

We can’t be dispensing
gumballs without payment.

What we’re doing is
implementing the behaviors
that are appropriate for the
state we’re in. In some cases, this
behavior includes moving the
Gumball Machine to a new state.

you are here 4
Download at WoweBook.Com

401

state objects in the gumball machine

Reworking the Gumball Machine
Before we finish the State classes, we’re going to rework the Gumball Machine – that way
you can see how it all fits together. We’ll start with the state-related instance variables
and switch the code from using integers to using state objects:

public class GumballMachine {
ﬁnal
ﬁnal
ﬁnal
ﬁnal

static
static
static
static

int
int
int
int

, we update the
In the GumballMachiwneclasses rather than
code to use the ne . The code is quite
the static integersat in one class we have
similar, except th e other objects...
integers and in th

SOLD_OUT = 0;
NO_QUARTER = 1;
HAS_QUARTER = 2;
SOLD = 3;

int state = SOLD_OUT;
int count = 0;

Old code

public class GumballMachine {
State
State
State
State

New code

soldOutState;
noQuarterState;
hasQuarterState;
soldState;

State state = soldOutState;
int count = 0;

All the State objects are created
and assigned in the constructor.

402

Chapter 10
Download at WoweBook.Com

This now holds a
State object, not
an integer.

the state pattern

Now, let’s look at the complete GumballMachine class...

es again...
Here are all the Stat
State soldOutState;
...and the State instance variable.
State noQuarterState;
State hasQuarterState;
The count instance variable holds
State soldState;
the count of gumballs – initially the
machine is empty.
State state = soldOutState;
int count = 0;
s the
Our constructor tagukemballs and
of
public GumballMachine(int numberGumballs) {
initial number
ce variable.
soldOutState = new SoldOutState(this);
stores it in an instan
noQuarterState = new NoQuarterState(this);
State
hasQuarterState = new HasQuarterState(this);
It also creates theae ch.
soldState = new SoldState(this);
instances, one of

public class GumballMachine {

this.count = numberGumballs;
if (numberGumballs > 0) {
state = noQuarterState;
}

If there are more than 0
gumballs we set the state to the
NoQuarterState.
ns. These awre. We
io
t
c
a
e
h
t
r
o
no
Now f
to implement
VERY EASYe to the current state.
just delegat

}
public void insertQuarter() {
state.insertQuarter();
}
public void ejectQuarter() {
state.ejectQuarter();
}

Note that we don’t need an
action method for dispense() in
GumballMachine because it’s just an
internal action; a user can’t ask the
machine to dispense directly. But we
do call dispense() on the State object
from the turnCrank() method.

public void turnCrank() {
state.turnCrank();
state.dispense();
}
void setState(State state) {
this.state = state;
}

This method allows other objects (like
our State objects) to transition the
machine to a different state.

void releaseBall() {
System.out.println(“A gumball comes rolling out the slot...”);
if (count != 0) {
count = count - 1;
The machine supports a releaseBall()
}
helper method that releases the ball
}

and
decrements the count instance variable.

// More methods here including getters for each State...
}

This includes methods like getNoQuarterState() for getting each
state object, and getCount() for getting the gumball count.
you are here 4
Download at WoweBook.Com

403

more states for the gumball machine

Implementing more states
Now that you’re starting to get a feel for how the Gumball Machine and the states
ﬁt together, let’s implement the HasQuarterState and the SoldState classes...

public class HasQuarterState implements State {
GumballMachine gumballMachine;
public HasQuarterState(GumballMachine gumballMachine) {
this.gumballMachine = gumballMachine;
}

ted
te is instantia
When the stareference to the
we pass it a hine. This is used
GumballMac n the machine to a
to transitio ate.
different st

public void insertQuarter() {
System.out.println(“You can’t insert another quarter”);
}
public void ejectQuarter() {
System.out.println(“Quarter returned”);
gumballMachine.setState(gumballMachine.getNoQuarterState());
}
public void turnCrank() {
System.out.println(“You turned...”);
gumballMachine.setState(gumballMachine.getSoldState());
}
public void dispense() {
System.out.println(“No gumball dispensed”);
}
}

Another e
inappropriatthis
action for
state.

404

Chapter 10
Download at WoweBook.Com

te
An inapproprtiahis
r
action fo
state.
Return the customer’s
quarter and
transition back to the
NoQuarterState.
When the crank is
turned we transition
the machine to the
SoldState state by
calling its setState()
method and passing it
the SoldState object.
The SoldState object
is retrieved by the
getSoldState()
getter method
(there is one of these
getter methods for
each state).

the state pattern

he
Here are all et
inappropriat this
actions for
state

Now, let’s check out the SoldState class...
public class SoldState implements State {
//constructor and instance variables here

public void insertQuarter() {
System.out.println(“Please wait, we’re already giving you a gumball”);
}
public void ejectQuarter() {
System.out.println(“Sorry, you already turned the crank”);
}
public void turnCrank() {
System.out.println(“Turning twice doesn’t get you another gumball!”);
}
public void dispense() {
gumballMachine.releaseBall();
if (gumballMachine.getCount() > 0) {
gumballMachine.setState(gumballMachine.getNoQuarterState());
} else {
System.out.println(“Oops, out of gumballs!”);
gumballMachine.setState(gumballMachine.getSoldOutState());
}
}
}

ere the
And here’s wehgins...
real work b

h
oldState, whSico,
S
e
h
t
in
e
’r
e
W
tomer paid.
means the ceusd to ask the
we first ne release a gumball.
machine to

at
he machine wehither
t
sk
a
e
w
n
e
h
T
unt is, and
the gumball coothe NoQuarterState
transition t OutState.
or the Sold

A

brain
power
Look back at the GumballMachine implementation. If the crank is turned and not successful (say
the customer didn’t insert a quarter ﬁrst), we call dispense anyway, even though it’s unnecessary.
How might you ﬁx this?

you are here 4
Download at WoweBook.Com

405

your turn to implement a state

Sharpen your pencil

We have one remaining class we haven’t implemented: SoldOutState.
Why don’t you implement it? To do this, carefully think through how
the Gumball Machine should behave in each situation. Check your
answer before moving on...

public class SoldOutState implements State
GumballMachine gumballMachine;

{

public SoldOutState(GumballMachine gumballMachine) {

}
public void insertQuarter() {

}
public void ejectQuarter() {

}
public void turnCrank() {

}
public void dispense() {

}
}

406

Chapter 10
Download at WoweBook.Com

the state pattern

Let’s take a look at what we’ve done so far...
For starters, you now have a Gumball Machine implementation that is structurally quite different from your
ﬁrst version, and yet functionally it is exactly the same. By structurally changing the implemention you’ve:

ß Localized the behavior of each state into its own class.
ß Removed all the troublesome if statements that would have been difﬁcult to maintain.
ß Closed each state for modiﬁcation, and yet left the Gumball Machine open to extension by
adding new state classes (and we’ll do this in a second).

ß Created a code base and class structure that maps much more closely to the Mighty Gumball
diagram and is easier to read and understand.
Now let’s look a little more at the functional aspect of what we did:

lds an
achine now hsso .
M
ll
a
b
um
G
e
Th
ch State cla
instance of ea

Gum ba ll M achi ne St ates

No
Quarter

current state

i
allMach

ne

Gu
mb

The current state of the
machine is always one of
these class instances.

Ha

sQuarte

r

S old

SoldOut

you are here 4
Download at WoweBook.Com

407

state transitions

When an action is called, it is
delegated to the current state.

Gum bal l Machi ne States

turnCrank()

turnCrank()

No
Quarter

current state
Ha

i
allMach

ne

Gu
mb

sQuarte

r

S old

In this case the turnCrank()
method is being called when the
machine is in the HasQuarter
state, so as a result the machine
transitions to the Sold state.

SoldOut

TRANSITION TO SOLD STATE
enters
The machineate and a
the Sold st ispensed...
gumball is d

Gum bal l Machi ne States

dispense()

ren

i
allMach

ne

Gu
mb

cur

t st

ate

No
Quarter

Ha

sQuarte

r

S old

s

more gumball

....and then the
machine will
either go to
the SoldOut
or NoQuarter
state depending
on the number of
gumballs remaining
in the machine.
sold out

SoldOut

408

Chapter 10
Download at WoweBook.Com

the state pattern

Behind the Scenes:
Self-Guided Tour

Sharpen your pencil

Trace the steps of the Gumball Machine starting with the NoQuarter state. Also annotate the diagram with actions
and output of the machine. For this exercise you can assume there are plenty of gumballs in the machine.
2

1
Gum ball Machine States

Gum ball Machine States

No
Quarter

3

Ha

sQuarte

r

Gu
mb

i
allMach

ne

i
allMach

ne

Gu
mb

No
Quarter

S old

SoldOut

SoldOut

Gum ball Machine States

4

Ha

sQuarte

r

r

Gum ball Machine States

No
Quarter

Gu
mb

i
allMach

ne

ne

i
allMach

sQuarte

S old

No
Quarter

Gu
mb

Ha

Ha

sQuarte

S old

S old

SoldOut

SoldOut

r

you are here 4
Download at WoweBook.Com

409

state pattern deﬁned

The State Pattern defined
Yes, it’s true, we just implemented the State Pattern! So now, let’s take a look at what it’s all about:
The State Pattern allows an object to alter its behavior
when its internal state changes. The object will appear to
change its class.

The ﬁrst part of this description makes a lot of sense, right? Because the pattern encapsulates state into
separate classes and delegates to the object representing the current state, we know that behavior changes
along with the internal state. The Gumball Machine provides a good example: when the gumball machine
is in the NoQuarterState and you insert a quarter, you get different behavior (the machine accepts the
quarter) than if you insert a quarter when it’s in the HasQuarterState (the machine rejects the quarter).
What about the second part of the deﬁnition? What does it mean for an object to “appear to change its
class?” Think about it from the perspective of a client: if an object you’re using can completely change its
behavior, then it appears to you that the object is actually instantiated from another class. In reality, however,
you know that we are using composition to give the appearance of a class change by simply referencing
different state objects.
Okay, now it’s time to check out the State Pattern class diagram:

The State interface defines a common
interface for all concrete states; the
states all implement the same interface,
so they are interchangeable.

The Context is the class that
can have a number of internal
states. In our example, the
GumballMachine is the Context.

State

Context
request()

state.handle()

handle()

Whenever the request()
is made on the Context
it is delegated to the
state to handle.

410

ConcreteStateB

ConcreteStateA
handle()

handle()

Many concrete
states are poss
ible

.

the
ConcreteStates handle requests from its
s
vide
pro
ate
eSt
cret
Con
Context. Each
own implementation for a request. In this
its
way, when the Context changes state,
.
well
as
nge
behavior will cha

Chapter 10
Download at WoweBook.Com

the state pattern

Wait a sec,
from what I remember
of the Strategy Pattern,
this class diagram is
EXACTLY the same.

You’ve got a good eye! Yes, the class diagrams are essentially the
same, but the two patterns differ in their intent.
With the State Pattern, we have a set of behaviors encapsulated in
state objects; at any time the context is delegating to one of those
states. Over time, the current state changes across the set of state
objects to reﬂect the internal state of the context, so the context’s
behavior changes over time as well. The client usually knows very
little, if anything, about the state objects.
With Strategy, the client usually speciﬁes the strategy object that
the context is composed with. Now, while the pattern provides the
ﬂexibility to change the strategy object at runtime, often there is a
strategy object that is most appropriate for a context object. For
instance, in Chapter 1, some of our ducks were conﬁgured to ﬂy
with typical ﬂying behavior (like mallard ducks), while others were
conﬁgured with a ﬂy behavior that kept them grounded (like rubber
ducks and decoy ducks).
In general, think of the Strategy Pattern as a ﬂexible alternative to
subclassing; if you use inheritance to deﬁne the behavior of a class,
then you’re stuck with that behavior even if you need to change it.
With Strategy you can change the behavior by composing with a
different object.
Think of the State Pattern as an alternative to putting lots of
conditionals in your context; by encapsulating the behaviors within
state objects, you can simply change the state object in context to
change its behavior.

you are here 4
Download at WoweBook.Com

411

q&a about the state pattern

there are no

Q:

Dumb Questions

unique instance per context.

In the GumballMachine, the states decide
what the next state should be. Do the ConcreteStates
always decide what state to go to next?

A:

No, not always. The alternative is to let the Context
decide on the flow of state transitions.
As a general guideline, when the state transitions are fixed
they are appropriate for putting in the Context; however,
when the transitions are more dynamic, they are typically
placed in the state classes themselves (for instance, in the
GumballMachine the choice of the transition to NoQuarter or
SoldOut depended on the runtime count of gumballs).
The disadvantage of having state transitions in the state
classes is that we create dependencies between the state
classes. In our implementation of the GumballMachine
we tried to minimize this by using getter methods on the
Context, rather than hardcoding explicit concrete state
classes.
Notice that by making this decision, you are making a
decision as to which classes are closed for modification
– the Context or the state classes – as the system evolves.

Q:

Do clients ever interact directly with the
states?

A:

No. The states are used by the Context to
represent its internal state and behavior, so all requests
to the states come from the Context. Clients don’t directly
change the state of the Context. It is the Context’s job
to oversee its state, and you don’t usually want a client
changing the state of a Context without that Context’s
knowledge.

Q:

If I have lots of instances of the Context in my
application, is it possible to share the state objects
across them?

A:

Yes, absolutely, and in fact this is a very common
scenario. The only requirement is that your state objects do
not keep their own internal state; otherwise, you’d need a

412

To share your states, you’ll typically assign each state to a
static instance variable. If your state needs to make use of
methods or instance variables in your Context, you’ll also
have to give it a reference to the Context in each handler()
method.

Q:

It seems like using the State Pattern always
increases the number of classes in our designs. Look
how many more classes our GumballMachine had
than the original design!

A:

You’re right, by encapsulating state behavior
into separate state classes, you’ll always end up with
more classes in your design. That’s often the price you
pay for flexibility. Unless your code is some “one off”
implementation you’re going to throw away (yeah, right),
consider building it with the additional classes and you’ll
probably thank yourself down the road. Note that often
what is important is the number of classes that you expose
to your clients, and there are ways to hide these extra
classes from your clients (say, by declaring them package
visible).
Also, consider the alternative: if you have an application
that has a lot of state and you decide not to use separate
objects, you’ll instead end up with very large, monolithic
conditional statements. This makes your code hard to
maintain and understand. By using objects, you make
states explicit and reduce the effort needed to understand
and maintain your code.

Q:

The State Pattern class diagram shows
that State is an abstract class. But didn’t you use
an interface in the implementation of the gumball
machine’s state?

A:

Yes. Given we had no common functionality to
put into an abstract class, we went with an interface. In
your own implementation, you might want to consider an
abstract class. Doing so has the benefit of allowing you to
add methods to the abstract class later, without breaking the
concrete state implementations.

Chapter 10
Download at WoweBook.Com

the state pattern

We still need to finish the Gumball 1 in 10 game
Remember, we’re not done yet. We’ve got a game to implement; but now that we’ve got the State
Pattern implemented, it should be a breeze. First, we need to add a state to the GumballMachine class:
public class GumballMachine {
State
State
State
State
State

soldOutState;
noQuarterState;
hasQuarterState;
soldState;
winnerState;

State state = soldOutState;
int count = 0;
// methods here
}

All you need to add here is the
new WinnerState and initialize
it in the constructor.
Don’t forget you also have
to add a getter method for
WinnerState too.

Now let’s implement the WinnerState class itself, it’s remarkably similar to the SoldState class:
public class WinnerState implements State {

e.

Just like SoldStat

// instance variables and constructor
// insertQuarter error message
// ejectQuarter error message
// turnCrank error message

Here we release two gumballs and then
either go to the NoQuarterState or the
SoldOutState.

public void dispense() {
System.out.println(“YOU’RE A WINNER! You get two gumballs for your quarter”);
gumballMachine.releaseBall();
if (gumballMachine.getCount() == 0) {
gumballMachine.setState(gumballMachine.getSoldOutState());
} else {
gumballMachine.releaseBall();
As long as we
if (gumballMachine.getCount() > 0) {
have a second
gumballMachine.setState(gumballMachine.getNoQuarterState());
gumball we
} else {
release it.
System.out.println(“Oops, out of gumballs!”);
gumballMachine.setState(gumballMachine.getSoldOutState());
}
}
}
}
you are here 4
Download at WoweBook.Com

413

implementing the 1 in 10 game

Finishing the game
We’ve just got one more change to make: we need to implement the random
chance game and add a transition to the WinnerState. We’re going to add both to
the HasQuarterState since that is where the customer turns the crank:

public class HasQuarterState implements State {
Random randomWinner = new Random(System.currentTimeMillis());
GumballMachine gumballMachine;
public HasQuarterState(GumballMachine gumballMachine) {
this.gumballMachine = gumballMachine;
}

First we add a
random number
generator to
generate the 10% ..
chance of winning.

public void insertQuarter() {
System.out.println(“You can’t insert another quarter”);
}
public void ejectQuarter() {
System.out.println(“Quarter returned”);
gumballMachine.setState(gumballMachine.getNoQuarterState());
}
public void turnCrank() {
System.out.println(“You turned...”);
int winner = randomWinner.nextInt(10);
if ((winner == 0) && (gumballMachine.getCount() > 1)) {
gumballMachine.setState(gumballMachine.getWinnerState());
} else {
gumballMachine.setState(gumballMachine.getSoldState());
}
}
public void dispense() {
System.out.println(“No gumball dispensed”);
}
}

...then we determine
if this customer won.

If they won, and there’s
enough gumballs left for
them to get two, we
go to the WinnerState;
otherwise, we go to the
SoldState (just like we
always did).

Wow, that was pretty simple to implement! We just added a new state to the GumballMachine
and then implemented it. All we had to do from there was to implement our chance game and
transition to the correct state. It looks like our new code strategy is paying off...

414

Chapter 10
Download at WoweBook.Com

the state pattern

Demo for the CEO of Mighty Gumball, Inc.
The CEO of Mighty Gumball has dropped by for a demo of your new gumball game code. Let’s
hope those states are all in order! We’ll keep the demo short and sweet (the short attention span of
CEOs is well documented), but hopefully long enough so that we’ll win at least once.

’t changed at all;
This code really hasn
a bit.
we just shortened it

Once, again, start with a gumball
with 5 gumballs.

public class GumballMachineTestDrive {
machine
public static void main(String[] args) {
GumballMachine gumballMachine = new GumballMachine(5);
System.out.println(gumballMachine);
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
System.out.println(gumballMachine);
gumballMachine.insertQuarter();
gumballMachine.turnCrank();
gumballMachine.insertQuarter();
gumballMachine.turnCrank();

We want to get a winning state,
so we just keep pumping in those
quarters and turning the crank. We
print out the state of the gumball
machine every so often...

System.out.println(gumballMachine);
}
}

team is waiting
The whole engineerinengce room to see
outside the confer ttern-based
if the new State Park!!
design is going to wo

you are here 4
Download at WoweBook.Com

415

testing the gumball machine

Yes! That rocks!

File Edit Window Help Whenisagumballajawbreaker?

%java GumballMachineTestDrive
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 5 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
YOU’RE A WINNER! You get two gumballs for your quarter
A gumball comes rolling out the slot...
A gumball comes rolling out the slot...
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 3 gumballs
Machine is waiting for quarter

y or what?
Gee, did we get luck
O, we
In our demo to thetwCEice!
won not once, but

You inserted a quarter
You turned...
A gumball comes rolling out the slot...
You inserted a quarter
You turned...
YOU’RE A WINNER! You get two gumballs for your quarter
A gumball comes rolling out the slot...
A gumball comes rolling out the slot...
Oops, out of gumballs!
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 0 gumballs
Machine is sold out
%

there are no

Dumb Questions

Q:
A:

Why do we need the WinnerState? Couldn’t we just have the SoldState dispense two gumballs?

That’s a great question. SoldState and WinnerState are almost identical, except that WinnerState dispenses two
gumballs instead of one. You certainly could put the code to dispense two gumballs into the SoldState. The downside
is, of course, that now you’ve got TWO states represented in one State class: the state in which you’re a winner, and the
state in which you’re not. So you are sacrificing clarity in your State class to reduce code duplication. Another thing to
consider is the principle you learned in the previous chapter: One class, One responsibility. By putting the WinnerState
responsibility into the SoldState, you’ve just given the SoldState TWO responsibilities. What happens when the
promotion ends? Or the stakes of the contest change? So, it’s a tradeoff and comes down to a design decision.

416

Chapter 10
Download at WoweBook.Com

the state pattern

Bravo! Great job,
gang. Our sales are already going
through the roof with the new game.
You know, we also make soda machines,
and I was thinking we could put one of
those slot machine arms on the side and
make that a game too. We’ve got four
year olds gambling with the gumball
machines; why stop there?

Sanity check...
Yes, the CEO of Mighty Gumball probably needs a sanity check, but that’s
not what we’re talking about here. Let’s think through some aspects of the
GumballMachine that we might want to shore up before we ship the gold version:

ß We’ve got a lot of duplicate code in the Sold and Winning
states and we might want to clean those up. How would we
do it? We could make State into an abstract class and build in
some default behavior for the methods; after all, error messages
like, “You already inserted a quarter,” aren’t going to be seen
by the customer. So all “error response” behavior could be
generic and inherited from the abstract State class.

ß The dispense() method always gets called, even if the crank is

Dammit Jim,
I’m a gumball
machine, not a
computer!

turned when there is no quarter. While the machine operates
correctly and doesn’t dispense unless it’s in the right state, we
could easily ﬁx this by having turnCrank() return a boolean,
or by introducing exceptions. Which do you think is a better
solution?

ß All of the intelligence for the state transitions is in the State
classes. What problems might this cause? Would we want to
move that logic into the Gumball Machine? What would be
the advantages and disadvantages of that?

ß Will you be instantiating a lot of GumballMachine objects?
If so, you may want to move the state instances into static
instance variables and share them. What changes would this
require to the GumballMachine and the States?

you are here 4
Download at WoweBook.Com

417

ﬁreside chats: state and strategy

Tonight: A Strategy and State Pattern Reunion.

Strategy

State

Hey bro. Did you hear I was in Chapter 1?
Yeah, word is deﬁnitely getting around.
I was just over giving the Template Method guys a
hand – they needed me to help them ﬁnish off their
chapter. So, anyway, what is my noble brother up
to?
Same as always – helping classes to exhibit different
behaviors in different states.
I don’t know, you always sound like you’ve just
copied what I do and you’re using different words
to describe it. Think about it: I allow objects to
incorporate different behaviors or algorithms
through composition and delegation. You’re just
copying me.

I admit that what we do is deﬁnitely related, but my
intent is totally different than yours. And, the way I
teach my clients to use composition and delegation
is totally different.

Oh yeah? How so? I don’t get it.

Yeah, that was some ﬁne work... and I’m sure you
can see how that’s more powerful than inheriting
your behavior, right?

Well if you spent a little more time thinking about
something other than yourself, you might. Anyway,
think about how you work: you have a class you’re
instantiating and you usually give it a strategy
object that implements some behavior. Like, in
Chapter 1 you were handing out quack behaviors,
right? Real ducks got a real quack, rubber ducks
got a quack that squeaked.

Yes, of course. Now, think about how I work; it’s
totally different.

Sorry, you’re going to have to explain that.
418

Chapter 10
Download at WoweBook.Com

the state pattern

Strategy

State
Okay, when my Context objects get created, I may
tell them the state to start in, but then they change
their own state over time.

Hey, come on, I can change behavior at runtime
too; that’s what composition is all about!
Sure you can, but the way I work is built around
discrete states; my Context objects change state
over time according to some well deﬁned state
transitions. In other words, changing behavior is
built in to my scheme – it’s how I work!
Well, I admit, I don’t encourage my objects to have
a well-deﬁned set of transitions between states. In
fact, I typically like to control what strategy my
objects are using.
Look, we’ve already said we’re alike in structure, but
what we do is quite different in intent. Face it, the
world has uses for both of us.
Yeah, yeah, keep living your pipe dreams brother.
You act like you’re a big pattern like me, but check
it out: I’m in Chapter 1; they stuck you way out in
Chapter 10. I mean, how many people are actually
going to read this far?

Are you kidding? This is a Head First book and
Head First readers rock. Of course they’re going to
get to Chapter 10!

That’s my brother, always the dreamer.

you are here 4
Download at WoweBook.Com

419

reﬁll exercise

We almost forgot!

spec...
t to put in the originalout
of
There’s one transitionillwethfoe rgo
it’s
en
wh
ne
chi
ball ma
gum
ref
to
y
wa
a
r us?
d
fo
nee
it
we
m - can you implement
gumballs! Here’s the newondiathgrae rest of the gumball machine we
You did such a good jobadd this in a jiffy!
have no doubt you can
s
- The Mighty Gumball Engineer

Mighty Gumball, Inc.
Where the Gumball Machine
is Never Half Empty

refill

gumba

lls =

420

bal

0

ls >

ns

cra

0

ejects q
u

arter

inserts q

No r
u
Q arte
gum

tur

Has r
Quarte

uarter

Out ofalls
Gumb

dispenslle
gumba

Chapter 10
Download at WoweBook.Com

ll
Gumba
Sold

nk

the state pattern

Sharpen your pencil
We need you to write the refill() method for the Gumball machine. It has one
argument − the number of gumballs you’re adding to the machine − and should
update the gumball machine count and reset the machine’s state.

You’ve done some amazing work!
I’ve got some more ideas that
are going to change the gumball
industry and I need you to implement
them. Shhhhh! I’ll let you in on these
ideas in the next chapter.

you are here 4
Download at WoweBook.Com

421

who does what?

Match each pattern with its description:

Pattern
State

422

Description
Encapsulate interchangeable
behaviors and use delegation to
decide which behavior to use

Strategy

Subclasses decide how
to implement steps in an
algorithm

Template Method

Encapsulate state-based
behavior and delegate
behavior to the current state

Chapter 10
Download at WoweBook.Com

the state pattern

Tools for your Design Toolbox
It’s the end of another chapter; you’ve got enough
patterns here to breeze through any job interview!

s
OO Princvaiprilees.

OO Basics

OO Patteinresnafsinfames ilya oofneal-gotori-tmhmnas,anly

ß The State Pattern allows an
object to have many different
behaviors that are based on its
internal state.

Abstraction
n
Encapsulatio
what
Encapsulate
inheritance. Polymorphism
sition over
po
m
co
or
av
F
faces, not
Inheritance
am to inter
Progr ations.
implement
led designs
loosely coup
Strive for jects that interact.
between ob
extension
be open forion.
ld
ou
sh
es
ss
at
Cla
or modific
but closed f
. Do not
abstractions
Depend on concrete classes.
depend on
ds.
o your frien
Only talk t
u.
, we’ll call yo
Don’t call us
reason
ave only one
h
ld
ou
sh
s
A clas .
to change

BULLET POINTS

ß Unlike a procedural state
machine, the State Pattern
represents state as a full-blown
class.

ß The Context gets its behavior
by delegating to the current
state object it is composed
with.

is
inciples th
No new pr hat gives you
chapter, t ep on them.
time to sle

def de
mitPio
oavimtfdicineaeallnya.n
sddso
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
Adntamtocak
batcjeesohcrttayhe
e
e
eits sof
d
go
F
b
o
t
al
ll
es
c
y
c
jeheadtfea,mailtieahm
t
puleeatnAdbensctlebrilc. itatScieotctra
encadpseD
sfyottcreghoM
r
aycanrnlegeeetatosstbhintstleotgha
o
it
t
dsshcootun,tlybuhas est
n
e
a
a
si
le
us
t
n
je
ab
F
la.beitje
g
ib
o
a
b
t
c
ge
x
o
d
in
sp
p
a
an
t
u
a
f
reen inotneerface pfcrroeomviftdoclifrenieiecnt
w
e
s
e
d
r
r
a
s
n
t
su
c
n
inter
g
o
d
je
E
whch
oepoede-ntinidogebfwonhrcviicadehpxesuctaelaes.ntssgdloeinstbal rpeoqinu tuest
lyafsoragrelendt
cnrodeenrelainadntteneSeostdrin
inpdeeep
varydeD
s a rueq
ebscladessdcnd- pEreo class
ss
nleatoaivysu
hsuaem.niracapeFcntoaancectr.r,oert-tyhEeMrnecebatyphsuoledlattleinetseginygaoeryeonqutuest
nlleineybCgtcinolaotstm
auatltomespratetincioicifst
t
it
e
je
h
d
t
b
t
t
o
.
o
le
A
t
y
ia
suhla deifs f fertyeonutalter its
aecnettc,-ialitetEhnioetnrncseawbtpyoit
func noaaflintatscdcaaeesnfssF
st
je
b
d
in
o
a
iz
r
ds,tifincatgnd
n
c
r
e
a
e
a
t
e
m
s.
a
a classpar menttqeuoarebtizujeeeecot-cr,liAetlonllhgtoesrwreewbaqitynuehleostbteje
fnedarteentchange
s,ifl ast
st
d
a
n
u
a
a
h
S
r
q
r
s,
s
e
s.
a
it
a
r
e
t
p
st
w
s.
e
in
ss
g
n
s
u
la
s
t
lo
q
io
c
sub re estms,hdeaoqtviaueoberrleuizeweoohpcrelinreanitt
aanngde its
el raloaptgpioeraners.quteostcs,h
p
o
r
suprpeoqpruatrbuaten st
o
il
le
w
e
b
u
a
e
t
o
u
c
d
q
n
je
u
b
suprpeoqrTuhee os, oable operations.
supcplaorsst. und

Here’s our new
pattern. If you’re
managing state in
a class, the State
Pattern gives you
a technique for
encapsulating that
state.

ß By encapsulating each state
into a class, we localize any
changes that will need to be
made.

ß The State and Strategy
Patterns have the same class
diagram, but they differ in
intent.

ß Strategy Pattern typically
configures Context classes
with a behavior or algorithm.

ß State Pattern allows a Context
to change its behavior as the
state of the Context changes.

ß State transitions can be
controlled by the State classes
or by the Context classes.

ß Using the State Pattern will
typically result in a greater
number of classes in your
design.

ß State classes may be shared
among Context instances.

you are here 4
Download at WoweBook.Com

423

exercise solutions

Exercise solutions

gumballs = 0

tur
have ns cran
a wi k, we
nner
!

lls >

0

Where the Gumball Machine
is Never Half Empty

d
gum ispen
bal se 2
ls

Mighty Gumball, Inc.

Winner

tur

ns

Has
r
u
Q arte

gumba

lls =

424

bal

0

ls >

nk,

0

Chapter 10
Download at WoweBook.Com

ejects

No
r
Quarte
gum

cra

quarter

inserts

quarter

gumba

Out ofalls
Gumb

dispenslel
gumba

ll
Gumba
Sold

no

win

ner

the state pattern

Exercise solutions
Sharpen your pencil
Based on our ﬁrst implementation, which of the following apply?
(Choose all that apply.)

❏ A. This code certainly isn’t adhering to the

❏ C. State transitions aren’t explicit; they
are buried in the middle of a bunch of
conditional code.

Open Closed Principle!

❏ B. This code would make a FORTRAN
programmer proud.

❏ C. This design isn’t even very object
oriented.

❏ D. We haven’t encapsulated anything that
varies here.

❏ E. Further additions are likely to cause bugs
in working code.

Sharpen your pencil

We have one remaining class we haven’t implemented: SoldOutState.
Why don’t you implement it? To do this, carefully think through how
the Gumball Machine should behave in each situation. Check your
answer before moving on...

public class SoldOutState implements State {
GumballMachine gumballMachine;

ally
t state, we re
In the Sold Ou ng until someone
hi
yt
can’t do an ball Machine.
refills the Gum

public SoldOutState(GumballMachine gumballMachine) {
this.gumballMachine = gumballMachine;
}
public void insertQuarter() {
System.out.println(“You can’t insert a quarter, the machine is sold out”);
}
public void ejectQuarter() {
System.out.println(“You can’t eject, you haven’t inserted a quarter yet”);
}
public void turnCrank() {
System.out.println(“You turned, but there are no gumballs”);
}
public void dispense() {
System.out.println(“No gumball dispensed”);
}
}

you are here 4
Download at WoweBook.Com

425

exercise solutions

Sharpen your pencil

To implement the states, we ﬁrst need to deﬁne what the behavior will be
when the corresponding action is called. Annotate the diagram below with the
behavior of each action in each class; we’ve already ﬁlled in a few for you.

Go to HasQuarterState
Tell the customer “you haven’t inserted a quarter”

Tell the customer “you turned, but there’s no quarter”
Tell the customer “you need to pay first”

Tell the customer “you can’t insert another quarter”
Give back quarter, go to No Quarter state
Go to SoldState

NoQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

HasQuarterState
insertQuarter()
ejectQuarter()
turnCrank()

Tell the customer, “no gumball dispensed”

Tell the customer “please wait, we’re already giving you a gumball”
Tell the customer “sorry, you already turned the crank”

Tell the customer “turning twice doesn’t get you another gumball”
Dispense one gumball. Check number of gumballs; if > 0, go
to NoQuarter state, otherwise, go to Sold Out state

dispense()

SoldState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

Tell the customer “the machine is sold out”
Tell the customer “you haven’t inserted a quarter yet”
Tell the customer “There are no gumballs”
Tell the customer “no gumball dispensed”
Tell the customer “please wait, we’re already giving you a gumball”
Tell the customer “sorry, you already turned the crank”

Tell the customer “turning twice doesn’t get you another gumball”
Dispense two gumballs. Check number of gumballs; if > 0,
go to NoQuarter state, otherwise, go to SoldOutState
426

Chapter 10
Download at WoweBook.Com

SoldOutState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

WinnerState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()

the state pattern

Behind the Scenes:
Self-Guided Tour
Solution

delegates to
current state

2
insertQuarter()

t

en
curr

insertQuarter()

No
Quarter

turnCrank()
Ha

i
allMach

machine action

sQuarte

Gum ball Machine States

turnCrank()

No
Quarter

state

ne

Gu
mb

delegates

Gum ball Machine States

r

current state

Gu
mb

Ha

i
allMach

ne

1

machine action

S old

sQuarte

S old

SoldOut

SoldOut

transitions to
HasQuarter state

3

Gum ball Machine States

i
allMach

Here the machine
gives out a gumball
by calling the internal
dispense() action.

ren

4

Gum ball Machine States

t st

ate

Ha

sQuarte

r

tate

nt s

re
cur

Gu
mb

i
allMach

S old

ne

cur

ne

Gu
mb

transitions to
Sold state

No
Quarter

dispense()

r

No
Quarter

Ha

sQuarte

r

S old

SoldOut

and then transitions
to NoQuarter

SoldOut

you are here 4
Download at WoweBook.Com

427

exercise solutions

Match each pattern with its description:

Pattern

Description
Encapsulate interchangeable
behaviors and use delegation to
decide which behavior to use

State

Subclasses decide how
to implement steps in an
algorithm

Strategy

Template Method

Encapsulate state-based
behavior and delegate
behavior to the current state

Sharpen your pencil
We need you to write the reﬁll() method for the Gumball machine. It has one
argument, the number of gumballs you’re adding to the machine, and should
update the gumball machine count and reset the machine’s state.

void reﬁll(int count) {
this.count = count;
state = noQuarterState;
}

428

Chapter 10
Download at WoweBook.Com

11 the Proxy Pattern

Controlling h
g Object Access

g

With you as my Proxy, I’ll be
able to triple the amount of lunch
money I can extract from friends!

Ever play good cop, bad cop? You’re the good cop and you provide all your
services in a nice and friendly manner, but you don’t want everyone asking you for services,
so you have the bad cop control access to you. That’s what proxies do: control and manage
access. As you’re going to see, there are lots of ways in which proxies stand in for the
objects they proxy. Proxies have been known to haul entire method calls over the Internet for
their proxied objects; they’ve also been known to patiently stand in the place for some pretty
lazy objects.

this is a new chapter
Download at WoweBook.Com

429

what’s the goal

Hey team, I’d
really like to get
some better monitoring for
my gumball machines. Can you
ﬁnd a way to get me a report of
inventory and machine state?

Sounds easy enough. If you remember, we’ve already
got methods in the gumball machine code for getting the
count of gumballs (getCount()), and getting the current
state of the machine (getState()).
All we need to do is create a report that can be printed out
and sent back to the CEO. Hmmm, we should probably
add a location ﬁeld to each gumball machine as well; that
way the CEO can keep the machines straight.

Remember the CEO of
Mighty Gumball, Inc.?

430

Let’s just jump in and code this. We’ll impress the CEO
with a very fast turnaround.

Chapter 11
Download at WoweBook.Com

the proxy pattern

Coding the Monitor
Let’s start by adding support to the GumballMachine class so that it
can handle locations:

A location is just a String.

public class GumballMachine {
// other instance variables
String location;

public GumballMachine(String location, int count) {
// other constructor code here
The location is passed into
this.location = location;
}
constructor and stored

instance variable.

public String getLocation() {
return location;
}

the
in the

Let’s also add a getter method to
grab the location when we need it.

// other methods here
}

Now let’s create another class, GumballMonitor, that retrieves the machine’s
location, inventory of gumballs and the current machine state and prints them
in a nice little report:

public class GumballMonitor {
GumballMachine machine;
public GumballMonitor(GumballMachine machine) {
this.machine = machine;
}

The monitor takes the machine in
constructor and assigns it to the its
machine instance variable.

public void report() {
System.out.println(“Gumball Machine: “ + machine.getLocation());
System.out.println(“Current inventory: “ + machine.getCount() + “ gumballs”);
System.out.println(“Current state: “ + machine.getState());
}
}

Our report method just prints
location, inventory and the machia report with
ne’s state.

you are here 4
Download at WoweBook.Com

431

local gumball monitor

Testing the Monitor
We implemented that in no time. The CEO is going to be thrilled and amazed by our
development skills.
Now we just need to instantiate a GumballMonitor and give it a machine to monitor:
public class GumballMachineTestDrive {
public static void main(String[] args) {
int count = 0;

Pass in a location and initial # of
gumballs on the command line.

if (args.length < 2) {
System.out.println(“GumballMachine <name> <inventory>”);
System.exit(1);
}

Don’t forget to give
the constructor a
location and count...

count = Integer.parseInt(args[1]);
GumballMachine gumballMachine = new GumballMachine(args[0], count);
GumballMonitor monitor = new GumballMonitor(gumballMachine);

pass it a
...and instantiate a monitor and
machine to provide a report on.

// rest of test code here
monitor.report();
}
}

When we need a report on
the machine, we call the
report() method.

File Edit Window Help FlyingFish

%java GumballMachineTestDrive Seattle 112
Gumball Machine: Seattle
Current Inventory: 112 gumballs
Current State: waiting for quarter

The monitor output looks great,
but I guess I wasn’t clear. I need to
monitor gumball machines REMOTELY!
In fact, we already have the networks
in place for monitoring. Come on guys,
you’re supposed to be the Internet
generation!

432

Chapter 11
Download at WoweBook.Com

And here’s the output!

the proxy pattern

Don’t worry guys, I’ve
been brushing up on my design
patterns. All we need is a remote
proxy and we’ll be ready to go.
Well, that will teach us to gather
some requirements before we jump
in and code. I hope we don’t have
to start over...

Joe: A remote what?

Joe

Jim

Frank

Frank: Remote proxy. Think about it: we’ve already got the monitor code written, right? We give the
GumballMonitor a reference to a machine and it gives us a report. The problem is that monitor runs
in the same JVM as the gumball machine and the CEO wants to sit at his desk and remotely monitor the
machines! So what if we left our GumballMonitor class as is, but handed it a proxy to a remote object?
Joe: I’m not sure I get it.
Jim: Me neither.
Frank: Let’s start at the beginning... a proxy is a stand in for a real object. In this case, the proxy acts
just like it is a Gumball Machine object, but behind the scenes it is communicating over the network to
talk to the real, remote GumballMachine.
Jim: So you’re saying we keep our code as it is, and we give the monitor a reference to a proxy version
of the GumballMachine...
Joe: And this proxy pretends it’s the real object, but it’s really just communicating over the net to the
real object.
Frank: Yeah, that’s pretty much the story.
Joe: It sounds like something that is easier said than done.
Frank: Perhaps, but I don’t think it’ll be that bad. We have to make sure that the gumball machine
can act as a service and accept requests over the network; we also need to give our monitor a way to get
a reference to a proxy object, but we’ve got some great tools already built into Java to help us. Let’s talk
a little more about remote proxies ﬁrst...
you are here 4
Download at WoweBook.Com

433

remote proxy

The role of the ‘remote proxy’
A remote proxy acts as a local representative to a remote object. What’s a “remote
object?” It’s an object that lives in the heap of a different Java Virtual Machine
(or more generally, a remote object that is running in a different address space).
What’s a “local representative?” It’s an object that you can call local methods on
and have them forwarded on to the remote object.

t
all Moni

Proxy

Same as your old
code, only it’s oxy.
talking to a pr

Remote Heap

um
b

ine

Gu
mb

Remote Gumball Machin
e
with a JVM.

G

ll
Here the Gumbaclient
he
t
is
Monitor
it’s
object; it thinkRs eal
talking to thene, but
gumball machi talking
it’s really just which
to the proxy, the
then talks to achine
Real gumball mork.
over the netw

or

Local Heap

ends to
The proxy pret
ject,
be the remote ob
and in
but it’s just aTsthing.
for the Real

a ll M a

ch

CEO’s desktop

t IS
ote objecIt’s the
m
e
R
e
h
T
Thing.
the Realwith the method
object tually does the
that ac rk.
real wo

Your client object acts like it’s making remote method calls.
But what it’s really doing is calling methods on a heaplocal ‘proxy’ object that handles all the low-level details of
network communication.

434

Chapter 11
Download at WoweBook.Com

the proxy pattern

This is a pretty slick idea. We’re
going to write some code that takes a
method invocation, somehow transfers it over
the network and invokes the same method on a
remote object. Then I presume when the call is
complete, the result gets sent back over the
network to our client. But it seems to me
this code is going to be very
tricky to write.

Hold on now, we
aren’t going to write that code
ourselves, it’s pretty much built
into Java’s remote invocation
functionality. All we have to do
is retroﬁt our code so that it
takes advantage of RMI.

A

brain
power
Before going further, think about how you’d design a system to enable remote method invocation.
How would you make it easy on the developer so that she has to write as little code as possible?
How would you make the remote invocation look seamless?

A

2

brain
power
Should making remote calls be totally transparent? Is that a good idea? What might be a problem
with that approach?

you are here 4
Download at WoweBook.Com

435

RMI detour

Adding a remote proxy to the Gumball
Machine monitoring code
On paper this looks good, but how do we create a proxy that knows how to invoke a method on an
object that lives in another JVM?
Hmmm. Well, you can’t get a reference to something on another heap, right? In other words, you
can’t say:
Duck d = <object in another heap>
Whatever the variable d is referencing must be in the same heap space as the code running the
statement. So how do we approach this? Well, that’s where Java’s Remote Method Invocation
comes in... RMI gives us a way to ﬁnd objects in a remote JVM and allows us to invoke their
methods.
You may have encountered RMI in Head First Java; if not, we’re going to take a slight detour and
come up to speed on RMI before adding the proxy support to the Gumball Machine code.
So, here’s what we’re going to do:

1

2

3

436

First, we’re going to take the RMI
Detour and check RMI out. Even if
you are familiar with RMI, you might
want to follow along and check out the
scenery.
Then we’re going to take our
GumballMachine and make it a remote
service that provides a set of methods
calls that can be invoked remotely.
Then, we going to create a proxy that can
talk to a remote GumballMachine, again
using RMI, and put the monitoring system
back together so that the CEO can monitor
any number of remote machines.

Chapter 11
Download at WoweBook.Com

An RMI Detour
If you’re new to RMI,
take the detour that runs
over the next few pages;
otherwise, you might want to
just quickly thumb through
the detour as a review.

the proxy pattern

Remote methods 101

An RMI Detour

Let’s say we want to design a system that allows us to call a local object that forwards each
request to a remote object. How would we design it? We’d need a couple of helper objects
that actually do the communicating for us. The helpers make it possible for the client to
act as though it’s calling a method on a local object (which in fact, it is). The client calls a
method on the client helper, as if the client helper were the actual service. The client helper
then takes care of forwarding that request for us.
In other words, the client object thinks it’s calling a method on the remote service, because
the client helper is pretending to be the service object. Pretending to be the thing with the
method the client wants to call.
But the client helper isn’t really the remote service. Although the client helper acts like it
(because it has the same method that the service is advertising), the client helper doesn’t
have any of the actual method logic the client is expecting. Instead, the client helper
contacts the server, transfers information about the method call (e.g., name of the method,
arguments, etc.), and waits for a return from the server.
On the server side, the service helper receives the request from the client helper (through
a Socket connection), unpacks the information about the call, and then invokes the real
method on the real service object. So, to the service object, the call is local. It’s coming from
the service helper, not a remote client.
The service helper gets the return value from the service, packs it up, and ships it back (over
a Socket’s output stream) to the client helper. The client helper unpacks the information
and returns the value to the client object.

Client heap

nks
Client object tthihe
it’s talking toIt
Real Service. nt
thinks the cliething
helper is the lly
that can actuaork.
do the real w

C li
ent object

ends
Client helper pricet
e, but
to be the serv y for the
it’s just a prox
Real Thing.

C li
ent helper

This is going
to be our
proxy.

Se

Server heap

e
rvice help

Se

Service helper gets the
request from the client
helper, unpacks it, and
calls the method on the
Real Service.

rvice objec

t

familiar...

r

This should look

t IS
ice objec
e
The Seravl Service. It’s thd
o
e
h
the R with the met
object tually does the
that ac rk.
real wo
you are here 4

Download at WoweBook.Com

437

remote method invocation

How the method call happens
1

Client object calls doBigThing() on the client helper object.
Server heap

Client heap
doBigThing()

C li
ent object

2

e
rvice help

Se

rvice objec

t

Se

r

C li
ent helper

Client helper packages up information about the call
(arguments, method name, etc.) and ships it over the
network to the service helper.
Client heap

“client wants to call a method”

Server heap

doBigThing()

C li
ent object

rvice objec

t

Se

Service helper unpacks the information from the client helper,
ﬁnds out which method to call (and on which object) and
invokes the real method on the real service object.
“client wants to call a method”

doBigThing()

doBigThing()

C li
ent object

C li
ent helper

Server heap

Se

rvice help

e

Se

Chapter 11
Download at WoweBook.Com

rvice objec

t

Client heap

438

e
rvice help

r

Se

r

3

C li
ent helper

s is the
Remember, thihe
REAL
t
object with The one
method logic. real work!
that does the

the proxy pattern

4

An RMI Detour

The method is invoked on the service object, which returns
some result to the service helper.
Server heap

Client heap

result

C li
ent object

Se

rvice objec

t

r

e
rvice help

Service helper packages up information returned from the
call and ships it back over the network to the client helper.

C li
ent object

Server heap
packaged up result

Se

rvice help

e

Se

rvice objec

t

C li
ent helper

r

Client heap

Client helper unpackages the returned values and returns
them to the client object. To the client object, this was all
transparent.
Server heap

Client heap
result

C li
ent object

C li
ent helper

Se

e
rvice help

Se

rvice objec

t

6

Se

r

5

C li
ent helper

you are here 4
Download at WoweBook.Com

439

RMI: the big picture

Java RMI, the Big Picture
Okay, you’ve got the gist of how remote methods work;
now you just need to understand how to use RMI to
enable remote method invocation.
What RMI does for you is build the client and service
helper objects, right down to creating a client helper
object with the same methods as the remote service. The
nice thing about RMI is that you don’t have to write
any of the networking or I/O code yourself. With your
client, you call remote methods (i.e., the ones the Real
Service has) just like normal method calls on objects
running in the client’s own local JVM.

There is one difference between RMI calls and local
(normal) method calls. Remember that even though to
the client it looks like the method call is local, the client
helper sends the method call across the network. So
there is networking and I/O. And what do we know
about networking and I/O methods?
They’re risky! They can fail! And so, they throw
exceptions all over the place. As a result, the client does
have to acknowledge the risk. We’ll see how in a few
pages.

RMI also provides all the runtime infrastructure to make
it all work, including a lookup service that the client can
use to ﬁnd and access the remote objects.
RMI Nomenclature: in RMI, the client helper is a ‘stub’ and the
service helper is a ‘skeleton’.

C li
ent object

C li
ent helper

RMI SKELETON

Se

rvice h

e
elp

Se

rvice objec

t

RMI STUB

Server heap

r

Client heap

This is going
to act as our
proxy!

Now let’s go through all the steps needed to make an object into a
service that can accept remote calls and also the steps needed to
allow a client to make remote calls.
You might want to make sure your seat belt is fastened; there are
a lot of steps and a few bumps and curves – but nothing to be too
worried about.
440

Chapter 11
Download at WoweBook.Com

Newer versions
of Java don’t
require an explic
skeleton object, it
but something on
the server side
is still handling
skeleton behavior.

the proxy pattern

Making the Remote service
An RMI Detour

This is an overview of the ﬁve steps for making the remote service. In other words, the
steps needed to take an ordinary object and supercharge it so it can be called by a remote
client. We’ll be doing this later to our GumballMachine. For now, let’s get the steps down
and then we’ll explain each one in detail.

Step one:

public interface
MyRemote extends
Remote { }

Make a Remote Interface
The remote interface deﬁnes the methods that
a client can call remotely. It’s what the client MyService.java
will use as the class type for your service. Both
the Stub and actual service will implement
this!

Step two:
Make a Remote Implementation
This is the class that does the Real Work. It
has the real implementation of the remote
methods deﬁned in the remote interface.
It’s the object that the client wants to call
methods on (e.g., our GumballMachine!).

he
defines ytou
e
c
a
f
r
e
t
This in methods that
remote ents to call.
want cli

public MyRemoteImpl
extends
UnicastRemoteObject
implements
MyRemote { }

MyServiceImpl.java

ss
The Real Service; theatclado
th
s
od
th
with the me
nts
the real work. It imple. me
the remote interface

...spits out two
classes for the new
helper objects.

e actual
Running rmic against thclass...
ion
service implementat

Step three:
Generate the stubs and skeletons using rmic
These are the client and server ‘helpers’. You
don’t have to create these classes or ever look
at the source code that generates them. It’s all
handled automatically when you run the rmic
tool that ships with your Java development kit.

101101
10 110 1
0 11 0
001 10
001 01

File Edit Window Help Eat

%rmic MyServiceImpl

MyServiceImpl_Stub.class
101101
10 110 1
0 11 0
001 10
001 01

Step four:
Start the RMI registry (rmiregistry)
The rmiregistry is like the white pages of a phone
book. It’s where the client goes to get the proxy
(the client stub/helper object).

MyServiceImpl_Skel.class
File Edit Window Help Drink

%rmiregistry

Step ﬁve:
Start the remote service
You have to get the service object up and running. Your
service implementation class instantiates an instance
of the service and registers it with the RMI registry.
Registering it makes the service available for clients.

Run this tine
a separa
terminal.

File Edit Window Help BeMerry

%java MyServiceImpl

you are here 4
Download at WoweBook.Com

441

make a remote interface

Step one: make a Remote interface
1

Extend java.rmi.Remote
Remote is a ‘marker’ interface, which means it has no methods. It has special
meaning for RMI, though, so you must follow this rule. Notice that we say
‘extends’ here. One interface is allowed to extend another interface.

public interface MyRemote extends Remote {
2

t the
This tells us thaing to be used
interface is gomote calls.
to support re

Declare that all methods throw a RemoteException
The remote interface is the one the client uses as the type for the service. In
other words, the client invokes methods on something that implements the
remote interface. That something is the stub, of course, and since the stub is
doing networking and I/O, all kinds of Bad Things can happen. The client
has to acknowledge the risks by handling or declaring the remote exceptions. If
the methods in an interface declare exceptions, any code calling methods on a
reference of that type (the interface type) must handle or declare the exceptions.

import java.rmi.*;

Remote interface is in

java.rmi

public interface MyRemote extends Remote {
public String sayHello() throws RemoteException;
}
3

Be sure arguments and return values are primitives or Serializable
Arguments and return values of a remote method must be either primitive
or Serializable. Think about it. Any argument to a remote method has to
be packaged up and shipped across the network, and that’s done through
Serialization. Same thing with return values. If you use primitives, Strings, and
the majority of types in the API (including arrays and collections), you’ll be ﬁne.
If you are passing around your own types, just be sure that you make your classes
implement Serializable.

public String sayHello() throws RemoteException;

This return value is gonna be ship
server back to the client, so it muped over the wire from the
how args and return values get pacst be Serializable. That’s
kaged up and sent.
442

Chapter 11
Download at WoweBook.Com

Every remote method call is
considered ‘risky’. Declaring
RemoteException on every
method forces the client
to pay attention and
acknowledge that things
might not work.
Check out Head First
Java if you need to
refresh your memory
on Serializable.

the proxy pattern

Step two: make a Remote implementation
1

An RMI Detour

Implement the Remote interface
Your service has to implement the remote interface—the one with
the methods your client is going to call.

public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
public String sayHello() {
return “Server says, ‘Hey’”; The compiler wil
l make sure t
}
you’ve implemented all the metha
ds
// more code in class
from the interface you implemtho
ent
.
}
In this case, the

re’s only one.

2

Extend UnicastRemoteObject
In order to work as a remote service object, your object needs some functionality
related to ‘being remote’. The simplest way is to extend UnicastRemoteObject
(from the java.rmi.server package) and let that class (your superclass) do the
work for you.
public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {

3

Write a no-arg constructor that declares a RemoteException
Your new superclass, UnicastRemoteObject, has one little problem—its
constructor throws a RemoteException. The only way to deal with this is to
declare a constructor for your remote implementation, just so that you have a
place to declare the RemoteException. Remember, when a class is instantiated,
its superclass constructor is always called. If your superclass constructor throws
an exception, you have no choice but to declare that your constructor also throws
an exception.
public MyRemoteImpl() throws RemoteException { }

4

Register the service with the RMI registry

t anything in
You don’t have toYpuou just need a
the constructor. at your superclass
way to declare thws an exception.
constructor thro

Now that you’ve got a remote service, you have to make it available to remote
clients. You do this by instantiating it and putting it into the RMI registry (which
must be running or this line of code fails). When you register the implementation
object, the RMI system actually puts the stub in the registry, since that’s what the
client really needs. Register your service using the static rebind() method of the
java.rmi.Naming class.
use
me (that clients can
try {
Give your service aenaregistry) and register it
MyRemote service = new MyRemoteImpl();
to look it up in th stry. When you bind the
Naming.rebind(“RemoteHello”, service);
with the RMI regi I swaps the service for the
} catch(Exception ex) {...}
service object, RM
gistry.

ub in the re

stub and puts the st

you are here 4
Download at WoweBook.Com

443

stubs and skeletons

Step three: generate stubs and skeletons
1

Run rmic on the remote implementation class
(not the remote interface)
The rmic tool, which comes with the Java software
development kit, takes a service implementation and
creates two new classes, the stub and the skeleton. It uses
a naming convention that is the name of your remote
implementation, with either _Stub or _Skel added to
the end. There are other options with rmic, including
not generating skeletons, seeing what the source code
for these classes looked like, and even using IIOP as
the protocol. The way we’re doing it here is the way
you’ll usually do it. The classes will land in the current
directory (i.e. whatever you did a cd to). Remember,
rmic must be able to see your implementation class, so
you’ll probably run rmic from the directory where your
remote implementation is located. (We’re deliberately
not using packages here, to make it simpler. In the Real
World, you’ll need to account for package directory
structures and fully-qualiﬁed names).

say “.class”
Notice that you don’t
ss name.
on the end. Just the cla
File Edit Window Help Whufﬁe

%rmic MyRemoteImpl

Bring up a terminal and start the rmiregistry.
Be sure you start it from a directory that has access to
your classes. The simplest way is to start it from your
‘classes’ directory.

Bring up another terminal and start your service
This might be from a main() method in your remote
implementation class, or from a separate launcher class.
In this simple example, we put the starter code in the
implementation class, in a main method that instantiates the
object and registers it with RMI registry.

444

MyRemoteImpl_Stub.class

MyRemoteImpl_Skel.class

File Edit Window Help Huh?

%rmiregistry

Step ﬁve: start the service
1

101101
10 110 1
0 11 0
001 10
001 01

101101
10 110 1
0 11 0
001 10
001 01

Step four: run rmiregistry
1

RMIC generates
two
new classes for
t
he
helper objects.

File Edit Window Help Huh?

%java MyRemoteImpl

Chapter 11
Download at WoweBook.Com

the proxy pattern

Complete code for the server side
An RMI Detour

The Remote interface:

import
public
}

Remote
RemoteException and.rm
i package.
java.rmi.*;
interface are in java
Remote
interface MUST extend java.rmi.
ur
Yo
interface MyRemote extends Remote {

All of your remote methods must
declare a RemoteException.

public String sayHello() throws RemoteException;

The Remote service (the implementation):

import java.rmi.*;
import java.rmi.server.*;

t is in the
c
e
j
b
O
e
t
o
m
the
UnicastRseerver package.
RemoteObject is
i.
m
Extending Unicamstake a remote object.
java.r
easiest way to

public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
public String sayHello() {
return “Server says, ‘Hey’”;
}

You have to implement all the
interface methods, of course. But
notice that you do NOT have to
declare the RemoteException.

public MyRemoteImpl() throws RemoteException { }
public static void main (String[] args) {

}

}

try {
MyRemote service = new MyRemoteImpl();
Naming.rebind(“RemoteHello”, service);
} catch(Exception ex) {
ex.printStackTrace();
}

You MUST impl
ent your
remote interfacem
e!!

Your superclass constructor (for
eption, so
UnicastRemoteObject) declares an exc
means
use
beca
YOU must write a constructor, y codite (its
risk
that your constructor is calling
super constructor).
Make the remote ob
, then ‘bind’ it to the
rmiregistery using thjee ct
st
name you register it un atic Naming.rebind(). The
use to look it up in the der is the name clients will
RMI registry.
you are here 4

Download at WoweBook.Com

445

how to get the stub object

How does the client get the
stub object?
The client has to get the stub object (our proxy), since
that’s the thing the client will call methods on. And that’s
where the RMI registry comes in. The client does a
‘lookup’, like going to the white pages of a phone book,
and essentially says, “Here’s a name, and I’d like the stub
that goes with that name.”
Let’s take a look at the code we need to lookup and
retrieve a stub object.

Here’s how

it works.

Code Up Close
The client always uses the remote
interface as the type of the
vice.
In fact, the client never needsser
to
know the actual class name of you
r
remote service.
lookup() is a static method
of the Naming class.

This must be
name
that the servicthe
e
w
registered under as
.

MyRemote service =
(MyRemote) Naming.lookup(“rmi://127.0.0.1/RemoteHello”);

You have to cast it to the
interface, since the lookup
method returns type Object.

446

The host name or IP
address where the
service is running.

Chapter 11
Download at WoweBook.Com

the proxy pattern

An RMI Detour

Server

Client
)
ello(
sayH

C li
ent object

S ke l
stu
eton
br
et
ur
ne
d

S tu b

Se

rvice objec

t

3

2

1 lo
oku
p(
)

RMI registry (on server)
Remote
Hello

Stub

How it works...
1 Client does a lookup on the RMI registry
Naming.lookup(“rmi://127.0.0.1/RemoteHello”);

2 RMI registry returns the stub object
(as the return value of the lookup method) and RMI deserializes the stub
automatically. You MUST have the stub class (that rmic generated for you)
on the client or the stub won’t be deserialized.

3

Client invokes a method on the stub, as if the
stub IS the real service

you are here 4
Download at WoweBook.Com

447

the remote client

Complete client code

import java.rmi.*;

The Naming clas
lookup) is in the s (for doing the rmiregistry
java.rmi package.

public class MyRemoteClient {
public static void main (String[] args) {
new MyRemoteClient().go();
}
public void go() {

type
registry aasst.
e
h
t
f
o
t
It comes oou don’t forget the c
Object, s

try {
MyRemote service = (MyRemote) Naming.lookup(“rmi://127.0.0.1/RemoteHello”);
String s = service.sayHello();

}

}

System.out.println(s);
} catch(Exception ex) {
ex.printStackTrace();
}

Geek Bits

You need the IP
address or hostname.

It looks just like a
method call! (Excepret gular old
acknowledge the Remoit must
teException.)

and the name used rvtoice.
bind/rebind the se

How does the client get the stub class?

Now we get to the interesting question. Somehow, some way, the client must have the stub class
(that you generated earlier using rmic) at the time the client does the lookup, or else the stub won’t
be deserialized on the client and the whole thing blows up. The client also needs classes for any
serialized objects returned by method calls to the remote object. In a simple system, you can simply
hand-deliver the these classes to the client.
There’s a much cooler way, although it’s beyond the scope of this book. But just in case you’re
interested, the cooler way is called “dynamic class downloading”. With dynamic class downloading,
Serialized objects (like the stub) are “stamped”with a URL that tells the RMI system on the client where
to ﬁnd the class ﬁle for that object. Then, in the process of deserializing an object, if RMI can’t ﬁnd the
class locally, it uses that URL to do an HTTP Get to retrieve the class ﬁle. So you’d need a simple web
server to serve up class ﬁles, and you’d also need to change some security parameters on the client.
There are a few other tricky issues with dynamic class downloading, but that’s the overview.
For the stub object speciﬁcally, there’s another way the client can get the class. This is only available in
Java 5, though. We’ll brieﬂy talk about this near the end of the chapter.

448

Chapter 11
Download at WoweBook.Com

the proxy pattern

An RMI Detour

The top three things programmers do wrong with RMI are:
1) Forget to start rmiregistry before starting remote service (when the service is registered using
Naming.rebind(), the rmiregistry must be running!)
2) Forget to make arguments and return types serializable (you won’t know until runtime; this is
not something the compiler will detect.)
3) Forget to give the stub class to the client.

Server

S ke l
eton
C li
ent object

S tu b

101101
10 110 1
0 11 0
001 10
001 01

101101
10 110 1
0 11 0
001 10
001 01

101101
10 110 1
0 11 0
001 10
001 01

rvice objec

S tu b

Don’t forget, the client
uses the remote interface
to call methods on the stub.
The client JVM needs the Client.class MyServiceImpl_Stub.class
stub class, but the client
never refers to the stub
class in code. The client
always uses the remote
MyRemote.class
interface, as though the
remote interface WERE the
actual remote object.
101101
10 110 1
0 11 0
001 10
001 01

Se

t

Client

MyServiceImpl.class
101101
10 110 1
0 11 0
001 10
001 01

MyServiceImpl_Skel.class

101101
10 110 1
0 11 0
001 10
001 01

MyServiceImpl_Stub.class
101101
10 110 1
0 11 0
001 10
001 01

MyRemote.class

Server needs both the Stub and Skeleton
classes, as well as the service and the
remote interface. It needs the stub class
because remember, the stub is substituted
for the real service when the real service
is bound to the RMI registry.

you are here 4
Download at WoweBook.Com

449

remote gumball monitor

Back to our GumballMachine
remote proxy
Okay, now that you have the RMI basics down, you’ve
got the tools you need to implement the gumball
machine remote proxy. Let’s take a look at how the
GumballMachine ﬁts into this framework:

Server heap

This is our it
Monitor code, o
uses a proxy te
talk to remotnes.
gumball machi

allMonito

r

Gu
mb

Gu
mballStub

to
n

Client heap

450

Remote Gumball Machin
e
with a JVM.

oxy
The stub is a epr
to the remot ne.
GumballMachi

e
Gu
mballSkel

Gu
mbal Machi
l

The skeleton accepts the
remote calls and makes
everything work on the
service side.

Chapter 11
Download at WoweBook.Com

ne

CEO’s desktop

The Machine is
Gumball ote service;
our rem g to expose
it’s goin e interface
a remot client to
for the
use.

the proxy pattern

Getting the GumballMachine ready
to be a remote ser vice
The ﬁrst step in converting our code to use the remote proxy is to enable the
GumballMachine to service remote requests from clients. In other words,
we’re going to make it into a service. To do that, we need to:
1) Create a remote interface for the GumballMachine. This will provide a set
of methods that can be called remotely.
2) Make sure all the return types in the interface are serializable.
3) Implement the interface in a concrete class.
We’ll start with the remote interface:

Don’t forget to import

java.rmi.*

This is the remote interface.

import java.rmi.*;
public interface GumballMachineRemote extends Remote {
public int getCount() throws RemoteException;
public String getLocation() throws RemoteException;
public State getState() throws RemoteException;
}

All return types need
to be primitive or
Serializable...

.
Here are the methods were going to support
Each one throws RemoteException.

We have one return type that isn’t Serializable: the State class. Let’s ﬁx it up...
import java.io.*;

Serializable is in the java.io package.

public interface State extends Serializable {
public void insertQuarter();
Then we just extend the Serializableit).
public void ejectQuarter();
interface (which has no methods in can
public void turnCrank();
And now State in all the subclasses
public void dispense();
}
be transferred over the network.

you are here 4
Download at WoweBook.Com

451

remote interface for the gumball machine

Actually, we’re not done with Serializable yet; we have one problem with State. As you may
remember, each State object maintains a reference to a gumball machine so that it can call the
gumball machine’s methods and change its state. We don’t want the entire gumball machine
serialized and transferred with the State object. There is an easy way to ﬁx this:
public class NoQuarterState implements State {
transient GumballMachine gumballMachine;
// all other methods here
}

In each implementation of State, we
add the transient keyword to the s
GumballMachine instance variable. Thi
tells the JVM not to serialize this fielusd.
Note that this can be slightly dangero
if you try to access this field once its
been serialized and transferred.

We’ve already implemented our GumballMachine, but we need to make sure it can act as a service and
handle requests coming from over the network. To do that, we have to make sure the GumballMachine is
doing everything it needs to implement the GumballMachineRemote interface.
As you’ve already seen in the RMI detour, this is quite simple, all we need to do is add a couple of things...

First, we need to import the
rmi packages.
import java.rmi.*;
import java.rmi.server.*;

GumballMachine is
going to subclass the
UnicastRemoteObject;
this gives it the ability to
act as a remote service.

GumballMachine also needs to
implement the remote interface...

public class GumballMachine
extends UnicastRemoteObject implements GumballMachineRemote
{
// instance variables here
public GumballMachine(String location, int numberGumballs) throws RemoteException {
// code here
}
public int getCount() {
return count;
}
public State getState() {
return state;
}

That’s it! Nothing
changes here at all!

public String getLocation() {
return location;
}
// other methods here
}

452

Chapter 11
Download at WoweBook.Com

...and the constructor needs
to throw a remote exception,
because the superclass does.

the proxy pattern

Registering with the RMI registry...
That completes the gumball machine service. Now we just need to ﬁre it up so it can
receive requests. First, we need to make sure we register it with the RMI registry so
that clients can locate it.
We’re going to add a little code to the test drive that will take care of this for us:
public class GumballMachineTestDrive {
public static void main(String[] args) {
GumballMachineRemote gumballMachine = null;
int count;
if (args.length < 2) {
System.out.println(“GumballMachine <name> <inventory>”);
System.exit(1);
First we need to
}

add a try/catch k
around the gumball instantiation becbloc
ause our
constructor can now throw exceptions
.

try {
count = Integer.parseInt(args[1]);

}

gumballMachine =
new GumballMachine(args[0], count);
Naming.rebind(“//” + args[0] + “/gumballmachine”, gumballMachine);
} catch (Exception e) {
e.printStackTrace();
}
We also add the call to Naming.rebind,

}

Let’s go ahead and get this running...

Run this first.

which publishes the GumballMachine stub
under the name gumballmachine.
icial”
We’re using the “offchines, you
This gets the RMI
Mighty Gumball mayour own
registry service up
should substitute .
and running.
machine name here

File Edit Window Help Huh?

% rmiregistry
File Edit Window Help Huh?

% java GumballMachineTestDrive seattle.mightygumball.com 100

Run this second.

This gets the GumballMachine up and running
and registers it with the RMI registry.
you are here 4

Download at WoweBook.Com

453

gumball monitor client

Now for the GumballMonitor client...
Remember the GumballMonitor? We wanted to reuse it without
having to rewrite it to work over a network. Well, we’re pretty much
going to do that, but we do need to make a few changes.

e
age because we ar
ck
pa
I
M
R
he
t
port
We need to imot
ion class below...
pt
ce
x
eE
em
R
using the
mote
import java.rmi.*;
o rely on the re
t
g
in
go
re
e’
e
w
Now
han the concret
t
r
he
t
ra
e
ac
f
inter
public class GumballMonitor {
class.
GumballMachine
GumballMachineRemote machine;
public GumballMonitor(GumballMachineRemote machine) {
this.machine = machine;
}

}

public void report() {
try {
System.out.println(“Gumball Machine: “ + machine.getLocation());
System.out.println(“Current inventory: “ + machine.getCount() + “ gumballs”);
System.out.println(“Current state: “ + machine.getState());
} catch (RemoteException e) {
e.printStackTrace();
}
We also need to catch any remote except
}
ions

that might happen as we try to invoke met
hods
that are ultimately happening over the
network.

Frank was right; this
is working out quite
nicely!

454

Chapter 11
Download at WoweBook.Com

the proxy pattern

Writing the Monitor test drive
Now we’ve got all the pieces we need. We just need to write some
code so the CEO can monitor a bunch of gumball machines:

Here’s the monitor test drive. The
CEO is going to run this!
import java.rmi.*;
public class GumballMonitorTestDrive {

tions
Here’s all the lomca
itor. We create an ,
were going to on
array of locations
one for each
machine.

public static void main(String[] args) {
String[] location = {“rmi://santafe.mightygumball.com/gumballmachine”,
“rmi://boulder.mightygumball.com/gumballmachine”,
“rmi://seattle.mightygumball.com/gumballmachine”};
GumballMonitor[] monitor = new GumballMonitor[location.length];

for (int i=0;i < location.length; i++) {
We also create an
try {
array of monitors.
GumballMachineRemote machine =
(GumballMachineRemote) Naming.lookup(location[i]);
monitor[i] = new GumballMonitor(machine);
System.out.println(monitor[i]);
} catch (Exception e) {
e.printStackTrace();
}
}
Now we need to get a proxy
for(int i=0; i < monitor.length; i++) {
monitor[i].report();
}

to each remote machine.

}
}

Then we iterate through eachort.
machine and print out its rep

you are here 4
Download at WoweBook.Com

455

the gumball machine proxy

Code Up Close
This returns a proxy to the remote
Gumball Machine (or throws an exception
if one can’t be located).

Remember, Naming.lookup() is a
static method in the RMI package
that takes a location and service
name and looks it up in the
rmiregistry at that location.

try {
GumballMachineRemote machine =
(GumballMachineRemote) Naming.lookup(location[i]);
monitor[i] = new GumballMonitor(machine);
} catch (Exception e) {
e.printStackTrace();
}

oxy to the remoteonitor
Once we get a prte
a new GumballM
machine, we creamachine to monitor.
and pass it the

Another demo for the CEO of Mighty Gumball...
Okay, it’s time to put all this work together and give another demo. First let’s make
sure a few gumball machines are running the new code:

On each machine, run rmiregistry in
the background or from a separate
terminal window...

...and then run the GumballMachine, giving it
a location and an initial gumball count.

File Edit Window Help Huh?

% rmiregistry &
% java GumballMachine santafe.mightygumball.com 100
File Edit Window Help Huh?

% rmiregistry &
% java GumballMachine boulder.mightygumball.com 100
File Edit Window Help Huh?

% rmiregistry &
% java GumballMachine seattle.mightygumball.com 250

popular machine!
456

Chapter 11
Download at WoweBook.Com

the proxy pattern

And now let’s put the monitor in the hands of the CEO.
Hopefully this time he’ll love it:

File Edit Window Help GumballsAndBeyond

% java GumballMonitor
Gumball Machine: santafe.mightygumball.com
Current inventory: 99 gumballs
Current state: waiting for quarter
Gumball Machine: boulder.mightygumball.com
Current inventory: 44 gumballs
Current state: waiting for turn of crank

The monitor iterates
over each remote
machine and calls its
getLocation(),
getCount() and
getState() methods.

Gumball Machine: seattle.mightygumball.com
Current inventory: 187 gumballs
Current state: waiting for quarter
%

This is amazing;
it’s going to revolutionize my
business and blow away the
competition!

By invoking methods on the proxy, a remote call
is made across the wire and a String, an integer
and a State object are returned. Because we are
using a proxy, the GumballMonitor doesn’t know,
or care, that calls are remote (other than having
to worry about remote exceptions).

you are here 4
Download at WoweBook.Com

457

proxy behind the scenes

This worked great! But
I want to make sure I
understand exactly what’s
going on...

1

Behind
the Scenes

The CEO runs the monitor, which ﬁrst grabs the proxies to the remote
gumball machines and then calls getState() on each one (along with
getCount() and getLocation()).

CEO’s desktop

Remote Gumball Machin
e
with a JVM

Type is GumballMachineR

emote

or

Gu
it
mballMon

t
Proxy/S

1 lo
oku
p(
“se

pr
S ke l
ox
eton
yr
et
ur
ne
d

Gu
mbal Machi
l

ne

3

ub

)
tate(
getS

2

att
le”
)

RMI registry (on gumball machine)
seattle

Proxy/Stub

458

Chapter 11
Download at WoweBook.Com

the proxy pattern

2

getState() is called on the proxy, which forwards the call to the remote
service. The skeleton receives the request and then forwards it to the
gumball machine.
getState()

)
tate(
getS

or

Gu
it
mballMon

3

Gu
mbal Machi
l

ne

ub

S ke l
eton

t
Proxy/S

GumballMachine returns the state to the skeleton, which serializes it and
transfers it back over the wire to the proxy. The proxy deserializes it and
returns it as an object to the monitor.
State
object

Serialized
State

or

Gu
it
mballMon

t
Proxy/S

l,
’t changed at aler
t
The monitor hasn
un
co
it may en
except it knowios ns. It also uses the
remote except Remote interface rather
GumballMachinete implementation.
than a concre

S ke l
eton

Gu
mbal Machi
l

ne

ub

State
object

Likewise, the GumballMachine
implements another interface and
may throw a remote exception in its
constructor, but other than that, the
code hasn’t changed.

We also have a small bit of code to register and locate stubs using the
RMI registry. But no matter what, if we were writing something to
work over the Internet, we’d need some kind of locator service.

you are here 4
Download at WoweBook.Com

459

the proxy pattern deﬁned

The Proxy Pattern defined
We’ve already put a lot of pages behind us in this chapter; as you
can see, explaining the Remote Proxy is quite involved. Despite
that, you’ll see that the deﬁnition and class diagram for the Proxy
Pattern is actually fairly straightforward. Note that Remote Proxy is
one implementation of the general Proxy Pattern; there are actually
quite a few variations of the pattern, and we’ll talk about them later.
For now, let’s get the details of the general pattern down.
Here’s the Proxy Pattern deﬁnition:

The Proxy Pattern provides a surrogate or
placeholder for another object to control access to it.

Well, we’ve seen how the Proxy Pattern provides a surrogate or
placeholder for another object. We’ve also described the proxy as
a “representative” for another object.
But what about a proxy controlling access? That sounds a little
strange. No worries. In the case of the gumball machine, just
think of the proxy controlling access to the remote object. The
proxy needed to control access because our client, the monitor,
didn’t know how to talk to a remote object. So in some sense the
remote proxy controlled access so that it could handle the network
details for us. As we just discussed, there are many variations of
the Proxy Pattern, and the variations typically revolve around the
way the proxy “controls access.” We’re going to talk more about
this later, but for now here are a few ways proxies control access:

ß As we know, a remote proxy controls access to a
remote object.

ß A virtual proxy controls access to a resource that is
expensive to create.

ß A protection proxy controls access to a resource
based on access rights.
Now that you’ve got the gist of the general pattern, check out the
class diagram...

460

Chapter 11
Download at WoweBook.Com

Use the Proxy
Pattern to create a
representative object
that controls access
to another object,
which may be remote,
expensive to create or
in need of securing.

the proxy pattern

and the
Both the Proxyplement the
RealSubject im ace. This
Subject interf to treat
allows any clientlike the
the proxy just
RealSubject.

<<interface>>

Subject

request()

subject

RealSubject
request()

The RealSubject is
usually the object
that does most
of the real work;
the Proxy controls
access to it.

Proxy
request()

The Proxy often instantiates
or handles the creation of
the RealSubject.

a
The Proxy keepthse
reference to can
Subject, so it ts
forward reques
to the Subject
when necessary.

Let’s step through the diagram...
First we have a Subject, which provides an interface for the RealSubject and the Proxy.
By implementing the same interface, the Proxy can be substituted for the RealSubject
anywhere it occurs.
The RealSubject is the object that does the real work. It’s the object that the Proxy
represents and controls access to.
The Proxy holds a reference to the RealSubject. In some cases, the Proxy may be
responsible for creating and destroying the RealSubject. Clients interact with the
RealSubject through the Proxy. Because the Proxy and RealSubject implement the
same interface (Subject), the Proxy can be substituted anywhere the subject can be
used. The Proxy also controls access to the RealSubject; this control may be needed
if the Subject is running on a remote machine, if the Subject is expensive to create in
some way or if access to the subject needs to be protected in some way.
Now that you understand the general pattern, let’s look at some other ways of using
proxy beyond the Remote Proxy...

you are here 4
Download at WoweBook.Com

461

virtual proxy

Get ready for Virtual Proxy
Okay, so far you’ve seen the deﬁnition of the Proxy Pattern and you’ve taken a look
at one speciﬁc example: the Remote Proxy. Now we’re going to take a look at a different
type of proxy, the Virtual Proxy. As you’ll discover, the Proxy Pattern can manifest
itself in many forms, yet all the forms follow roughly the general proxy design. Why
so many forms? Because the proxy pattern can be applied to a lot of different use
cases. Let’s check out the Virtual Proxy and compare it to Remote Proxy:

st( )
reque

Remote Proxy
st( )
reque

Real ubjec
S

t

With Remote Proxy, the proxy
acts as a local representative
for an object that lives in a
different JVM. A method call
on the proxy results in the call
being transferred over the wire,
invoked remotely, and the result
being returned back to the proxy
and then to the Client.

Proxy

C li e n t

We know this diagram
pretty well by now...

eate” object.

Big “expensive to cr

The proxy creates
the RealSubject
when it’s needed.

Virtual Proxy acts as a
representative for an object that
may be expensive to create. The
Virtual Proxy often defers the
creation of the object until it
is needed; the Virtual Proxy
also acts as a surrogate for
the object before and while it
is being created. After that, the
proxy delegates requests directly to
the RealSubject.

462

st( )
reque

C li e n t

Proxy

Real ubjec
S

The proxy may handle the request, or if
the RealSubject has been created, delegate
the calls to the RealSubject.

Chapter 11
Download at WoweBook.Com

t

Virtual Proxy

the proxy pattern

Displaying CD covers
Let’s say you want to write an application that displays your favorite compact disc
covers. You might create a menu of the CD titles and then retrieve the images
from an online service like Amazon.com. If you’re using Swing, you might create
an Icon and ask it to load the image from the network. The only problem is,
depending on the network load and the bandwidth of your connection, retrieving
a CD cover might take a little time, so your application should display something
while you are waiting for the image to load. We also don’t want to hang up the
entire application while it’s waiting on the image. Once the image is loaded, the
message should go away and you should see the image.
An easy way to achieve this is through a virtual proxy. The virtual proxy can
stand in place of the icon, manage the background loading, and before the
image is fully retrieved from the network, display “Loading CD cover, please
wait...”. Once the image is loaded, the proxy delegates the display to the Icon.

Choose the album cover of
your liking here.

While the CD cover
is loading, the proxy
displays a message.

is
CD coverroxy
e
h
t
n
e
h
W
d, the p
fully loadtehe image.
displays
you are here 4
Download at WoweBook.Com

463

image proxy controls access

Designing the CD cover Virtual Proxy
Before writing the code for the CD Cover Viewer, let’s look at the class diagram.
You’ll see this looks just like our Remote Proxy class diagram, but here the proxy is
used to hide an object that is expensive to create (because we need to retrieve the data
for the Icon over the network) as opposed to an object that actually lives somewhere
else on the network.

This is the Swing
Icon interface used
to display images in a
user interface.

<<interface>>

Icon

getIconWidth()
getIconHeight()
paintIcon()

subject

ImageIcon

ImageProxy

getIconWidth()

getIconWidth()

getIconHeight()

getIconHeight()

paintIcon()

paintIcon()

This is javax.swing.ImageIcon,
a class that displays an Image.

This is our proxy, which first
displays a message and then when
the image is loaded, delegates to
ImageIcon to display the image.

How ImageProxy is going to work:

464

1

ImageProxy ﬁrst creates an ImageIcon and starts
loading it from a network URL.

2

While the bytes of the image are being retrieved,
ImageProxy displays “Loading CD cover, please
wait...”.

3

When the image is fully loaded, ImageProxy delegates all method calls to the image icon, including
paintIcon(), getWidth() and getHeight().

4

If the user requests a new image, we’ll create a
new proxy and start the process over.

Chapter 11
Download at WoweBook.Com

the proxy pattern

Writing the Image Proxy
class ImageProxy implements Icon {
ImageIcon imageIcon;
URL imageURL;
Thread retrievalThread;
boolean retrieving = false;

The ImageProxy on
implements the Ic
interface.

Icon

getIconWidth()
getIconHeight()
paintIcon()

public ImageProxy(URL url) { imageURL = url; }
public int getIconWidth() {
if (imageIcon != null) {
return imageIcon.getIconWidth();
} else {
return 800;
}
}
public int getIconHeight() {
if (imageIcon != null) {
return imageIcon.getIconHeight();
} else {
return 600;
}
}

}

<<interface>>

The imageIcon is the REAL icon that we
eventually want to display when it’s loaded.
We pass the URL of the image into
the constructor. This is the image
we need to display once it’s loaded!
We return a default width and height
until the imageIcon is loaded; then we
turn it over to the imageIcon.

public void paintIcon(ﬁnal Component c, Graphics g, int x, int y) {
if (imageIcon != null) {
imageIcon.paintIcon(c, g, x, y);
} else {
g.drawString(“Loading CD cover, please wait...”, x+300, y+190);
if (!retrieving) {
retrieving = true;
retrievalThread = new Thread(new Runnable() {
public void run() {
try {
imageIcon = new ImageIcon(imageURL, “CD Cover”);
c.repaint();
} catch (Exception e) {
e.printStackTrace();
}
Here’s where things get interesting.
}
code paints the icon on the
This
});
(by delegating to the
screen
retrievalThread.start();
imageIcon). However, if we don’t have
}
}
a fully created ImageIcon, then we
}
create one. Let’s look at this closer

on the next page...

you are here 4
Download at WoweBook.Com

465

image proxy up close

.

Code Up Close
This method is called when it’s time to paint the icon on the screen.

public void paintIcon(ﬁnal Component c, Graphics
if (imageIcon != null) {

g, int x,

imageIcon.paintIcon(c, g, x, y);

int y) {

If we’ve got an icon already, we go
ahead and tell it to paint itself.

} else {
g.drawString(“Loading CD cover, please wait...”, x+300, y+190);
if (!retrieving) {

Otherwise we

display the
retrieving = true;
“loading” message.
retrievalThread = new Thread(new Runnable() {
public void run() {
try {
imageIcon = new ImageIcon(imageURL, “CD Cover”);
c.repaint();
} catch (Exception e) {
e.printStackTrace();
}
}
});
ote that

}

466

}

}

retrievalThread.start();

N
icon image. ous: the
L
A
E
R
e
h
t
n
we load
synchro
Here’s wherloeading with IconImage tisurn until the image is
the image constructor doesn’t rech of a chance to do
ImageIcon hat doesn’t give us mu age displayed, so we’rep
loaded. T ates and have our mess See the “Code Way U
screen upd o this asynchronously. e...
going to d he next page for mor
Close” on t

Chapter 11
Download at WoweBook.Com

the proxy pattern

Code Way Up Close

if

e the image...
If we aren’t already trying to retriev
it (in case you
...then it’s time to start retrieving
calls paint, so we
were wondering, only one thread thr
ead safety).
should be okay here in terms of
(!retrieving) {
We don’t want to hang up the
retrieving = true;
entire user interface, so we’re
going to use another thread to
retrievalThread = new Thread(new Runnable() {
public void run() {
retrieve the image.
try {
imageIcon = new ImageIcon(imageURL, “CD Cover”);
c.repaint();
} catch (Exception e) {
e.printStackTrace();
}

}

}
});
retrievalThread.start();

When we have the image,
we tell Swing that we
need to be repainted.

In our thr
instantiateead we
Icon object. the
constructor Its
return until will not
image is loa the
ded.

So, the next time the display is painted after the ImageIcon is instantiated, the paintIcon
method will paint the image, not the loading message.

you are here 4
Download at WoweBook.Com

467

design puzzle

Design Puzzle

The ImageProxy class appears to have two states that are controlled
by conditional statements. Can you think of another pattern that
might clean up this code? How would you redesign ImageProxy?

class ImageProxy implements Icon {
// instance variables & constructor here
public int getIconWidth() {
if (imageIcon != null) {
return imageIcon.getIconWidth();
} else {
return 800;
}
}
public int getIconHeight() {
if (imageIcon != null) {
return imageIcon.getIconHeight();
} else {
return 600;
}
}

Two states

Two states

public void paintIcon(ﬁnal Component c, Graphics g, int x, int y) {
if (imageIcon != null) {
Two
imageIcon.paintIcon(c, g, x, y);
} else {
g.drawString(“Loading CD cover, please wait...”, x+300, y+190);
// more code here
}
}
}

468

Chapter 11
Download at WoweBook.Com

states

the proxy pattern

Testing the CD Cover Viewer
Ready-bake
Code

Okay, it’s time to test out this fancy new virtual proxy. Behind the
scenes we’ve been baking up a new ImageProxyTestDrive that sets up
the window, creates a frame, installs the menus and creates our proxy.
We don’t go through all that code in gory detail here, but you can
always grab the source code and have a look, or check it out at the end
of the chapter where we list all the source code for the Virtual Proxy.
Here’s a partial view of the test drive code:

public class ImageProxyTestDrive {
ImageComponent imageComponent;
public static void main (String[] args) throws Exception {
ImageProxyTestDrive testDrive = new ImageProxyTestDrive();
}
public ImageProxyTestDrive() throws Exception{
// set up frame and menus
Icon icon = new ImageProxy(initialURL);
imageComponent = new ImageComponent(icon);
frame.getContentPane().add(imageComponent);
}
}

Finally we add the proxy to the frame
so it can be displayed.

Here we create an image proxy and set
it to an initial URL. Whenever you
choose a selection from the CD menu,
you’ll get a new image proxy.

Next we wrap our proxy in a
component so it can be added to
the frame. The component will
take care of the proxy’s width,
height and similar details.

Now let’s run the test drive:
File Edit Window Help JustSomeOfTheCDsThatGotUsThroughThisBook

% java ImageProxyTestDrive

Running ImageProxyTestDrive should
give you a window like this.
Things to try...
1

Use the menu to load different CD covers; watch the
proxy display “loading” until the image has arrived.

2

Resize the window as the “loading” message is
displayed. Notice that the proxy is handling the loading
without hanging up the Swing window.

3

Add your own favorite CDs to the ImageProxyTestDrive.

you are here 4
Download at WoweBook.Com

469

behind the scenes with image proxy

What did we do?
1

Behind

We created an ImageProxy for the display. The paintIcon()
method is called and ImageProxy ﬁres off a thread to
retrieve the image and create the ImageIcon.

tes a
ImageProxy creaantiate the
thread to instch starts
ImageIcon, whi image.
retrieving the

xy

paintIcon()

the Scenes

ro
ImageP

Im
ag

get image

eIcon

displays loading
message

image retrieved

2

3

At some point the image is returned and
the ImageIcon fully instantiated.

Im
ag

After the ImageIcon is created, the next time paintIcon() is
called, the proxy delegates to the ImageIcon.

paintIcon()

xy

paintIcon()

ro
ImageP

displays the real image

470

eIcon

Chapter 11
Download at WoweBook.Com

Im
ag

eIcon

Some image
server on
the Internet

the proxy pattern

there are no

Q:

The Remote Proxy and Virtual
Proxy seem so different to me; are
they really ONE pattern?

A:

You’ll ﬁnd a lot of variants of the
Proxy Pattern in the real world; what
they all have in common is that they
intercept a method invocation that
the client is making on the subject.
This level of indirection allows us to
do many things, including dispatching
requests to a remote subject, providing
a representative for an expensive
object as it is created, or, as you’ll see,
providing some level of protection that
can determine which clients should be
calling which methods. That’s just the
beginning; the general Proxy Pattern
can be applied in many different ways,
and we’ll cover some of the other ways
at the end of the chapter.

Q:

ImageProxy seems just like
a Decorator to me. I mean, we are
basically wrapping one object with
another and then delegating the
calls to the ImageIcon. What am I
missing?

A:

Sometimes Proxy and Decorator
look very similar, but their purposes are
different: a decorator adds behavior to
a class, while a proxy controls access
to it. You might say, “Isn’t the loading
message adding behavior?” In some

Dumb Questions
ways it is; however, more importantly,
the ImageProxy is controlling access
to an ImageIcon. How does it control
access? Well, think about it this way:
the proxy is decoupling the client from
the ImageIcon. If they were coupled
the client would have to wait until each
image is retrieved before it could paint
it entire interface. The proxy controls
access to the ImageIcon so that before
it is fully created, the proxy provides
another on screen representation.
Once the ImageIcon is created the
proxy allows access.

Q:

How do I make clients use the
Proxy rather than the Real Subject?

A:

Good question. One common
technique is to provide a factory that
instantiates and returns the subject.
Because this happens in a factory
method we can then wrap the subject
with a proxy before returning it. The
client never knows or cares that it’s
using a proxy instead of the real thing.

Q:

I noticed in the ImageProxy
example, you always create a new
ImageIcon to get the image, even
if the image has already been
retrieved. Could you implement
something similar to the ImageProxy
that caches past retrievals?

A:

You are talking about a specialized form of a Virtual Proxy called
a Caching Proxy. A caching proxy
maintains a cache of previous created
objects and when a request is made it
returns cached object, if possible.
We’re going to look this and at several
other variants of the Proxy Pattern at
the end of the chapter.

Q:

I see how Decorator and Proxy
relate, but what about Adapter? An
adapter seems very similar as well.

A:

Both Proxy and Adapter sit in
front of other objects and forward
requests to them. Remember that
Adapter changes the interface of
the objects it adapts, while the Proxy
implements the same interface.
There is one additional similarity that
relates to the Protection Proxy. A
Protection Proxy may allow or disallow
a client access to particular methods
in an object based on the role of the
client. In this way a Protection Proxy
may only provide a partial interface to
a client, which is quite similar to some
Adapters. We are going to take a look
at Protection Proxy in a few pages.

you are here 4
Download at WoweBook.Com

471

ﬁreside chats: proxy and decorator

Tonight’s talk: Proxy and Decorator get intentional.

Proxy

Decorator

Hello, Decorator. I presume you’re here
because people sometimes get us confused?

Me copying your ideas? Please. I control access
to objects. You just decorate them. My job is
so much more important than yours it’s just not
even funny.

Fine, so maybe you’re not entirely frivolous...
but I still don’t get why you think I’m copying
all your ideas. I’m all about representing my
subjects, not decorating them.

I don’t think you get it, Decorator. I stand in for
my Subjects; I don’t just add behavior. Clients
use me as a surrogate of a Real Subject, because
I can protect them from unwanted access, or keep
their GUIs from hanging up while they’re waiting
for big objects to load, or hide the fact that their
Subjects are running on remote machines. I’d say
that’s a very different intent from yours!

472

Well, I think the reason people get us confused
is that you go around pretending to be an
entirely different pattern, when in fact, you’re
just a Decorator in disguise. I really don’t
think you should be copying all my ideas.

“Just” decorate? You think decorating is some
frivolous unimportant pattern? Let me tell
you buddy, I add behavior. That’s the most
important thing about objects - what they do!

You can call it “representation” but if it looks
like a duck and walks like a duck... I mean, just
look at your Virtual Proxy; it’s just another
way of adding behavior to do something while
some big expensive object is loading, and your
Remote Proxy is a way of talking to remote
objects so your clients don’t have to bother
with that themselves. It’s all about behavior,
just like I said.

Call it what you want. I implement the same
interface as the objects I wrap; so do you.

Chapter 11
Download at WoweBook.Com

the proxy pattern

Proxy

Decorator

Okay, let’s review that statement. You wrap
an object. While sometimes we informally say
a proxy wraps its Subject, that’s not really an
accurate term.

Oh yeah? Why not?

Think about a remote proxy... what object am
I wrapping? The object I’m representing and
controlling access to lives on another machine!
Let’s see you do that.
Okay, but we all know remote proxies are kinda
weird. Got a second example? I doubt it.
Sure, okay, take a virtual proxy... think about
the CD viewer example. When the client ﬁrst
uses me as a proxy the subject doesn’t even
exist! So what am I wrapping there?
I never knew decorators were so dumb! Of
course I sometimes create objects, how do you
think a virtual proxy gets its subject! Okay, you
just pointed out a big difference between us:
we both know decorators only add window
dressing; they never get to instantiate anything.

Hey, after this conversation I’m convinced
you’re just a dumb proxy!

Very seldom will you ever see a proxy get into
wrapping a subject multiple times; in fact, if
you’re wrapping something 10 times, you
better go back reexamine your design.

Uh huh, and the next thing you’ll be saying is
that you actually get to create objects.

Oh yeah? Instantiate this!

Dumb proxy? I’d like to see you recursively
wrap an object with 10 decorators and keep
your head straight at the same time.

Just like a proxy, acting all real when in fact you
just stand in for the objects doing the real work.
You know, I actually feel sorry for you.
you are here 4

Download at WoweBook.Com

473

protection proxy

Using the Java API’s Proxy to create a
protection proxy
Java’s got its own proxy support right in the java.lang.reﬂect package. With this package, Java
lets you create a proxy class on the ﬂy that implements one or more interfaces and forwards
method invocations to a class that you specify. Because the actual proxy class is created at
runtime, we refer to this Java technology as a dynamic proxy.
We’re going to use Java’s dynamic proxy to create our next proxy implementation (a
protection proxy), but before we do that, let’s quickly look at a class diagram that shows how
dynamic proxies are put together. Like most things in the real world, it differs slightly from
the classic deﬁnition of the pattern:

<<interface>>
Subject

<<interface>>
InvocationHandler

request()

invoke()

consists
The Proxy nows.
of two classe
Proxy

RealSubject
request()

request()

The Proxy is generated
by Java and implements
the entire Subject
interface.

InvocationHandler
invoke()

which gets
You supply the InvocationHandler,invo
ked on the
passed all method calls that arecontrols access to
Proxy. The InvocationHandler
the methods of the RealSubject.

Because Java creates the Proxy class for you, you need a way to tell the Proxy class what to do. You can’t
put that code into the Proxy class like we did before, because you’re not implementing one directly. So, if
you can’t put this code in the Proxy class, where do you put it? In an InvocationHandler. The job of the
InvocationHandler is to respond to any method calls on the proxy. Think of the InvocationHandler as the
object the Proxy asks to do all the real work after it’s received the method calls.
Okay, let’s step through how to use the dynamic proxy...
474

Chapter 11
Download at WoweBook.Com

the proxy pattern

Matchmaking in Object ville

Hot

Not

Every town needs a matchmaking service, right? You’ve risen to the task and
implemented a dating service for Objectville. You’ve also tried to be innovative by
including a “Hot or Not” feature in the service where participants can rate each
other – you ﬁgure this keeps your customers engaged and looking through possible
matches; it also makes things a lot more fun.
Your service revolves around a Person bean that allows you to set and get information
about a person:

we’ll
interface;
This is the implementation
get to the c...
in just a se

Here we can
about the perget information
gender, inter son’s name,
HotOrNot ra ests and
ting (1-10).

public interface PersonBean {
String getName();
String getGender();
String getInterests();
int getHotOrNotRating();
void
void
void
void

setName(String name);
setGender(String gender);
setInterests(String interests);
setHotOrNotRating(int rating);

}

We can also set the same
information through the
respective method calls.

ating() takes
setHotOrNotR adds it to the
an integer and e for this person.
running averag

Now let’s check out the implementation...

you are here 4
Download at WoweBook.Com

475

personbean needs protecting

The PersonBean implementation
The PersonBeanImpl implements the PersonBean interface
public class PersonBeanImpl implements PersonBean {
String name;
String gender;
The instance variables.
String interests;
int rating;
int ratingCount = 0;
public String getName() {
return name;
}

All the getter methods; they each return
the appropriate instance variable...

public String getGender() {
return gender;
}
public String getInterests() {
return interests;
}
public int getHotOrNotRating() {
if (ratingCount == 0) return 0;
return (rating/ratingCount);
}

...except for
getHotOrNotRating(), which
computes the average of the
ratings by dividing the ratings
by the ratingCount.

public void setName(String name) {
this.name = name;
}
public void setGender(String gender) {
this.gender = gender;
}
public void setInterests(String interests) {
this.interests = interests;
}
public void setHotOrNotRating(int rating) {
this.rating += rating;
ratingCount++;
}
}

476

Chapter 11
Download at WoweBook.Com

And here’s all the setter
methods, which set the
corresponding instance variable.

Finally, the
setHotOrNotRating
method increments ()
ratingCount and ad the total
rating to the runn ds the
ing total.

the proxy pattern

I wasn’t very successful ﬁnding
dates. Then I noticed someone had changed
my interests. I also noticed that a lot of people
are bumping up their HotOrNot scores by giving
themselves high ratings. You shouldn’t be able
to change someone else’s interests or give
yourself a rating!

While we suspect other factors may be keeping Elroy from getting
dates, he is right: you shouldn’t be able to vote for yourself or to change
another customer’s data. The way our PersonBean is deﬁned, any client
can call any of the methods.
This is a perfect example of where we might be able to use a Protection
Proxy. What’s a Protection Proxy? It’s a proxy that controls access to
an object based on access rights. For instance, if we had an employee
object, a protection proxy might allow the employee to call certain
methods on the object, a manager to call additional methods (like
setSalary()), and a human resources employee to call any method on the
object.

Elroy

In our dating service we want to make sure that a customer can set his
own information while preventing others from altering it. We also want
to allow just the opposite with the HotOrNot ratings: we want the other
customers to be able to set the rating, but not that particular customer.
We also have a number of getter methods in the PersonBean, and
because none of these return private information, any customer should
be able to call them.

you are here 4
Download at WoweBook.Com

477

ﬁve minute drama

Five minute drama: protecting subjects
The Internet bubble seems a distant memory; those were the days
when all you needed to do to ﬁnd a better, higher-paying job was to
walk across the street. Even agents for software developers were
in vogue...

I’d like to make an
offer, can we get her on
the phone?

She’s tied up ... uh ...
in a meeting right now,
what did you have in
mind?

y,
ection prox ess
t
o
r
p
a
e
ik
c
L
rotects ac
the agent p ct, only letting
to his subje s through...
certain call

Joe DotCom

Agent

We think we can
meet her current
salary plus 15%.

478

Come
on. You’re wasting our
time here! Not a chance!
Come back later with a
better offer.

Chapter 11
Download at WoweBook.Com

the proxy pattern

Big Picture: creating a Dynamic Proxy
for the PersonBean
We have a couple of problems to ﬁx: customers shouldn’t be changing their own
HotOrNot rating and customers shouldn’t be able to change other customers’ personal
information. To ﬁx these problems we’re going to create two proxies: one for accessing
your own PersonBean object and one for accessing another customer’s PersonBean
object. That way, the proxies can control what requests can be made in each
circumstance.
To create these proxies we’re going to use the
Java API’s dynamic proxy that you saw a few
pages back. Java will create two proxies for us;
all we need to do is supply the handlers that
know what to do when a method is invoked on
the proxy.

<<interface>>
Subject

Create two InvocationHandlers.
InvocationHandlers implement the behavior
of the proxy. As you’ll see Java will take care
of creating the actual proxy class and object,
we just need to supply a handler that knows
what to do when a method is called on it.

invoke()

We need two
of these.
We create the
proxy itself at
runtime.

Proxy
request()

When we need to use a PersonBean object,
either it’s the object of the customer himself
(in that case, will call him the “owner”), or it’s
another user of the service that the customer is
checking out (in that case we’ll call him “nonowner”).

InvocationHandler

request()

Write the code that creates the
dynamic proxies.
We need to write a little bit of code to
generate the proxy class and instantiate it.
We’ll step through this code in just a bit.

Wrap any PersonBean object with
the appropriate proxy.

invoke()

Proxy

request()

Step two:

Step three:

<<interface>>
InvocationHandler

request()

RealSubject

Step one:

Remember this diagram
from a few pages back...

OwnerInvocationHandler
invoke()

n

When a customer is viewing his own bea

When a customer is viewing someone else

’s bean

Proxy
request()

NonOwnerInvocationHandler
invoke()

In either case, we create the appropriate proxy
for the PersonBean.
you are here 4
Download at WoweBook.Com

479

create an invocation handler

Step one: creating Invocation Handlers
We know we need to write two invocation handlers, one for the owner and one for the non-owner. But
what are invocation handlers? Here’s the way to think about them: when a method call is made on the
proxy, the proxy forwards that call to your invocation handler, but not by calling the invocation handler’s
corresponding method. So, what does it call? Have a look at the InvocationHandler interface:
<<interface>>
OwnerInvocationHandler

invoke()

There’s only one method, invoke(), and no matter what methods get called on the proxy, the invoke()
method is what gets called on the handler. Let’s see how this works:

1 Let’s say the setHotOrNotRating()
method is called on the proxy.

proxy.setHotOrNotRating(9);

2 The proxy then
turns around and
calls invoke() on the
InvocationHandler.

invoke(Object proxy, Method method, Object[] args)

3 The handler decides
what it should do
with the request
and possibly
forwards it on to
the RealSubject.
How does the
handler decide?
We’ll ﬁnd out next.

480

Here’s how we
invoke the method
on the Real
Subject.

The Method class, part of the
reflection API, tells us what
method was called on the proxy
via its getName() method.

return method.invoke(person, args);

Here we invoke the
Only now we
was
t
tha
hod
met
inal
orig
invoke it on the
is
Th
xy.
pro
the
on
led
cal
RealSubject...
in
us
to
sed
pas
was
ect
obj
the invoke call.

Chapter 11
Download at WoweBook.Com

with the original
arguments.

the proxy pattern

Creating Invocation Handlers continued...
When invoke() is called by the proxy, how do you know what to do with the call?
Typically, you’ll examine the method that was called on the proxy and make
decisions based on the method’s name and possibly its arguments. Let’s implement
the OwnerInvocationHandler to see how this works:

a.lang.reflect
InvocationHandler is part of theit.jav
package, so we need to import

All invocation
handlers implement
the InvocationHandler
interface.

import java.lang.reﬂect.*;
public class OwnerInvocationHandler implements InvocationHandler {
PersonBean person;
public OwnerInvocationHandler(PersonBean person) {
this.person = person;
}
public Object invoke(Object proxy, Method method, Object[] args)
throws IllegalAccessException {

}

We’re passed the
Real Subject in the
constructor and we
keep a reference to it.

Here’s the invoke
method that gets
called every time a
method is invoked
on the proxy.

If the method is a
try {
getter, we go ahead
if (method.getName().startsWith(“get”)) {
return method.invoke(person, args);
and invoke it on the
} else if (method.getName().equals(“setHotOrNotRating”)) { real subject.
throw new IllegalAccessException();
} else if (method.getName().startsWith(“set”)) {
Otherwise, if it is the
return method.invoke(person, args);
setHotOrNotRating()
}
method we disallow
} catch (InvocationTargetException e) {
it
by throwing a
e.printStackTrace();
IllegalAccessException.
}
return null;
Because we

}

If any other method is
called,
we’re just going to retu
rn
rather than take a chan null
ce.

This will happen if
the real subject
throws an exception.

are
the owner any
other set method
is fine and we go
ahead and invoke
it on the real
subject.

you are here 4
Download at WoweBook.Com

481

create your own invocation handler

Exercise

482

The NonOwnerInvocationHandler works just like the
OwnerInvocationHandler except that it allows calls to setHotOrNotRating()
and it disallows calls to any other set method. Go ahead and write this
handler yourself:

Chapter 11
Download at WoweBook.Com

the proxy pattern

Step t wo: creating the Proxy class and
instantiating the Proxy object
Now, all we have left is to dynamically create the proxy class and instantiate the proxy object. Let’s start by writing a
method that takes a PersonBean and knows how to create an owner proxy for it. That is, we’re going to create the
kind of proxy that forwards its method calls to the OwnerInvocationHandler. Here’s the code:

This method takes a person object (the realuse the
subject) and returns a proxy for it. Becact, we
proxy has the same interface as the subje
return a PersonBean.

This code creates the
proxy. Now this is some
mighty ugly code, so let’s
step through it carefully.

PersonBean getOwnerProxy(PersonBean person) {
return (PersonBean) Proxy.newProxyInstance(
person.getClass().getClassLoader(),
person.getClass().getInterfaces(),
new OwnerInvocationHandler(person));
}

We pass the real subject into the constructor
of the invocation handler. If you look back
two pages you’ll see this is how the handler gets
access to the real subject.

Sharpen your pencil

To create a proxy we use
the static newProxyInstance
method on the Proxy class...
We pass it the classloader
for our subject...
...and the set of interfaces the
proxy needs to implement...

...and an invocation handler, in this
case our OwnerInvocationHandler.

While it is a little complicated, there isn’t much to creating a dynamic proxy.
Why don’t you write getNonOwnerProxy(), which returns a proxy for the
NonOwnerInvocationHandler:

Take it further: can you write one method getProxy() that takes a
handler and a person and returns a proxy that uses that handler?
you are here 4
Download at WoweBook.Com

483

ﬁnd your match

Testing the matchmaking ser vice
Let’s give the matchmaking service a test run and see how it controls access to the
setter methods based on the proxy that is used.

public class MatchMakingTestDrive {
// instance variables here

Main just creates the test
drive and calls its drive()
method to get things going.

public static void main(String[] args) {
MatchMakingTestDrive test = new MatchMakingTestDrive();
test.drive();
}

The constructor initializes
our DB of people in the
matchmaking service.

public MatchMakingTestDrive() {
initializeDatabase();
}
Let’s retrieve a
public void drive() {
person from the DB
PersonBean joe = getPersonFromDatabase(“Joe Javabean”);
PersonBean ownerProxy = getOwnerProxy(joe);
...and create an
System.out.println(“Name is “ + ownerProxy.getName());
owner proxy.
ownerProxy.setInterests(“bowling, Go”);
Call a getter
System.out.println(“Interests set from owner proxy”);
try {
and then a setter
ownerProxy.setHotOrNotRating(10);
and then try to
} catch (Exception e) {
change the rating.
System.out.println(“Can’t set rating from owner proxy”);
}
System.out.println(“Rating is “ + ownerProxy.getHotOrNotRating()); this shouldn’t work!

}

PersonBean nonOwnerProxy = getNonOwnerProxy(joe);
Now create a nonSystem.out.println(“Name is “ + nonOwnerProxy.getName());
owner proxy
try {
...and call a getter
nonOwnerProxy.setInterests(“bowling, Go”);
followed by a
} catch (Exception e) {
System.out.println(“Can’t set interests from non owner proxy”); setter
}
This shouldn’t work!
nonOwnerProxy.setHotOrNotRating(3);
System.out.println(“Rating set from non owner proxy”);
System.out.println(“Rating is “ + nonOwnerProxy.getHotOrNotRating()); Then try to

set the rating

// other methods like getOwnerProxy and getNonOwnerProxy here
}

484

This should work!

Chapter 11
Download at WoweBook.Com

the proxy pattern

Running the code...
File Edit Window Help Born2BDynamic

% java MatchMakingTestDrive
Name is Joe Javabean
Interests set from owner proxy
Can’t set rating from owner proxy

Our Owner proxy
allows getting and
setting, except for
the HotOrNot rating.

Rating is 7
Name is Joe Javabean
Can’t set interests from non owner proxy
Rating set from non owner proxy
Rating is 5
%

Our NonOwner proxy
allows getting only, but
also allows calls to set the
HotOrNot rating.

The new rating is the average of the previous rating, 7
and the value set by the nonowner proxy, 3.

you are here 4
Download at WoweBook.Com

485

q&a about proxy

there are no

Dumb Questions

Q:

So what exactly is the
“dynamic” aspect of dynamic
proxies? Is it that I’m instantiating
the proxy and setting it to a handler
at runtime?

A:

A:

Yes. The Proxy class has a static
method called isProxyClass(). Calling
this method with a class will return
true if the class is a dynamic proxy
class. Other than that, the proxy class
will act like any other class that implements a particular set of interfaces.

No, the proxy is dynamic
because its class is created at runtime.
Think about it: before your code runs
there is no proxy class; it is created on
demand from the set of interfaces you
pass it.

Q:

Q:

A:

That is because the
InvocationHandler isn’t a proxy − it is
a class that the proxy dispatches to
for handling method calls. The proxy
itself is created dynamically at runtime
by the static Proxy.newProxyInstance()
method.

Yes, there are a few. First, it is
worth pointing out that we always
pass newProxyInstance() an array of
interfaces – only interfaces are allowed,
no classes. The major restrictions are
that all non-public interfaces need to
be from the same package. You also
can’t have interfaces with clashing
method names (that is, two interfaces
with a method with the same
signature). There are a few other minor
nuances as well, so at some point you
should take a look at the ﬁne print on
dynamic proxies in the javadoc.

Q:

Q:

My InvocationHandler seems
like a very strange proxy, it doesn’t
implement any of the methods of
the class it’s proxying.

Is there any way to tell if a
class is a Proxy class?

486

Are there any restrictions on
the types of interfaces I can pass into
newProxyInstance()?

A:

Why are you using skeletons?
I thought we got rid of those back in
Java 1.2.

Chapter 11
Download at WoweBook.Com

A:

You’re right; we don’t need
to actually generate skeletons. As
of Java 1.2, the RMI runtime can
dispatch the client calls directly to
the remote service using reﬂection.
But we like to show the skeleton,
because conceptually it helps you to
understand that there is something
under the covers that’s making that
communication between the client
stub and the remote service happen.

Q:

I heard that in Java 5, I
don’t even need to generate stubs
anymore either. Is that true?

A:

It sure is. In Java 5, RMI and
Dynamic Proxy got together and now
stubs are generated dynamically using
Dynamic Proxy. The remote object’s
stub is a java.lang.reﬂect.Proxy instance
(with an invocation handler) that is
automatically generated to handle all
the details of getting the local method
calls by the client to the remote object.
So, now you don’t have to use rmic at
all; everything you need to get a client
talking to a remote object is handled
for you behind the scenes.

the proxy pattern

Match each pattern with its description:

Pattern

Description

Decorator

Wraps another object
and provides a different
interface to it

Facade

Wraps another object
and provides additional
behavior for it

Proxy

Wraps another object to
control access to it

Adapter

Wraps a bunch of
objects to simplify their
interface

you are here 4
Download at WoweBook.Com

487

the proxy zoo

The Proxy Zoo
Welcome to the Objectville Zoo!
You now know about the remote, virtual and protection proxies, but
out in the wild you’re going to see lots of mutations of this pattern.
Over here in the Proxy corner of the zoo we’ve got a nice collection
of wild proxy patterns that we’ve captured for your study.
Our job isn’t done; we are sure you’re going to see more variations of
this pattern in the real world, so give us a hand in cataloging more
proxies. Let’s take a look at the existing collection:

Firewall Proxy
controls access to a
set of network
resources, protecting
the subject from “bad” clients.

Habitat: often seen in the location
of corporate firewall systems.

Help find a habitat
Smart Reference Proxy
provides additional actions
whenever a subject is
referenced, such as counting
the number of references to
an object.

Caching Proxy provides
temporary storage for
results of operations
that are expensive. It
can also allow multiple clients to share
the results to reduce computation or
network latency.

488

Habitat: often seen in web server proxies as well
as content management and publishing systems.

Chapter 11
Download at WoweBook.Com

the proxy pattern

Seen hanging around
it controls synchronizJaedvaSpaces, where
an underlying set of ob access to
distributed environmentjects in a
.

Synchronization Proxy
provides safe access to
a subject from multiple
threads.

Complexity Hiding Proxy
hides the complexity of
and controls access to a
complex set of classes.
This is sometimes called
the Facade Proxy for obvious reasons.
The Complexity Hiding Proxy differs
from the Facade Pattern in that the
proxy controls access, while the Facade
Pattern just provides an alternative
interface.

Help find a habitat

Copy-On-Write Proxy
controls the copying of
an object by deferring
the copying of an
object until it is required by
a client. This is a variant of
the Virtual Proxy.

Habitat: seen in the vicinity of the
Java 5’s CopyOnWriteArrayList.

Field Notes: please add your observations of other proxies in the wild here:

you are here 4
Download at WoweBook.Com

489

crossword puzzle

It’s been a LONG chapter. Why not unwind by doing a
crossword puzzle before it ends?

�

�

�
�

�

�

�

�

�
��
��

��
��
��

��
��

��
��

490

��

������

����

�� ����� �� ����� �� ����� ��������� ���� ������
�� ����� ���� ������ �� ��� ��������� �������
�� �� ���� ��� �� ����� �� ����� ���
�� ������ �������� ��� ���� �� ���������
��� ������� ������� ������� ���� ������
�� �������� ��������� ����� ��� ����� ���� ����
��������
����������������������������������������������
�������� �� ��� ������� ����
��� ����� ���� �������� ������ ����� ����
������������ �������
��� � ������� ����� ����� �� ������� �� �������
��� ����� �� ����� ����� ��� ���� ����� ��������
��� �������� ���� ����� ��� ��� �������� ����
������
������������������������������������
��� ��� �� ������ ���� ���� ���� �� �����

�� ������ ������� ����� �������� ��� �������� ��
���� ���� ������
��������������������������������������
�� ���� ������� ���� �� � ������ ������� ��� ���
�������������������������������
��� ������� �� ������ ��� ���� � ��������� �������
��� ����������� ����������� ������� ������
������
��� ��� ����� �������� ��� ������� �������
��������� ��� ��� �������

Chapter 11
Download at WoweBook.Com

the proxy pattern

Tools for your Design Toolbox
Your design toolbox is almost full; you’re prepared
for almost any design problem that comes your way.

s
OO Principesle.

OO Basics

OO Patternasfames ilya oofneal-gotori-tmhmas,ny

ß The Proxy Pattern provides
a representative for another
object in order to control the
client’s access to it. There
are a number of ways it can
manage that access.

Abstraction
n
Encapsulatio
vari
at
h
w
e
t
la
Encapsu
ance. Polymorphism
over inherit
n
io
t
si
po
m
Favor co
t
Inheritance
terfaces, no
o in
Program tat
ions.
t
en
em
impl
led designs
loosely coup
Strive for jects that interact.
between ob
or extension
ld be openicfation.
ou
sh
es
ss
la
C
or modif
but closed f
. Do not
abstractions
Depend on concrete classes.
depend on
ds.
o your frien
Only talk t
u.
, we’ll call yo
Don’t call us
e reason
have only on
ld
ou
sh
s
as
A cl
to change.

BULLET POINTS

ß A Remote Proxy manages
interaction between a client
and a remote object.

ß A Virtual Proxy controls access
to an object that is expensive
to instantiate.

ter,
s this chap
le
ip
c
in
r
p
No new se the book and
can you clothem all?
remember

noaavitl de an
defin mtak
defines
mitPio
sddso
StrOabtesgeyrv-erearacht-oonerte,w-an
- tyrirhnD
Adntaocbatcjeesohcrttayhe
e
e
emitsficsoinafellya.n
d
go
F
b
o
t
al
es
c
y
jeohegcadtfea,maillltieahm
nrlegeeetatosstbhintst
t
a
puleeatnAdbensctlebrilc. itatScieotctra
encadpseD
y
M
o
eg
t
t
y
n
s
r
a
h
c
dsshcootun,tlybuhas est
atdaensaitcotwla.beitje
siraofbajece tfor creiecnt
nF
ab
ib
o
trgueleus
ge
x
in
sp
ha
p
t
le
an
e
e
t
a
f
r
n
s
ch
e
o
d
r
a
n
n
su
e
c
n
e
inter
d
g
cl
h
t
o
o
d
je
E
vi
w in rinadteneotrlyafsragpfecle
omeftpoif
ctaelaes.ntssgdloeinstbal rpeoqinuqtuest
endlaiede-enssctinido-gebpEfwronohrcviiccaladehpxesu
cnrodeenelanteSsdinorrroendsstosu
inpdeeep
ss
c
varydeD
b
d
s
e
d
s a rue
n
e
t
n
a
e
a
nleatoaivysu
haem.niracpeFctoancectr.r,ort-yhEeMrnecebatyphsuoledlattleinetseginygaoeryeonqutuest
nlleineybCgtcinolaotstm
auatltomespratetincioicifst
t
it
e
je
h
d
t
b
t
t
o
.
o
le
A
t
y
ia
suhla deifs f fertyeonutalter its
aecnettc,-ialitetEhnioetnrncseawbtpyoit
func noaaflintatscdcaaeesnfssF
st
je
b
d
in
o
a
iz
r
ds,tifincatgnd
n
c
r
e
a
e
a
t
e
m
s.
a classpara menttqeuoarebtizujeeeecot-cr,liAetlonllhgtoesrwreewbaqitynuehleostbteje
ast
fnredaortgeeanttcehaonrge
s,su
if
l
st
d
a
r
n
u
a
a
h
S
r
q
r
s,
s
e
s.
a
it
a
r
e
t
p
st
a
w
s.
e
in
ss
g
n
s
e
u
la
s
t
lo
q
d
io
subc re estms,hdeaoqtviaueorberrleuoizexweooyhpcreli-nreanit
P oaubceletuewoopilerPeltrralofaoptogviprioeranaers.nqoutteosthecs,rhaoanbngdjee cittsto
suprpeoqpruatrbuaten st
qcehold
u
tions.
suprpeoqrTuhee npos,dlabje
oableccoepsserato it.
u
.
t
supcplaorssconntdrol a

Our new pattern.
A Proxy acts as a
representative for
another object.

ß A Protection Proxy controls
access to the methods of an
object based on the caller.

ß Many other variants of
the Proxy Pattern exist
including caching proxies,
synchronization proxies,
firewall proxies, copy-on-write
proxies, and so on.

ß Proxy is structurally similar to
Decorator, but the two differ in
their purpose.

ß The Decorator Pattern adds
behavior to an object, while a
Proxy controls access.

ß Java’s built-in support for Proxy
can build a dynamic proxy
class on demand and dispatch
all calls on it to a handler of
your choosing.

ß Like any wrapper, proxies will
increase the number of classes
and objects in your designs.

you are here 4
Download at WoweBook.Com

491

exercise solutions

Exercise solutions
Exercise

The NonOwnerInvocationHandler works just like the
OwnerInvocationHandler, except that it allows calls to setHotOrNotRating()
and it disallows calls to any other set method. Go ahead and write this
handler yourself:

import java.lang.reﬂect.*;
public class NonOwnerInvocationHandler implements InvocationHandler {
PersonBean person;
public NonOwnerInvocationHandler(PersonBean person) {
this.person = person;
}
public Object invoke(Object proxy, Method method, Object[] args)
throws IllegalAccessException {
try {
if (method.getName().startsWith(“get”)) {
return method.invoke(person, args);
} else if (method.getName().equals(“setHotOrNotRating”)) {
return method.invoke(person, args);
} else if (method.getName().startsWith(“set”)) {
throw new IllegalAccessException();
}
} catch (InvocationTargetException e) {
e.printStackTrace();
}
return null;
}
}

Design Class

Our ImageProxy class appears to have two states that are controlled
by conditional statements. Can you think of another pattern that
might clean up this code? How would you redesign ImageProxy?

Use State Pattern: implement two states, ImageLoaded and ImageNotLoaded. Then put the code from
the if statements into their respective states. Start in the ImageNotLoaded state and then transition to the
ImageLoaded state once the ImageIcon had been retrieved.
492

Chapter 11
Download at WoweBook.Com

the proxy pattern

Exercise solutions
Sharpen your pencil

While it is a little complicated, there isn’t much to creating a dynamic
proxy. Why don’t you write getNonOwnerProxy(), which returns a
proxy for the NonOwnerInvocationHandler:

PersonBean getNonOwnerProxy(PersonBean person) {
return (PersonBean) Proxy.newProxyInstance(
person.getClass().getClassLoader(),
person.getClass().getInterfaces(),
new NonOwnerInvocationHandler(person));
}

�

�

�

�

�

�

�

�

� �

�

�
�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

��

�

�

�

�

�

�

�

�

�

�

�

�

��

�

�

�

�

�

�

�

�

�

��

�
��

�

�

�

�

�

�

�

�

�

�

�

�
��

�

�

�

�

�

�

�

�

�

�

�

�

�

� �

�

�

�

�

�

��

�

�

�

�

�
��

�

�

�

�

�

�

�

�

�

�
��

��

�

������

�

�

�

�

����

�

�

�

you are here 4

������������������������������������������
����������������������������������������������
Download at WoweBook.Com
�������������������
����������������������������������������

493

ready-bake code: cd cover viewer

Ready-bake
Code

The code for the CD Cover Viewer

package headﬁrst.proxy.virtualproxy;
import java.net.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
public class ImageProxyTestDrive {
ImageComponent imageComponent;
JFrame frame = new JFrame(“CD Cover Viewer”);
JMenuBar menuBar;
JMenu menu;
Hashtable cds = new Hashtable();
public static void main (String[] args) throws Exception {
ImageProxyTestDrive testDrive = new ImageProxyTestDrive();
}
public ImageProxyTestDrive() throws Exception{
cds.put(“Ambient: Music for Airports”,”http://images.amazon.com/images/P/
B000003S2K.01.LZZZZZZZ.jpg”);
cds.put(“Buddha Bar”,”http://images.amazon.com/images/P/B00009XBYK.01.LZZZZZZZ.
jpg”);
cds.put(“Ima”,”http://images.amazon.com/images/P/B000005IRM.01.LZZZZZZZ.jpg”);
cds.put(“Karma”,”http://images.amazon.com/images/P/B000005DCB.01.LZZZZZZZ.gif”);
cds.put(“MCMXC A.D.”,”http://images.amazon.com/images/P/B000002URV.01.LZZZZZZZ.
jpg”);
cds.put(“Northern Exposure”,”http://images.amazon.com/images/P/B000003SFN.01.
LZZZZZZZ.jpg”);
cds.put(“Selected Ambient Works, Vol. 2”,”http://images.amazon.com/images/P/
B000002MNZ.01.LZZZZZZZ.jpg”);
cds.put(“oliver”,”http://www.cs.yale.edu/homes/freeman-elisabeth/2004/9/Oliver_
sm.jpg”);
URL initialURL = new URL((String)cds.get(“Selected Ambient Works, Vol. 2”));
menuBar = new JMenuBar();
menu = new JMenu(“Favorite CDs”);
menuBar.add(menu);
frame.setJMenuBar(menuBar);

494

Chapter 11
Download at WoweBook.Com

the proxy pattern

for(Enumeration e = cds.keys(); e.hasMoreElements();) {
String name = (String)e.nextElement();
JMenuItem menuItem = new JMenuItem(name);
menu.add(menuItem);
menuItem.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {
imageComponent.setIcon(new ImageProxy(getCDUrl(event.getActionCommand())));
frame.repaint();
}
});
}
// set up frame and menus
Icon icon = new ImageProxy(initialURL);
imageComponent = new ImageComponent(icon);
frame.getContentPane().add(imageComponent);
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
frame.setSize(800,600);
frame.setVisible(true);
}
URL getCDUrl(String name) {
try {
return new URL((String)cds.get(name));
} catch (MalformedURLException e) {
e.printStackTrace();
return null;
}
}
}

you are here 4
Download at WoweBook.Com

495

ready-bake code: cd cover viewer

Ready-bake
Code

The code for the CD Cover Viewer,
continued...

package headﬁrst.proxy.virtualproxy;
import java.net.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
class ImageProxy implements Icon {
ImageIcon imageIcon;
URL imageURL;
Thread retrievalThread;
boolean retrieving = false;
public ImageProxy(URL url) { imageURL = url; }
public int getIconWidth() {
if (imageIcon != null) {
return imageIcon.getIconWidth();
} else {
return 800;
}
}
public int getIconHeight() {
if (imageIcon != null) {
return imageIcon.getIconHeight();
} else {
return 600;
}
}
public void paintIcon(ﬁnal Component c, Graphics g, int x, int y) {
if (imageIcon != null) {
imageIcon.paintIcon(c, g, x, y);
} else {
g.drawString(“Loading CD cover, please wait...”, x+300, y+190);
if (!retrieving) {
retrieving = true;
retrievalThread = new Thread(new Runnable() {
public void run() {
try {
imageIcon = new ImageIcon(imageURL, “CD Cover”);
c.repaint();
} catch (Exception e) {

496

Chapter 11
Download at WoweBook.Com

the proxy pattern

e.printStackTrace();
}
}
});
retrievalThread.start();
}
}
}
}

package headﬁrst.proxy.virtualproxy;
import java.awt.*;
import javax.swing.*;
class ImageComponent extends JComponent {
private Icon icon;
public ImageComponent(Icon icon) {
this.icon = icon;
}
public void setIcon(Icon icon) {
this.icon = icon;
}
public void paintComponent(Graphics g) {
super.paintComponent(g);
int w = icon.getIconWidth();
int h = icon.getIconHeight();
int x = (800 - w)/2;
int y = (600 - h)/2;
icon.paintIcon(this, g, x, y);
}
}

you are here 4
Download at WoweBook.Com

497

Download at WoweBook.Com

12 Compound Patterns

h Patterns

g

of Patterns

g

Who would have ever guessed that Patterns could work together?
You’ve already witnessed the acrimonious Fireside Chats (and you haven’t even seen the Pattern
Death Match pages that the editor forced us to remove from the book*), so who would have thought
patterns can actually get along well together? Well, believe it or not, some of the most powerful OO
designs use several patterns together. Get ready to take your pattern skills to the next level; it’s time
for compound patterns.

* send us email for a copy.
this is a new chapter
Download at WoweBook.Com

499

patterns can work together

Working together
One of the best ways to use patterns is to get them out of the house so they
can interact with other patterns. The more you use patterns the more you’re
going to see them showing up together in your designs. We have a special
name for a set of patterns that work together in a design that can be applied
over many problems: a compound pattern. That’s right, we are now talking
about patterns made of patterns!
You’ll ﬁnd a lot of compound patterns in use in the real world. Now that
you’ve got patterns in your brain, you’ll see that they are really just patterns
working together, and that makes them easier to understand.
We’re going to start this chapter by revisiting our friendly ducks in the
SimUDuck duck simulator. It’s only ﬁtting that the ducks should be here
when we combine patterns; after all, they’ve been with us throughout the
entire book and they’ve been good sports about taking part in lots of patterns.
The ducks are going to help you understand how patterns can work together
in the same solution. But just because we’ve combined some patterns doesn’t
mean we have a solution that qualiﬁes as a compound pattern. For that, it
has to be a general purpose solution that can be applied to many problems.
So, in the second half of the chapter we’ll visit a real compound pattern:
that’s right, Mr. Model-View-Controller himself. If you haven’t heard of
him, you will, and you’ll ﬁnd this compound pattern is one of the most
powerful patterns in your design toolbox.

Patterns are often used together and
combined within the same design solution.
A compound pattern combines two or
more patterns into a solution that solves a
recurring or general problem.

500

Chapter 12
Download at WoweBook.Com

compound patterns

Duck reunion
As you’ve already heard, we’re going to get to work with the ducks again. This time the ducks
are going to show you how patterns can coexist and even cooperate within the same solution.
We’re going to rebuild our duck simulator from scratch and give it some interesting capabilities
by using a bunch of patterns. Okay, let’s get started...

1

First, we’ll create a Quackable interface.
Like we said, we’re starting from scratch. This time around, the Ducks are
going to implement a Quackable interface. That way we’ll know what things
in the simulator can quack() – like Mallard Ducks, Redhead Ducks, Duck
Calls, and we might even see the Rubber Duck sneak back in.

public interface Quackable {
public void quack();
}

2

do
nly need to
o
s
le
b
a
k
c
a
u
Q
ll: Quack!
one thing we

Now, some Ducks that implement Quackable
What good is an interface without some classes to implement it? Time to
create some concrete ducks (but not the “lawn art” kind, if you know what
we mean).

public class MallardDuck implements Quackable {
public void quack() {
System.out.println(“Quack”);
}
}

public class RedheadDuck implements Quackable {
public void quack() {
System.out.println(“Quack”);
}
}

rd
Your standa k.
Mallard duc

We’ve got to have some variation
of species if we want this to be an
interesting simulator.

you are here 4
Download at WoweBook.Com

501

adding more ducks

This wouldn’t be much fun if we didn’t add other kinds of Ducks too.
Remember last time? We had duck calls (those things hunters use, they
are deﬁnitely quackable) and rubber ducks.
public class DuckCall implements Quackable {
public void quack() {
System.out.println(“Kwak”);
}
}

A DuckCall that quacks but doesn’t
sound quite like the real thing.

public class RubberDuck implements Quackable {
public void quack() {
System.out.println(“Squeak”);
}
}

3

A RubberDuck that makes a
squeak when it quacks.

Okay, we’ve got our ducks; now all we need is a simulator.
Let’s cook up a simulator that creates a few ducks and makes sure their
quackers are working...
public class DuckSimulator {
public static void main(String[] args) {
DuckSimulator simulator = new DuckSimulator();
simulator.simulate();
}
void simulate() {
Quackable mallardDuck = new MallardDuck();
Quackable redheadDuck = new RedheadDuck();
Quackable duckCall = new DuckCall();
Quackable rubberDuck = new RubberDuck();

to
Here’s our main method
get everything going.
We create a simulator
and then call its
simulate() method.
We need some ducks, so
here we create one of
each Quackable...

System.out.println(“\nDuck Simulator”);
simulate(mallardDuck);
simulate(redheadDuck);
simulate(duckCall);
simulate(rubberDuck);
}
void simulate(Quackable duck) {
duck.quack();
}
}

502

... then we simulate
each one.

Here we overload the simulate
method to simulate just one duck.

Here we let polymorphism do its magic: no
matter what kind of Quackable gets passed in,
the simulate() method asks it to quack.

Chapter 12
Download at WoweBook.Com

compound patterns

Not too excit
haven’t added ing yet, but we
patterns!

File Edit Window Help ItBetterGetBetterThanThis

% java DuckSimulator
Duck Simulator
Quack
Quack
Kwak
Squeak

%

ackable
They all implement the same Quations
interface, but their implement n way.
allow them to quack in their ow
It looks like everything is working; so far, so good.

4

When ducks are around, geese can’t be far.
Where there is one waterfowl, there are probably two. Here’s a Goose
class that has been hanging around the simulator.

public class Goose {
public void honk() {
System.out.println(“Honk”);
}
}

A Goose is a honker,
not a quacker.

A

brain
power

Let’s say we wanted to be able to use a Goose anywhere we’d want to use a Duck. After all, geese
make noise; geese ﬂy; geese swim. Why can’t we have Geese in the simulator?
What pattern would allow Geese to easily intermingle with Ducks?

you are here 4
Download at WoweBook.Com

503

goose adapter

5

We need a goose adapter.
Our simulator expects to see Quackable interfaces. Since geese
aren’t quackers (they’re honkers), we can use an adapter to adapt
a goose to a duck.

public class GooseAdapter implements Quackable {
Goose goose;
public GooseAdapter(Goose goose) {
this.goose = goose;
}
public void quack() {
goose.honk();
}

Remember, an Adapter interface,
implements the target ackable.
which in this case is Qu
The constructor takes the
goose we are going to adapt.

When quack is called, the call is delegated
to the goose’s honk() method.

}

6

Now geese should be able to play in the simulator, too.
All we need to do is create a Goose, wrap it in an adapter that
implements Quackable, and we should be good to go.
public class DuckSimulator {
public static void main(String[] args) {
DuckSimulator simulator = new DuckSimulator();
simulator.simulate();
}
void simulate() {
ts like
Quackable mallardDuck = new MallardDuck();
make a Goose that acGoose
e
W
e
Quackable redheadDuck = new RedheadDuck();
a Duck by wrapping th
Quackable duckCall = new DuckCall();
.
er
pt
da
eA
in the Goos
Quackable rubberDuck = new RubberDuck();
Quackable gooseDuck = new GooseAdapter(new Goose());
System.out.println(“\nDuck Simulator: With Goose Adapter”);
simulate(mallardDuck);
simulate(redheadDuck);
simulate(duckCall);
simulate(rubberDuck);
simulate(gooseDuck);

Once the Goose is wrapped, we can treat
it just like other duck Quackables.

}
void simulate(Quackable duck) {
duck.quack();
}
}

504

Chapter 12
Download at WoweBook.Com

compound patterns

7

Now let’s give this a quick run....
This time when we run the simulator, the list of objects passed
to the simulate() method includes a Goose wrapped in a duck
adapter. The result? We should see some honking!

File Edit Window Help GoldenEggs

% java DuckSimulator

There’s the goose! Now the
Goose can quack with the
rest of the Ducks.

Duck Simulator: With Goose Adapter
Quack
Quack
Kwak
Squeak
Honk

%

Quackology
Quackologists are fascinated by all aspects of Quackable behavior. One
thing Quackologists have always wanted to study is the total number of
quacks made by a ﬂock of ducks.
How can we add the ability to count duck quacks without having to
change the duck classes?
Can you think of a pattern that would help?

J. Brewer,
Park Ranger and
Quackologist

you are here 4
Download at WoweBook.Com

505

duck decorator

8

We’re going to make those Quackologists happy and give
them some quack counts.
How? Let’s create a decorator that gives the ducks some new
behavior (the behavior of counting) by wrapping them with a
decorator object. We won’t have to change the Duck code at all.

Like with Adapter, we need to
implement the target interface.
We’ve got an instance variable
to hold on to the quacker
we’re decorating.
public class QuackCounter implements Quackable {
Quackable duck;
And we’re counting ALL
static int numberOfQuacks;
quacks, so we’ll use a static
variable to keep track.
public QuackCounter (Quackable duck) {
QuackCounter is a decorator

this.duck = duck;

We get the reference to the
Quackable we’re decorating in
the constructor.

}
public void quack() {
duck.quack();
numberOfQuacks++;
}
public static int getQuacks() {
return numberOfQuacks;
}

When quack() is ca
the Quackable we’rlled, we delegate the call to
e decorating...
... then we increase
the number of quac
ks.

}

We’re adding one other method
to the decorator. This static
method just returns the number
of quacks that have occurred
in all Quackables.

506

Chapter 12
Download at WoweBook.Com

compound patterns
9

We need to update the simulator to create decorated ducks.
Now, we must wrap each Quackable object we instantiate in a
QuackCounter decorator. If we don’t, we’ll have ducks running
around making uncounted quacks.
public class DuckSimulator {
public static void main(String[] args) {
Each time we create a
DuckSimulator simulator = new DuckSimulator();
Quackable, we wrap it
simulator.simulate();
with a new decorator.
}
void simulate() {
Quackable mallardDuck = new QuackCounter(new MallardDuck());
Quackable redheadDuck = new QuackCounter(new RedheadDuck());
Quackable duckCall = new QuackCounter(new DuckCall());
Quackable rubberDuck = new QuackCounter(new RubberDuck());
Quackable gooseDuck = new GooseAdapter(new Goose());
System.out.println(“\nDuck Simulator: With Decorator”);

The park ranger told us he didn’t
want to count geese honks, so we
don’t decorate it.

simulate(mallardDuck);
simulate(redheadDuck);
simulate(duckCall);
simulate(rubberDuck);
simulate(gooseDuck);

}

Here’s where we

System.out.println(“The ducks quacked “ +
gather the quacking
QuackCounter.getQuacks() + “ times”); behavior for the

Quackologists.

void simulate(Quackable duck) {
duck.quack();
}
}

e decorated
Nothing changes here; th s.
objects are still Quackable

File Edit Window Help DecoratedEggs

Here’s the
output!
e’re
Remember, w geese.
g
not countin

% java DuckSimulator
Duck Simulator: With Decorator
Quack
Quack
Kwak
Squeak
Honk
4 quacks were counted
%

you are here 4
Download at WoweBook.Com

507

duck factory

This quack counting is
great. We’re learning things we
never knew about the little quackers.
But we’re ﬁnding that too many
quacks aren’t being counted. Can
you help?

You have to decorate objects
to get decorated behavior.
He’s right, that’s the problem with wrapping objects:
you have to make sure they get wrapped or they don’t
get the decorated behavior.
Why don’t we take the creation of ducks and localize
it in one place; in other words, let’s take the duck
creation and decorating and encapsulate it.
What pattern does that sound like?

10

We need a factory to produce ducks!
Okay, we need some quality control to make sure our ducks get wrapped.
We’re going to build an entire factory just to produce them. The factory
should produce a family of products that consists of different types of
ducks, so we’re going to use the Abstract Factory Pattern.
Let’s start with the deﬁnition of the AbstractDuckFactory:

public abstract class AbstractDuckFactory {
public
public
public
public

abstract
abstract
abstract
abstract

Quackable
Quackable
Quackable
Quackable

t factory
We’re defining an abstrac nt to
that subclasses will impleme
s.
create different familie

createMallardDuck();
createRedheadDuck();
createDuckCall();
createRubberDuck();

}

Each method creates one kind of duck.

508

Chapter 12
Download at WoweBook.Com

compound patterns
Let’s start by creating a factory that creates ducks without decorators,
just to get the hang of the factory:
public class DuckFactory extends AbstractDuckFactory {
public Quackable createMallardDuck() {
return new MallardDuck();
}
public Quackable createRedheadDuck() {
return new RedheadDuck();
}
public Quackable createDuckCall() {
return new DuckCall();
}

DuckFactory extends the
abstract factory.

oduct:
Each method creates a prkable.
ac
Qu
a particular kind of known
The actual product is un t knows
to the simulator - it jus.
it’s getting a Quackable

public Quackable createRubberDuck() {
return new RubberDuck();
}
}

Now let’s create the factory we really want, the CountingDuckFactory:

CountingDuckFactory
also extends the
abstract factory.

public class CountingDuckFactory extends AbstractDuckFactory {
public Quackable createMallardDuck() {
return new QuackCounter(new MallardDuck());
}
public Quackable createRedheadDuck() {
return new QuackCounter(new RedheadDuck());
}
public Quackable createDuckCall() {
return new QuackCounter(new DuckCall());
}

Each method wraps the
Quackable with the quack
counting decorator. The
simulator will never know
the difference; it just
gets back a Quackable.
But now our rangers can
be sure that all quacks are
being counted.

public Quackable createRubberDuck() {
return new QuackCounter(new RubberDuck());
}
}

you are here 4
Download at WoweBook.Com

509

families of ducks

Let’s set up the simulator to use the factory.

11

Remember how Abstract Factory works? We create a polymorphic method
that takes a factory and uses it to create objects. By passing in different
factories, we get to use different product families in the method.
We’re going to alter the simulate() method so that it takes a factory and
uses it to create ducks.

public class DuckSimulator {
public static void main(String[] args) {
DuckSimulator simulator = new DuckSimulator();
AbstractDuckFactory duckFactory = new CountingDuckFactory();

te
First we crea
y
r
the facto oing
that we’re g
to pass into )
the simulate(
method.

simulator.simulate(duckFactory);
}

The simulate()
method takes an
AbstractDuckFactory
and uses it to create
ducks rather than
instantiating them
directly
.
Factory”);

void simulate(AbstractDuckFactory duckFactory) {
Quackable mallardDuck = duckFactory.createMallardDuck();
Quackable redheadDuck = duckFactory.createRedheadDuck();
Quackable duckCall = duckFactory.createDuckCall();
Quackable rubberDuck = duckFactory.createRubberDuck();
Quackable gooseDuck = new GooseAdapter(new Goose());
System.out.println(“\nDuck Simulator: With Abstract
simulate(mallardDuck);
simulate(redheadDuck);
simulate(duckCall);
simulate(rubberDuck);
simulate(gooseDuck);
System.out.println(“The ducks quacked “ +
QuackCounter.getQuacks() +
“ times”);
}
void simulate(Quackable duck) {
duck.quack();
}
}

510

Chapter 12
Download at WoweBook.Com

Nothing changes here!
Same ol’ code.

compound patterns

Here’s the output using the factory...

File Edit Window Help EggFactory

% java DuckSimulator
Duck Simulator: With Abstract Factory
Quack
Quack
Kwak
Squeak
Honk
4 quacks were counted
%

time, but
Same as last re ensuring
this time we’ ks are
that the duc because
all decoratedthe
we are using kFactory.
CountingDuc

Sharpen your pencil
We’re still directly instantiating Geese by relying on concrete classes. Can you write
an Abstract Factory for Geese? How should it handle creating “goose ducks”?

you are here 4
Download at WoweBook.Com

511

ﬂock of ducks

It’s getting a little difﬁcult
to manage all these different ducks
separately. Is there any way you can
help us manage ducks as a whole, and
perhaps even allow us to manage a few
duck “families” that we’d like to keep
track of?

Ah, he wants to manage a
ﬂock of ducks.
Here’s another good question from Ranger Brewer:
Why are we managing ducks individually?

This isn’t very
manageable!

Quackable
Quackable
Quackable
Quackable
Quackable

mallardDuck = duckFactory.createMallardDuck();
redheadDuck = duckFactory.createRedheadDuck();
duckCall = duckFactory.createDuckCall();
rubberDuck = duckFactory.createRubberDuck();
gooseDuck = new GooseAdapter(new Goose());

simulate(mallardDuck);
simulate(redheadDuck);
simulate(duckCall);
simulate(rubberDuck);
simulate(gooseDuck);

What we need is a way to talk about collections of
ducks and even sub-collections of ducks (to deal with
the family request from Ranger Brewer). It would
also be nice if we could apply operations across the
whole set of ducks.
What pattern can help us?

512

Chapter 12
Download at WoweBook.Com

compound patterns
12

Let’s create a ﬂock of ducks (well, actually a ﬂock of Quackables).
Remember the Composite Pattern that allows us to treat a collection of
objects in the same way as individual objects? What better composite
than a ﬂock of Quackables!
Let’s step through how this is going to work:

ds to implement
Remember, the composite nee f elements. Our
the same interface as the lea
leaf elements are Quackables.
public class Flock implements Quackable {
ArrayList quackers = new ArrayList();

We’re using an ArrayList inside
each Flock to hold the Quackables
that belong to the Flock.

public void add(Quackable quacker) {
quackers.add(quacker);
}

The add() method adds a
Quackable to the Flock.

public void quack() {
Iterator iterator = quackers.iterator();
while (iterator.hasNext()) {
Quackable quacker = (Quackable)iterator.next();
quacker.quack();
}
}
}

the Flock is a Quackable too.
Now for the quack() method - after all, k over the entire Flock. Here
The quack() method in Flock needs to wor
call quack() on each element.
we iterate through the ArrayList and

Code Up Close

Did you notice that we tried to sneak a Design Pattern by
you without mentioning it?

public void quack() {
Iterator iterator = quackers.iterator();
while (iterator.hasNext()) {
Quackable quacker = (Quackable)iterator.next();
quacker.quack();
}
}

There it is! The Iterator
Pattern at work!

you are here 4
Download at WoweBook.Com

513

duck composite

Now we need to alter the simulator.

13

Our composite is ready; we just need some code to round up the
ducks into the composite structure.
public class DuckSimulator {
// main method here

Create all the
Quackables, just
like before.

void simulate(AbstractDuckFactory duckFactory) {
Quackable redheadDuck = duckFactory.createRedheadDuck();
Quackable duckCall = duckFactory.createDuckCall();
Quackable rubberDuck = duckFactory.createRubberDuck();
Quackable gooseDuck = new GooseAdapter(new Goose());
System.out.println(“\nDuck Simulator: With Composite - Flocks”);
Flock ﬂockOfDucks = new Flock();

First we create a Flock, and
load it up with Quackables.

ﬂockOfDucks.add(redheadDuck);
ﬂockOfDucks.add(duckCall);
ﬂockOfDucks.add(rubberDuck);
ﬂockOfDucks.add(gooseDuck);

Then we create a new
Flock of Mallards.

Flock ﬂockOfMallards = new Flock();
Quackable
Quackable
Quackable
Quackable

Here we’re
creating a
little family of
mallards...

mallardOne = duckFactory.createMallardDuck();
mallardTwo = duckFactory.createMallardDuck();
mallardThree = duckFactory.createMallardDuck();
mallardFour = duckFactory.createMallardDuck();

ﬂockOfMallards.add(mallardOne);
ﬂockOfMallards.add(mallardTwo);
ﬂockOfMallards.add(mallardThree);
ﬂockOfMallards.add(mallardFour);

...and adding them to the
Flock of mallards.

Then we add the Flock of
mallards to the main flock.

ﬂockOfDucks.add(ﬂockOfMallards);

System.out.println(“\nDuck Simulator: Whole Flock Simulation”);
simulate(ﬂockOfDucks);

Let’s test out the entire Flock!

System.out.println(“\nDuck Simulator: Mallard Flock Simulation”);
simulate(ﬂockOfMallards);

Then let’s just test out the mallard’s Flock.

System.out.println(“\nThe ducks quacked “ +
QuackCounter.getQuacks() +
“ times”);
}
void simulate(Quackable duck) {
duck.quack();
}
}

514

Finally, let’s give the
Quackologist the data.

Nothing needs to change here, a Flock is a Quackable!

Chapter 12
Download at WoweBook.Com

compound patterns
Let’s give it a spin...
File Edit Window Help FlockADuck

% java DuckSimulator
Duck Simulator: With Composite - Flocks

Duck Simulator: Whole Flock Simulation
Quack
Kwak
Here’s the first flock.
Squeak
Honk
Quack
Quack
Quack
Quack
Duck Simulator: Mallard Flock Simulation
Quack
And now the mallards.
Quack
The data looks
Quack
good (remember
Quack
The ducks quacked 11 times

the goose doesn’t
get counted).

Safety versus transparency
You might remember that in the Composite Pattern chapter the composites (the Menus) and the leaf nodes
(the MenuItems) had the same exact set of methods, including the add() method. Because they had the
same set of methods, we could call methods on MenuItems that didn’t really make sense (like trying to add
something to a MenuItem by calling add()). The benefit of this was that the distinction between leaves and
composites was transparent: the client didn’t have to know whether it was dealing with a leaf or a composite;
it just called the same methods on both.
Here, we’ve decided to keep the composite’s child maintenance methods separate from the leaf nodes: that
is, only Flocks have the add() method. We know it doesn’t make sense to try to add something to a Duck,
and in this implementation, you can’t. You can only add() to a Flock. So this design is safer – you can’t call
methods that don’t make sense on components – but it’s less transparent. Now the client has to know that a
Quackable is a Flock in order to add Quackables to it.
As always, there are trade-offs when you do OO design and you need to consider them as you create your
own composites.
you are here 4
Download at WoweBook.Com

515

duck observer

The Composite is working
great! Thanks! Now we have the
opposite request: we also need to
track individual ducks. Can you give
us a way to keep track of individual
duck quacking in real time?

Can you say “observer?’
It sounds like the Quackologist would like to observe individual
duck behavior. That leads us right to a pattern made for observing
the behavior of objects: the Observer Pattern.

14

First we need an Observable interface.
Remember that an Observable is the object being observed. An Observable
needs methods for registering and notifying observers. We could also have
a method for removing observers, but we’ll keep the implementation simple
here and leave that out.

erface
QuackObservable is the int lement
that Quackables should imp .
if they want to be observed
public interface QuackObservable {
public void registerObserver(Observer observer);
public void notifyObservers();
}

It also has a method for
notifying the observers.

It has a method for registering
Observers. Any object implementing
the Observer interface can listen
to quacks. We’ll define the Observer
interface in a sec.

Now we need to make sure all Quackables implement this interface...

public interface Quackable extends QuackObservable {
public void quack();
}

So, we extend the Quackable
interface with QuackObserver.
516

Chapter 12
Download at WoweBook.Com

compound patterns

15

Now, we need to make sure all the concrete
classes that implement Quackable can handle
being a QuackObservable.

Stop looking at
me. You’re making
me nervous!

We could approach this by implementing registration and
notiﬁcation in each and every class (like we did in Chapter
2). But we’re going to do it a little differently this time:
we’re going to encapsulate the registration and notiﬁcation
code in another class, call it Observable, and compose it
with a QuackObservable. That way we only write the real
code once and the QuackObservable just needs enough
code to delegate to the helper class Observable.
Let’s start with the Observable helper class...

QuackObserverable

e functionality
Observable implements all th observable.
a Quackable needs to be an o a class and
We just need to plug it int Observable.
have that class delegate to

Observable must implement QuackObservable
because these are the same method calls
that are going to be delegated to it.
In the constructor we get le
passed the QuackObservab
public class Observable implements QuackObservable {
that is using this object to or.
ArrayList observers = new ArrayList();
manage its observable behavithod
QuackObservable duck;
Check out the notify() me a
below; you’ll see that when sses
public Observable(QuackObservable duck) {
this.duck = duck;
notify occurs, Observable pa e
}
this object along so that tht is
observer knows which objec
public void registerObserver(Observer observer) {
quacking.
observers.add(observer);

}
public void notifyObservers() {
Iterator iterator = observers.iterator();
while (iterator.hasNext()) {
Observer observer = (Observer)iterator.next();
observer.update(duck);
}
}
}

Here’s the code for
registering an observer.

And the code for doing
the notifications.

Now let’s see how a Quackable class uses this helper...

you are here 4
Download at WoweBook.Com

517

quack decorators are observables too

16

Integrate the helper Observable with the Quackable classes.
This shouldn’t be too bad. All we need to do is make sure the Quackable classes
are composed with an Observable and that they know how to delegate to it. After
that, they’re ready to be Observables. Here’s the implementation of MallardDuck;
the other ducks are the same.
public class MallardDuck implements Quackable {
Observable observable;

Each Quackable has an
Observable instance variable.

public MallardDuck() {
observable = new Observable(this);
}

In the constructor, we create an
Observable and pass it a reference
to the MallardDuck object.

public void quack() {
System.out.println(“Quack”);
notifyObservers();
}

When we quack, we
need to let the
observers know about it.

public void registerObserver(Observer observer) {
observable.registerObserver(observer);
}
public void notifyObservers() {
observable.notifyObservers();
}
}

Here’s our two QuackObservable
methods. Notice that we just
delegate to the helper.

Sharpen your pencil
We haven’t changed the implementation of one Quackable, the QuackCounter
decorator. We need to make it an Observable too. Why don’t you write that one:

518

Chapter 12
Download at WoweBook.Com

compound patterns

17

We’re almost there! We just need to work on the Observer side
of the pattern.
We’ve implemented everything we need for the Observables; now we
need some Observers. We’ll start with the Observer interface:

The Observer interface
has one method, update just
is passed the QuackObs (), which
ervable
that is quacking.
public interface Observer {
public void update(QuackObservable duck);
}

Now we need an Observer: where are
those Quackologists?!

We need to implement the Observable interface or else
we won’t be able to register with a QuackObservable.
public class Quackologist implements Observer {
public void update(QuackObservable duck) {
System.out.println(“Quackologist: “ + duck + “ just quacked.”);
}
}

The Quackologist is sim
method, update(), whichple; it just has one
Quackable that just qu prints out the
acked.

you are here 4
Download at WoweBook.Com

519

ﬂock composites are observables too

Sharpen your pencil
What if a Quackologist wants to observe an entire ﬂock? What does that mean
anyway? Think about it like this: if we observe a composite, then we’re observing
everything in the composite. So, when you register with a ﬂock, the ﬂock
composite makes sure you get registered with all its children (sorry, all its little
quackers), which may include other ﬂocks.
Go ahead and write the Flock observer code before we go any further...

520

Chapter 12
Download at WoweBook.Com

compound patterns

18

We’re ready to observe. Let’s update the
simulator and give it try:

public class DuckSimulator {
public static void main(String[] args) {
DuckSimulator simulator = new DuckSimulator();
AbstractDuckFactory duckFactory = new CountingDuckFactory();
simulator.simulate(duckFactory);
}
void simulate(AbstractDuckFactory duckFactory) {
// create duck factories and ducks here
// create ﬂocks here
System.out.println(“\nDuck Simulator: With Observer”);
Quackologist quackologist = new Quackologist();
ﬂockOfDucks.registerObserver(quackologist);
simulate(ﬂockOfDucks);
System.out.println(“\nThe ducks quacked “ +
QuackCounter.getQuacks() +
“ times”);
}
void simulate(Quackable duck) {
duck.quack();
}
}

All we do here is create a
Quackologist and set him as
an observer of the flock.
This time we’ll we
just simulate the
entire flock.

Let’s give it a try and
see how it works!

you are here 4
Download at WoweBook.Com

521

the duck ﬁnale

This is the big ﬁnale. Five, no, six patterns have come together to create
this amazing Duck Simulator. Without further ado, we present the
DuckSimulator!
File Edit Window Help DucksAreEverywhere

% java DuckSimulator
Duck Simulator: With Observer
After each
Quack
quack, no matter
Quackologist: Redhead Duck just quacked.
what kind of
Kwak
quack it was, the
Quackologist: Duck Call just quacked.
observer gets a
Squeak
notification.
Quackologist: Rubber Duck just quacked.
Honk
Quackologist: Goose pretending to be a Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
And the
The Ducks quacked 7 times.
quackologist still

gets his counts.

%

there are no

Q:
A:

Dumb Questions

So this was a compound pattern?

No, this was just a set of patterns
working together. A compound pattern is a
set of a few patterns that are combined to
solve a general problem. We’re just about
to take a look at the Model-View-Controller
compound pattern; it’s a collection of a few
patterns that has been used over and over in
many design solutions.

522

Q:

So the real beauty of Design
Patterns is that I can take a problem, and
start applying patterns to it until I have a
solution. Right?

A:

Wrong. We went through this
exercise with Ducks to show you how
patterns can work together. You’d never
actually want to approach a design like we
just did. In fact, there may be solutions to
parts of the duck simulator for which some
of these patterns were big time overkill.

Chapter 12
Download at WoweBook.Com

Sometimes just using good OO design
principles can solve a problem well enough
on its own.
We’re going to talk more about this in the
next chapter, but you only want to apply
patterns when and where they make
sense. You never want to start out with the
intention of using patterns just for the sake
of it. You should consider the design of the
DuckSimulator to be forced and artificial.
But hey, it was fun and gave us a good
idea of how several patterns can fit into a
solution.

compound patterns

What did we do?
We started with a bunch of Quackables...
A goose came along and wanted to act like a Quackable too. So we
used the Adapter Pattern to adapt the goose to a Quackable. Now, you can call quack() on a
goose wrapped in the adapter and it will honk!
Then, the Quackologists decided they wanted to count quacks. So we
used the Decorator Pattern to add a QuackCounter decorator that keeps track of the number
of times quack() is called, and then delegates the quack to the Quackable it’s wrapping.
But the Quackologists were worried they’d forget to add the
QuackCounter decorator. So we used the Abstract Factory Pattern to create ducks
for them. Now, whenever they want a duck, they ask the factory for one, and it hands back
a decorated duck. (And don’t forget, they can also use another duck factory if they want an
un-decorated duck!)
We had management problems keeping track of all those ducks and
geese and quackables. So we used the Composite Pattern to group quackables
into Flocks. The pattern also allows the quackologist to create sub-Flocks to manage duck
families. We used the Iterator Pattern in our implementation by using java.util’s iterator in
ArrayList.
The Quackologists also wanted to be notiﬁed when any quackable
quacked. So we used the Observer Pattern to let the Quackologists register as Quackable
Observers. Now they’re notiﬁed every time any Quackable quacks. We used iterator again
in this implementation. The Quackologists can even use the Observer Pattern with their
composites.

That was quite a Design Pattern
workout. You should study the
class diagram on the next page
and then take a relaxing break before
continuing on with the Model-ViewController.

you are here 4
Download at WoweBook.Com

523

duck’s eye view

A bird’s duck’s eye view: the class diagram
We’ve packed a lot of patterns into one small duck simulator! Here’s the big picture of what we did:

DuckSimulator

ctory to create Ducks.

The DuckSimulator uses a fa

AbstractDuckFactory
createMallardDuck()
createRedheadDuck()
createDuckCall()
createRubberDuck()

DuckFactory

CountingDuckFactory

createMallardDuck()

createMallardDuck()

createRedheadDuck()

createRedheadDuck()

createDuckCall()

createDuckCall()

createRubberDuck()

createRubberDuck()

If a class implements
Observer, that
means it can observ
Quackables, and will e
be notified whenever
a Quackable quacks.

<<interface>>
Observer
update(QuackObservable)

Quackologist
update(QuackObservable)

We only implem
for the Quack ented one kind of Observer
any class that ables - the Quackologist. B
interface can implements the Observer ut
implementing a observe ducks... how about
BirdWatcher ob
server?
524

Chapter 12
Download at WoweBook.Com

Here are two different
factories that produce
the same family of
products. The DuckFactory
creates ducks, and the
CountingDuckFactory
creates Ducks wrapped in
QuackCounter decorators.

compound patterns

The QuackObservable interfacet
gives us a set of methods tha .
any Observable must implement

Quackable is the in
that all classes thatterface
quacking behavior im have
plement.

Each Quackable has an
instance of Observable
to keep track of their
observers and notify them
when the Quackable quacks.

<<interface>>
QuackObservable
registerObserver(Observer)
notifyObservers()

Observable
<<interface>>
Quackable

ArrayList observers
QuackObservable duck

quack()

registerObserver(Observer)
notifyObservers()

MallardDuck
quack()

GooseAdapter
Goose goose

RedheadDuck

registerObserver(Observer)
quack()
DuckCall
notifyObservers()

quack()

registerObserver(Observer)
quack() RubberDuck
notifyObservers()
registerObserver(Observer)
quack()
notifyObservers()
registerObserver(Observer)
notifyObservers()

registerObserver(Observer)

This Adapter...

notifyObservers()

Flock
ArrayList ducks
add(Quackable)

We have two kinds of
Quackables: ducks and
other things that want
Quackable behavior: like the
GooseAdapter, which wraps a
Goose and makes it look like
a Quackable; Flock, which is
a Quackable Composite, and
QuackCounter, which adds
behavior to Quackables.

quack()
registerObserver(Observer)
notifyObservers()

... and this
Composite...

QuackCounter
Quackable duck
getQuacks()
quack()
registerObserver(Observer)
notifyObservers()

... and this
Decorator
all act like
Quackables!

you are here 4
Download at WoweBook.Com

525

the model view controller song

The King of Compound Patterns
If Elvis were a compound pattern, his name would be Model-View-Controller,
and he’d be singing a little song like this...
Model, View, Controller

Lyrics and music by James Dempsey.

MVC’s a paradigm for factoring your code
into functional segments, so your brain does not explode.
To achieve reusability, you gotta keep those boundaries
clean
Model on the one side, View on the other, the
Controller’s in between.

Model View, you can model all the models that pose for
GQ
Model View Controller
So does

View

Creamy
Controller

Model

Model View, it’s got three layers like Oreos do
Model View Controller
Model View, Model View, Model View Controller
Model objects represent your application’s raison d’être
Custom objects that contain data, logic, and et cetera
You create custom classes, in your app’s problem domain
you can choose to reuse them with all the views
but the model objects stay the same.

526

You can model a throttle and a manifold
Model the toddle of a two year old
Model a bottle of fine Chardonnay
Model all the glottal stops people say
Model the coddling of boiling eggs
You can model the waddle in Hexley’s legs

Java!

View objects tend to be controls used to display and edit
Cocoa’s got a lot of those, well written to its credit.
Take an NSTextView, hand it any old Unicode string
The user can interact with it, it can hold most anything
But the view don’t know about the Model
That string could be a phone number or the works of
Aristotle
Keep the coupling loose
and so achieve a massive level of reuse
Model View, all rendered very nicely in Aqua blue
Model View Controller
You’re probably wondering now
You’re probably wondering how
Data flows between Model and View
The Controller has to mediate
Between each layer’s changing state
To synchronize the data of the two

Chapter 12
Download at WoweBook.Com

compound patterns

It pulls and pushes every changed value

I sent a TextField StringValue.

Model View, mad props to the smalltalk crew!
Model View Controller

Model View
How we gonna deep six all that glue
Model View Controller

Model View, it’s pronounced Oh Oh not Ooo Ooo
Model View Controller
There’s a little left to this story
A few more miles upon this road
Nobody seems to get much glory
From writing the controller code

Controllers know the Model and View very intimately
They often use hardcoding which can be foreboding for
reusability
But now you can connect each model key that you select
to any view property
And once you start binding
I think you’ll be finding less code in your source tree

Well the model’s mission critical
And gorgeous is the view
I might be lazy, but sometimes it’s just crazy
How much code I write is just glue
And it wouldn’t be so tragic
But the code ain’t doing magic
It’s just moving values through

Yeah I know I was elated by the stuff they’ve automated
and the things you get for free
And I think it bears repeating
all the code you won’t be needing
when you hook it up in IB.

And I don’t mean to be vicious
But it gets repetitious
Doing all the things controllers do

ing.

Using Sw

Model View, even handles multiple selections too
Model View Controller
Model View, bet I ship my application before you
Model View Controller

And I wish I had a dime
For every single time

Ear
power
Don’t just read! After all this is a Head First book... grab your iPod, hit this URL:
http://www.headfirstlabs.com/books/hfdp/media.html
Sit back and give it a listen.

you are here 4
Download at WoweBook.Com

527

mvc is patterns put together

Cute song, but is that really
supposed to teach me what ModelView-Controller is? I’ve tried
learning MVC before and it made my
brain hurt.

No. Design Patterns are
your key to the MVC.
We were just trying to whet your appetite.
Tell you what, after you ﬁnish reading this
chapter, go back and listen to the song again
– you’ll have even more fun.
It sounds like you’ve had a bad run in with
MVC before? Most of us have. You’ve
probably had other developers tell you it’s
changed their lives and could possibly create
world peace. It’s a powerful compound
pattern, for sure, and while we can’t claim it
will create world peace, it will save you hours
of writing code once you know it.
But ﬁrst you have to learn it, right? Well,
there’s going to be a big difference this time
around because now you know patterns!
That’s right, patterns are the key to MVC.
Learning MVC from the top down is difﬁcult;
not many developers succeed. Here’s the
secret to learning MVC: it’s just a few patterns
put together. When you approach learning
MVC by looking at the patterns, all of the
sudden it starts to make sense.
Let’s get started. This time around you’re
going to nail MVC!

528

Chapter 12
Download at WoweBook.Com

compound patterns

Meet the Model-View-Controller
Imagine you’re using your favorite MP3 player, like iTunes. You can use its interface to add
new songs, manage playlists and rename tracks. The player takes care of maintaining a little
database of all your songs along with their associated names and data. It also takes care of
playing the songs and, as it does, the user interface is constantly updated with the current song
title, the running time, and so on.
Well, underneath it all sits the Model-View-Controller...

the
disp view
upd
la
ate y i s
d fo
r
yo u

e
se th
yo u u a c e a n d
f
i nte r c t i o n s
a
yo u r t h e
t
o
g o ller
o
co nt r

You see the song
display update and
hear the new song
playing

“Play new song”

Controller

View
Model tells the
view the state has
changed

the m
the v odel not
if
ie
in sta w of a c ies
hang
te
e

The model contains all the state,
data, and application logic needed
to maintain and play mp3s.

class Player {
play(){}

}

rip(){}
burn(){}

Controller asks
Player model to
begin playing
song

controller
manipulates
the model

Model

you are here 4
Download at WoweBook.Com

529

Now let’s zoom into the

mvc up close

A closer look...
The MP3 Player description gives us a high level view of MVC, but it really doesn’t help you
understand the nitty gritty of how the compound pattern works, how you’d build one yourself, or
why it’s such a good thing. Let’s start by stepping through the relationships among the model, view
and controller, and then we’ll take second look from the perspective of Design Patterns.

CONTROLLER
Takes user input and ﬁgures out
what it means to the model.

VIEW
Gives you a presentation
of the model. The view
usually gets the state
and data it needs to
display directly from
the model.

MODEL

Here’s the creamy
controller; it lives in
the middle.

2

1 The user did

Controller

Change your
state

The model holds all
the data, state and
application logic. The
model is oblivious to
the view and controller,
although it provides an
interface to manipulate
and retrieve its
state and it can send
notiﬁcations of state
changes to observers.

something

3 Change your
display

class Player {
play(){}

4
I’ve changed!

}

rip(){}
burn(){}

Model
View

This is the user
interface.

530

5
I need your state
information

Chapter 12
Download at WoweBook.Com

Here’s the model;
it handles all
application data
and logic.

compound patterns

1

You’re the user — you interact with the view.
The view is your window to the model. When you do something to the view (like click
the Play button) then the view tells the controller what you did. It’s the controller’s
job to handle that.

2

The controller asks the model to change its state.
The controller takes your actions and interprets them. If you click on a button, it’s
the controller’s job to ﬁgure out what that means and how the model should be
manipulated based on that action.

3

The controller may also ask the view to change.
When the controller receives an action from the view, it may need to tell the view
to change as a result. For example, the controller could enable or disable certain
buttons or menu items in the interface.

4

The model notiﬁes the view when its state has changed.
When something changes in the model, based either on some action you took (like
clicking a button) or some other internal change (like the next song in the playlist
has started), the model notiﬁes the view that its state has changed.

5

The view asks the model for state.
The view gets the state it displays directly from the model. For instance, when the
model notiﬁes the view that a new song has started playing, the view requests the
song name from the model and displays it. The view might also ask the model for
state as the result of the controller requesting some change in the view.

there are no

Q:

Does the controller ever become
an observer of the model?

A:

Sure. In some designs the controller
registers with the model and is notified
of changes. This can be the case when
something in the model directly affects the
user interface controls. For instance, certain
states in the model may dictate that some
interface items be enabled or disabled. If
so, it is really controller’s job to ask the view
to update its display accordingly.

Dumb Questions

Q:

All the controller does is take user
input from the view and send it to the
model, correct? Why have it at all if that
is all it does? Why not just have the code
in the view itself? In most cases isn’t the
controller just calling a method on the
model?

A:

The controller does more than
just “send it to the model”, the controller is
responsible for interpreting the input and
manipulating the model based on that input.
But your real question is probably “why can’t
I just do that in the view code?”

You could; however, you don’t want to
for two reasons: First, you’ll complicate
your view code because it now has two
responsibilities: managing the user interface
and dealing with logic of how to control the
model. Second, you’re tightly coupling your
view to the model. If you want to reuse
the view with another model, forget it. The
controller separates the logic of control from
the view and decouples the view from the
model. By keeping the view and controller
loosely coupled, you are building a more
flexible and extensible design, one that can
more easily accommodate change down the
road.
you are here 4

Download at WoweBook.Com

531

the patterns in mvc

Looking at MVC through
patterns-colored glasses
We’ve already told you the best path to learning the MVC is to see it for what it
is: a set of patterns working together in the same design.
Let’s start with the model. As you might have guessed the model uses
Observer to keep the views and controllers updated on the latest state changes.
The view and the controller, on the other hand, implement the Strategy Pattern. The controller
is the behavior of the view, and it can be easily exchanged with another controller if you
want different behavior. The view itself also uses a pattern internally to manage the windows,
buttons and other components of the display: the Composite Pattern.
Let’s take a closer look:

Strategy
The view and controller implement the classic Strategy Pattern: the
view is an object that is configured with a strategy. The controller
provides the strategy. The view is concerned only with the visual
aspects of the application, and delegates to the controller for any
decisions about the interface behavior. Using the Strategy Pattern also
keeps the view decoupled from the model because it is the controller
that is responsible for interacting with the model to carry out user
requests. The view knows nothing about how this gets done.

The user did
something

C om

e
posi t

Controller
Change your
display

I’ve changed!

Change your
state

Ob s e r ve

r

class Player {
play(){}

}

rip(){}
burn(){}

Model
View
The display consists of a nested set of windows, panels, buttons, text labels and so on.
Each display component is a composite (like
a window) or a leaf (like a button). When the
controller tells the view to update, it only has
to tell the top view component, and Composite
takes care of the rest.

532

I need your state
information

Chapter 12
Download at WoweBook.Com

The model implements the Observer Pattern
to keep interested objects updated when state
changes occur. Using the Observer Pattern
keeps the model completely independent of
the views and controllers. It allows us to use
different views with the same model, or even
use multiple views at once.

compound patterns

Obser ver

All these observers will be
notified whenever state
changes in the model.

Observers

Observable

My state has
changed!

class Foo {
void bar()

{

}

}

View

doBar();

View

Model
Controller

I’d like to register
as an observer

Strategy
The view
delegates to
the controller
to handle the
user actions.

View

Any object that’s
interested in state
changes in the model
registers with the
model as an observer.

The model has no dependencies on
viewers or controllers!

The user did
something

Controller

View

The view only worries about presentation, the controller worries
about translating user input to actions on the model.

Composite

Controller

paint()

the
The controller ise view
th
r
strategy fo
that
- it’s the object ndle
ha
to
knows how
the user actions.
We can swap in
another behavior fo
the view by changingr
the controller.

of
The view is a composite
GUI components (labels,
buttons, text entry,
etc.). The top level her
component contains ot ain
components, which contso
other components and
on until you get to the
leaf nodes.

View

you are here 4
Download at WoweBook.Com

533

mvc and the dj view

Using MVC to control the beat...
It’s your time to be the DJ. When you’re a DJ it’s all about the beat. You might start
your mix with a slowed, downtempo groove at 95 beats per minute (BPM) and then
bring the crowd up to a frenzied 140 BPM of trance techno. You’ll ﬁnish off your set
with a mellow 80 BPM ambient mix.
How are you going to do that? You have to control the beat and you’re going to build
the tool to get you there.

Meet the Java DJ View
Let’s start with the view of the tool. The view allows you to create a
driving drum beat and tune its beats per minute...

A pulsing bar shows the beat in real time.

A display shows the current BPMs and is
automatically set whenever the BPM changes.
s,
The view has two part
ng
wi
the part for vie
l
the state of the mode
r
and the part fo
controlling things.

You can enter a specific BPM and click
the Set button to set a specific beats
per minute, or you can use the increase
and decrease buttons for fine tuning.
Decreases
the BPM by
one beat per
minute.

534

Increases
the BPM by
one beat per
minute.

Chapter 12
Download at WoweBook.Com

compound patterns

Here’s a few more ways to control the DJ View...

You use the Stop
button to shut
down the beat
generation.

e beat
You can start thng the
si
oo
kicking by ch
in the
Start menu item u.
en
“DJ Control” m

Notice Start is
disabled after the
beat has started.

Notice Stop is
disabled until you
start the beat.

All user actions are
sent to the controller.

The controller is in the middle...
The controller sits between the view and
model. It takes your input, like selecting “Start”
from the DJ Control menu, and turns it into an
action on the model to start the beat generation.

The controller takes input
from the user and figures out
how to translate that into
requests on the model.

Controller

Let’s not forget about the model underneath it all...
You can’t see the model, but you can hear it. The
model sits underneath everything else, managing the
beat and driving the speakers with MIDI.

atMod
Be on() el
The BeatModel is the heart of the
application. It implements the logic
to start and stop the beat, set
the beats per minute (BPM), and
generate the sound.

setBPM()

getBP

off()

M()

The model also allows us to
obtain its current state through
the getBPM() method.
you are here 4
Download at WoweBook.Com

535

the dj model, view and controller

Putting the pieces together

The beat is set at 119 BPM and you
would like to increase it to 120.

Click on the
increase beat
button...

View

...which results in the
controller being invoked.

Controller

You see the beatbar
pulse every 1/2 second.
Because the BPM is 120, the view
a beat notification every 1/2 sec gets
ond.

View

The controller asks
the model to update
its BPM by one.

atMod
Be on() el
setBPM() off()
getBP

The view is updated
to 120 BPM.

536

M
View is notified that the BPon
)
M(
changed. It calls getBP
the model state.

Chapter 12
Download at WoweBook.Com

M()

compound patterns

Building the pieces
Okay, you know the model is responsible for maintaining all the data, state and any
application logic. So what’s the BeatModel got in it? Its main job is managing the beat,
so it has state that maintains the current beats per minute and lots of code that generates
MIDI events to create the beat that we hear. It also exposes an interface that lets the
controller manipulate the beat and lets the view and controller obtain the model’s state.
Also, don’t forget that the model uses the Observer Pattern, so we also need some methods
to let objects register as observers and send out notiﬁcations.

Let’s check out the BeatModelInterface before looking at the
implementation:
public interface BeatModelInterface {
void initialize();

These are the methods
the controller will use to
direct the model based on
user interaction.

void on();
void off();
void setBPM(int bpm);

he
ed after t ed.
ll
a
c
s
t
e
g
iat
This
l is instant
BeatMode
These methods turn the beat
generator on and off.
This method sets the beats per
minute. After it is called, the beat
frequency changes immediately.

int getBPM();

These methods allow
the view and the
controller to get
state and to become
observers.

void registerObserver(BeatObserver o);

The getBPM() method returns
the current BPMs, or 0 if
the generator is off.

void removeObserver(BeatObserver o);
void registerObserver(BPMObserver o);
void removeObserver(BPMObserver o);
}

This should look
familiar, these
methods allow
objects to register
as observers for
state changes.

We’ve split this into two kinds of
observers: observers that want to be
notified on every beat, and observers
that just want to be notified with
the beats per minute change.

you are here 4
Download at WoweBook.Com

537

the beat model

Now let’s have a look at the concrete BeatModel class:
We implement the BeatModeIInterface.

This is needed for
the MIDI code.

public class BeatModel implements BeatModelInterface, MetaEventListener {
Sequencer sequencer;
The sequencer is the object that knows how
ArrayList beatObservers = new ArrayList();
generate real beats (that you can hear!).
ArrayList bpmObservers = new ArrayList();
int bpm = 90;
These ArrayLists hold the two kinds of
// other instance variables here
public void initialize() {
setUpMidi();
buildTrackAndStart();
}
public void on() {
sequencer.start();
setBPM(90);
}
public void off() {
setBPM(0);
sequencer.stop();
}

This method does
setup on the sequencer
and sets up the beat
tracks for us.

void beatEvent() {
notifyBeatObservers();
}

observers (Beat and BPM observers).
The bpm instance variable holds the frequency
of beats - by default, 90 BPM.

The on() method starts the sequencer and
sets the BPMs to the default: 90 BPM.

And off() shuts it down by setting BPMs to
0 and stopping the sequencer.

public void setBPM(int bpm) {
this.bpm = bpm;
sequencer.setTempoInBPM(getBPM());
notifyBPMObservers();
}
public int getBPM() {
return bpm;
}

to

The setBPM() method is the way the controller
manipulates the beat. It does three things:
(1) Sets the bpm instance variable

(2) Asks the sequencer to change its BPMs.
(3) Notifies all BPM Observers that the BPM
has changed.
nce variable, which
The getBPM() method just returns the bpm insta
indicates the current beats per minute.
ModelInterface, is
The beatEvent() method, which is not in the Beat ts. This method
called by the MIDI code whenever a new beat star occurred.
notifies all BeatObservers that a new beat has just

// Code to register and notify observers
// Lots of MIDI code to handle the beat
}

Ready-bake Code
This model uses Java’s MIDI support to generate beats. You can check out the
complete implementation of all the DJ classes in the Java source files available
on the headfirstlabs.com site, or look at the code at the end of the chapter.

538

Chapter 12
Download at WoweBook.Com

compound patterns

The View
Now the fun starts; we get to hook up a view and visualize the BeatModel!
The ﬁrst thing to notice about the view is that we’ve implemented it so that it is displayed in two separate
windows. One window contains the current BPM and the pulse; the other contains the interface
controls. Why? We wanted to emphasize the difference between the interface that contains the view of
the model and the rest of the interface that contains the set of user controls. Let’s take a closer look at
the two parts of the view:

We’ve separated
the view of the
model from the
view with the
controls.
The DJ view
displays two
aspects of the
BeatModel...
...the current beats
per minute, from
the BPMObserver
notifications...

...and a pulsing “beat
bar” pulses in synch
with the beat, driven
by the BeatObserver
notifications.

This is the pa
that you use rt of the view
This view pass to change the beat.
do on to the es everything you
controller.

A

brain
power
Our BeatModel makes no assumptions about the view. The model is implemented using the
Observer Pattern, so it just notiﬁes any view registered as an observer when its state changes. The
view uses the model’s API to get access to the state. We’ve implemented one type of view, can you
think of other views that could make use of the notiﬁcations and state in the BeatModel?

A lightshow that is based on the real-time beat.
A textual view that displays a music genre based on the BPM (ambient, downbeat, techno, etc.).

you are here 4
Download at WoweBook.Com

539

the dj view

Implementing the View
The two parts of the view – the view of the model, and
the view with the user interface controls – are displayed
in two windows, but live together in one Java class. We’ll
ﬁrst show you just the code that creates the view of the
model, which displays the current BPM and the beat bar.
Then we’ll come back on the next page and show you just
the code that creates the user interface controls, which
displays the BPM text entry ﬁeld, and the buttons.

.
Watch it!

o
The code on these tw
e!
tlin
ou
pages is just an

split ONE
What we’ve done here is
you one part
g
win
sho
O,
class into TW
and the other
of the view on this page,
this code is
All
part on the next page.
w.java. It’s
Vie
DJ
ss
cla
really in ONE
pter.
cha
the
of
k
bac
the
at
d
all liste

es.

DJView is an observer for both real-time beats and BPM chang

public class DJView implements ActionListener, BeatObserver, BPMObserver {
BeatModelInterface model;
The view holds a reference to both the model and
ControllerInterface controller;
the controller. The controller is only used by the
JFrame viewFrame;
JPanel viewPanel;
control interface, which we’ll go over in a sec...
Here, we create a few
BeatBar beatBar;
components for the displa
JLabel bpmOutputLabel;
y.
public DJView(ControllerInterface controller, BeatModelInterface model) {
this.controller = controller;
The constructor gets a reference
this.model = model;
to the controller and the model,
model.registerObserver((BeatObserver)this);
and we store references to those
model.registerObserver((BPMObserver)this);
}
the instance variables.
public void createView() {
// Create all Swing components here
}

We also register as a BeatObserver and a
BPMObserver of the model.
The updateBPM() method is called when a state change
update the
this value

public void updateBPM() {
occurs in the model. When that happens we
int bpm = model.getBPM();
display with the current BPM. We can get
if (bpm == 0) {
by requesting it directly from the model.
bpmOutputLabel.setText(“ofﬂine”);
} else {
bpmOutputLabel.setText(“Current BPM: “ + model.getBPM());
}
}
public void updateBeat() {
beatBar.setValue(100);
}
}

540

in

Likewise, the updateBeat() method is called
when the model starts a new beat. When that
happens, we need to pulse our “beat bar.” We
do this by setting it to its maximum value (100)
and letting it handle the animation of the pulse.

Chapter 12
Download at WoweBook.Com

compound patterns

Implementing the View, continued...
Now, we’ll look at the code for the user interface controls part of the view. This view lets you control the
model by telling the controller what to do, which in turn, tells the model what to do. Remember, this code
is in the same class ﬁle as the other view code.
public class DJView implements ActionListener,
BeatModelInterface model;
ControllerInterface controller;
JLabel bpmLabel;
JTextField bpmTextField;
JButton setBPMButton;
JButton increaseBPMButton;
JButton decreaseBPMButton;
JMenuBar menuBar;
JMenu menu;
JMenuItem startMenuItem;
JMenuItem stopMenuItem;
public void createControls() {
// Create all Swing components here
}
public void enableStopMenuItem() {
stopMenuItem.setEnabled(true);
}
public void disableStopMenuItem() {
stopMenuItem.setEnabled(false);
}

BeatObserver, BPMObserver {

This method creates all the controls and
interface. It also takes care of the men places them in the
or start items are chosen, the corresp u. When the stop
onding methods are
called on the controller.
All these methods allow the start and
stop items in the menu to be enabled and
disabled. We’ll see that the controller
uses
these to change the interface.

public void enableStartMenuItem() {
startMenuItem.setEnabled(true);
}
public void disableStartMenuItem() {
startMenuItem.setEnabled(false);
}

This method is called when a button is clicked.

public void actionPerformed(ActionEvent event) {
if (event.getSource() == setBPMButton) {
int bpm = Integer.parseInt(bpmTextField.getText());
controller.setBPM(bpm);
} else if (event.getSource() == increaseBPMButton) {
controller.increaseBPM();
} else if (event.getSource() == decreaseBPMButton) {
controller.decreaseBPM();
}
}

If the Set button is
clicked then it is passed
on to the controller along
with the new bpm.
Likewise, if the increase
or decrease buttons are
clicked, this information is
passed on to the controller.

}
you are here 4
Download at WoweBook.Com

541

the dj controller

Now for the Controller
It’s time to write the missing piece: the controller. Remember the controller is
the strategy that we plug into the view to give it some smarts.
Because we are implementing the Strategy Pattern, we need to start with an
interface for any Strategy that might be plugged into the DJ View. We’re going
to call it ControllerInterface.

public interface ControllerInterface {
void start();
void stop();
void increaseBPM();
void decreaseBPM();
void setBPM(int bpm);
}

Here are all the
methods the view can
call on the controller.
These should look familiar after seeing the model’s
interface. You can stop and start the beat
generation and change the BPM. This interface is
“richer” than the BeatModel interface because you
can adjust the BPMs with increase and decrease.

Design Puzzle
You’ve seen that the view and controller together make use of the Strategy Pattern. Can you draw a
class diagram of the two that represents this pattern?

542

Chapter 12
Download at WoweBook.Com

compound patterns

And here’s the implementation of the controller:
The controller implements
the ControllerInterface.
public class BeatController implements ControllerInterface {
BeatModelInterface model;
The
DJView view;

controller is the creamy stuff
in the middle of the MVC oreo
cookie, so it is the object that
gets to hold on to the view and the
model and glues it all together.

public BeatController(BeatModelInterface model) {
this.model = model;
view = new DJView(this, model);
view.createView();
The controller is passed the
view.createControls();
model in the constructor and
view.disableStopMenuItem();
then creates the view.
view.enableStartMenuItem();
model.initialize();
}
public void start() {
model.on();
view.disableStartMenuItem();
view.enableStopMenuItem();
}
public void stop() {
model.off();
view.disableStopMenuItem();
view.enableStartMenuItem();
}
public void increaseBPM() {
int bpm = model.getBPM();
model.setBPM(bpm + 1);
}
public void decreaseBPM() {
int bpm = model.getBPM();
model.setBPM(bpm - 1);
}
public void setBPM(int bpm) {
model.setBPM(bpm);
}
}

user
When you choose Start from the ns the
interface menu, the controller turr interface
model on and then alters the use bled and
so that the start menu item is disa
the stop menu item is enabled.
Likewise, when you choose Stop from the
menu, the controller turns the model off
and alters the user interface so that
the stop menu item is disabled and the
start menu item is enabled.

If the increase button is clicked, the
controller gets the current BPM
from the model, adds one, and then
sets a new BPM.
Same thing here, only we subtract
one from the current BPM.

NOTE: the controller is
making the intelligent
decisions for the view.
The view just knows how
to turn menu items on
and off; it doesn’t know
the situations in which it
should disable them.

Finally, if the user interface is used to
set an arbitrary BPM, the controller
instructs the model to set its BPM.
you are here 4
Download at WoweBook.Com

543

putting it all together

Putting it all together...
We’ve got everything we need: a model, a view, and a controller.
Now it’s time to put them all together into a MVC! We’re going to
see and hear how well they work together.
All we need is a little code to get things started; it won’t take much:

public class DJTestDrive {
public static void main (String[] args) {
First
BeatModelInterface model = new BeatModel();
ControllerInterface controller = new BeatController(model);
}
}

create a model...

...then create a controller and
pass it the model. Remember, the
controller creates the view, so we
don’t have to do that.

And now for a test run...
File Edit Window Help LetTheBassKick

% java DJTestDrive
%

Run this...

...and you’ll see this.

Things to do
1

Start the beat generation with the Start menu item;
notice the controller disables the item afterwards.

2

Use the text entry along with the increase and decrease
buttons to change the BPM. Notice how the view
display reﬂects the changes despite the fact that it has
no logical link to the controls.

3

Notice how the beat bar always keeps up with the beat
since it’s an observer of the model.

4

Put on your favorite song and see if you can beat match
the beat by using the increase and decrease controls.

5

Stop the generator. Notice how the controller disables
the Stop menu item and enables the Start menu item.

544

Chapter 12
Download at WoweBook.Com

compound patterns

Exploring Strategy
Let’s take the Strategy Pattern just a little further to get a better
feel for how it is used in MVC. We’re going to see another
friendly pattern pop up too – a pattern you’ll often see hanging
around the MVC trio: the Adapter Pattern.
Think for a second about what the DJ View does: it displays
a beat rate and a pulse. Does that sound like something else?
How about a heartbeat? It just so happens we happen to have a
heart monitor class; here’s the class diagram:

HeartModel
getHeartRate()
registerBeatObserver()
registerBPMObserver()
// other heart methods

r getting
We’ve got a method fo .
the current heart rate

And luckily, its developers knew about
the Beat and BPM Observer interfaces!

A

brain
power
It certainly would be nice to reuse our current view with the HeartModel, but we need a controller that
works with this model. Also, the interface of the HeatModel doesn’t match what the view expects
because it has a getHeartRate() method rather than a getBPM(). How would you design a set of
classes to allow the view to be reused with the new model?

you are here 4
Download at WoweBook.Com

545

mvc and adapter

Adapting the Model
For starters, we’re going to need to adapt the HeartModel to a BeatModel. If we don’t, the view
won’t be able to work with the model, because the view only knows how to getBPM(), and the
equivalent heart model method is getHeartRate(). How are we going to do this? We’re going to
use the Adapter Pattern, of course! It turns out that this is a common technique when working
with the MVC: use an adapter to adapt a model to work with existing controllers and views.
Here’s the code to adapt a HeartModel to a BeatModel:

public class HeartAdapter implements BeatModelInterface {
HeartModelInterface heart;
public HeartAdapter(HeartModelInterface heart) {
this.heart = heart;
}
public void initialize() {}

Here, we store a reference
to the heart model.

We don’t know what these would do
to a heart, but it sounds scary. So
we’ll just leave them as “no ops.”

public void on() {}
public void off() {}
public int getBPM() {
return heart.getHeartRate();
}
public void setBPM(int bpm) {}

public void registerObserver(BeatObserver o) {
heart.registerObserver(o);
}
public void removeObserver(BeatObserver o) {
heart.removeObserver(o);
}
public void registerObserver(BPMObserver o) {
heart.registerObserver(o);
}
public void removeObserver(BPMObserver o) {
heart.removeObserver(o);
}
}

546

We need to implement the
target interface, in this
case, BeatModelInterface.

Chapter 12
Download at WoweBook.Com

When getBPM() is called, we’ll just
translate it to a getHeartRate() call
on the heart model.
We don’t want to do this on a heart!
Again, let’s leave it as a “no op”.
Here are our observer methods.
We just delegate them to the
wrapped heart model.

compound patterns

Now we’re ready for a HeartController
With our HeartAdapter in hand we should be ready to create a controller and get the
view running with the HeartModel. Talk about reuse!

public class HeartController implements ControllerInterface {
HeartModelInterface model;
DJView view;
public HeartController(HeartModelInterface model) {
this.model = model;
view = new DJView(this, new HeartAdapter(model));
view.createView();
view.createControls();
view.disableStopMenuItem();
view.disableStartMenuItem();
}

Like before, the controller
creates the view and gets
everything glued together.
There is one change: we are passed a
HeartModel, not a BeatModel...

...and we need to wrap that
model with an adapter before
we hand it to the view.
Finally, the HeartController disables the
menu items as they aren’t needed.

public void start() {}
public void stop() {}
public void increaseBPM() {}
public void decreaseBPM() {}
public void setBPM(int bpm) {}
}

The HeartController implements
the ControllerInterface, just
like the BeatController did.

There’s not a lot to do here;
after all, we can’t really control
hearts like we can beat machines.

And that’s it! Now it’s time for some test code...
public class HeartTestDrive {
public static void main (String[] args) {
HeartModel heartModel = new HeartModel();
ControllerInterface model = new HeartController(heartModel);
}
}

All we need to do is create
the controller and pass it a
heart monitor.
you are here 4
Download at WoweBook.Com

547

test the heart model

And now for a test run...

File Edit Window Help CheckMyPulse

% java HeartTestDrive
%

Run this...

...and you’ll see this.

Things to do
1

Notice that the display works great with a heart!
The beat bar looks just like a pulse. Because the
HeartModel also supports BPM and Beat Observers we
can get beat updates just like with the DJ beats.

2

As the heartbeat has natural variation, notice the
display is updated with the new beats per minute.

3

Each time we get a BPM update the adapter is doing
its job of translating getBPM() calls to getHeartRate()
calls.

4

The Start and Stop menu items are not enabled
because the controller disabled them.

5

The other buttons still work but have no effect
because the controller implements no ops for them.
The view could be changed to support the disabling of
these items.

548

Chapter 12
Download at WoweBook.Com

Nice healthy
heart rate.

compound patterns

MVC and the Web
It wasn’t long after the Web was spun that developers started adapting the MVC to ﬁt the
browser/server model. The prevailing adaptation is known simply as “Model 2” and uses a
combination of servlet and JSP technology to achieve the same separation of model, view and
controller that we see in conventional GUIs.
Let’s check out how Model 2 works:

2

es

at

ti

servlet/controller

n
ta

HT

s
in

1
t
ques
TP re

3

DB

4

Web
browser

HTTP res
5

ponse

<html>
<body>
Refactor
<%= new Foo() %>
<% // more here %>
more here
</body>
</html>

jsp/view

Client

4

bean

model/DB/
business logic

1

You make an HTTP request, which is received by a servlet.
Using your web browser you make an HTTP request. This typically involves
sending along some form data, like your username and password. A servlet
receives this form data and parses it.

2

The servlet acts as the controller.
The servlet plays the role of the controller and processes your request,
most likely making requests on the model (usually a database). The result
of processing the request is usually bundled up in the form of a JavaBean.

3

The controller forwards control to the view.
The View is represented by a JSP. The JSP’s only job is to generate
the page representing the view of model ( 4 which it obtains via the
JavaBean) along with any controls needed for further actions.

5

The view returns a page to the browser via HTTP.
A page is returned to the browser, where it is displayed as the view. The
user submits further requests, which are processed in the same fashion.

you are here 4
Download at WoweBook.Com

549

model 2

You don’t even want to
know what life was like before
Model 2 came on the scene. It was
ugly.

Model 2 is more than just
a clean design.
The beneﬁts of the separation of the view,
model and controller are pretty clear to
you now. But you need to know the “rest
of the story” with Model 2 – that it saved
many web shops from sinking into chaos.
How? Well, Model 2 not only provides
a separation of components in terms of
design, it also provides a separation in
production responsibilities. Let’s face it, in the
old days, anyone with access to your JSPs
could get in and write any Java code they
wanted, right? And that included a lot
of people who didn’t know a jar ﬁle from
a jar of peanut butter. The reality is that
most web producers know about content and
HTML, not software.
Luckily Model 2 came to the rescue.
With Model 2 we can leave the developer
jobs to the guys & girls who know their
Servlets and let the web producers loose
on simple Model 2 style JSPs where all
the producers have access to is HTML
and simple JavaBeans.

550

Chapter 12
Download at WoweBook.Com

former DOT COM’er

compound patterns

Model 2: DJ’ing from a cell phone
You didn’t think we’d try to skip out without moving that
great BeatModel over to the Web did you? Just think, you can
control your entire DJ session through a web page on your
cellular phone. So now you can get out of that DJ booth and
get down in the crowd. What are you waiting for? Let’s write
that code!

The plan
1

Fix up the model.
Well, actually, we don’t have to ﬁx the model, it’s ﬁne just
like it is!

2

Create a servlet controller
We need a simple servlet that can receive our HTTP
requests and perform a few operations on the model. All it
needs to do is stop, start and change the beats per minute.

3

Create a HTML view.
We’ll create a simple view with a JSP. It’s going to receive
a JavaBean from the controller that will tell it everything
it needs to display. The JSP will then generate an HTML
interface.

Geek Bits

Setting up your Ser vlet environment

Showing you how to set up your servlet environment is a little bit off
topic for a book on Design Patterns, at least if you don’t want the book
to weigh more than you do!
Fire up your web browser and head straight to
http://jakarta.apache.org/tomcat/ for the Apache Jakarta Project’s
Tomcat Servlet Container. You’ll find everything you need there to get
you up and running.
You’ll also want to check out Head First Servlets & JSP by Bryan
Basham, Kathy Sierra and Bert Bates.

you are here 4
Download at WoweBook.Com

551

model 2 controller servlet

Step one: the model
Remember that in MVC, the model doesn’t know anything about the views or
controllers. In other words it is totally decoupled. All it knows is that it may have
observers it needs to notify. That’s the beauty of the Observer Pattern. It also
provides an interface the views and controllers can use to get and set its state.
Now all we need to do is adapt it to work in the web environment, but, given that
it doesn’t depend on any outside classes, there is really no work to be done. We
can use our BeatModel off the shelf without changes. So, let’s be productive and
move on to step two!

Step t wo: the controller ser vlet
Remember, the servlet is going to act as our controller; it will receive Web browser
input in a HTTP request and translate it into actions that can be applied to the
model.
Then, given the way the Web works, we need to return a view to the browser. To
do this we’ll pass control to the view, which takes the form of a JSP. We’ll get to
that in step three.
Here’s the outline of the servlet; on the next page, we’ll look at the full
implementation.

We extend the HttpServlet class
so that we can do servlet kinds of
things, like receive HTTP requests.
public class DJView extends HttpServlet {
public void init() throws ServletException {
BeatModel beatModel = new BeatModel();
beatModel.initialize();
getServletContext().setAttribute(“beatModel”, beatModel);
}
// doPost method here

}

552

public void doGet(HttpServletRequest request,
HttpServletResponse response)
throws IOException, ServletException
{
// implementation here
}
Here’s the

Here’s the init method;
this is called when the
servlet is first created.
We first create a
BeatModel object...

...and place a reference to
it in the servlet’s context
so that it’s easily accessed.

doGet() method. This is where the real work
happens. We’ve got its implementation on the next page.

Chapter 12
Download at WoweBook.Com

compound patterns

Here’s the implementation of the doGet() method from the page before:

First we grab the model from
We can’t
without a

public void doGet(HttpServletRequest request,
the servlet context.
HttpServletResponse response)
manipulate the model
throws IOException, ServletException
reference to it.
{
BeatModel beatModel =
(BeatModel)getServletContext().getAttribute(“beatModel”);
String bpm = request.getParameter(“bpm”);
if (bpm == null) {
bpm = beatModel.getBPM() + “”;
}

Next we grab all the HTTP
commands/parameters...

String set = request.getParameter(“set”);
if (set != null) {
int bpmNumber = 90;
bpmNumber = Integer.parseInt(bpm);
beatModel.setBPM(bpmNumber);
}
String decrease = request.getParameter(“decrease”);
if (decrease != null) {
beatModel.setBPM(beatModel.getBPM() - 1);
}
String increase = request.getParameter(“increase”);
if (increase != null) {
beatModel.setBPM(beatModel.getBPM() + 1);
}
String on = request.getParameter(“on”);
if (on != null) {
beatModel.start();
}
String off = request.getParameter(“off”);
if (off != null) {
beatModel.stop();
}
request.setAttribute(“beatModel”, beatModel);
RequestDispatcher dispatcher =
request.getRequestDispatcher(“/jsp/DJView.jsp”);
dispatcher.forward(request, response);
}

If we get a set command, then
we get the value of the set,
and tell the model.

ease, we get the
To increase or decr the model, and
current BPMs from one.
adjust up or down by

If we get an on or off command, we
tell the model to start or stop.
Finally, our job as a controller
is done. All we need to do is
ask the view to take over and
create an HTML view.
Following the Model 2 definition,
we pass the JSP a bean with the
model state in it. In this case, we
pass it the actual model, since it
happens to be a bean.
you are here 4

Download at WoweBook.Com

553

model 2 view

Now we need a view...
All we need is a view and we’ve got our browser-based beat generator ready to go!
In Model 2, the view is just a JSP. All the JSP knows about is the bean it receives
from the controller. In our case, that bean is just the model and the JSP is only
going to use its BPM property to extract the current beats per minute. With that
data in hand, it creates the view and also the user interface controls.

Here’s our bean, which
the servlet passed us.

<jsp:useBean id=”beatModel” scope=”request” class=”headﬁrst.combined.djview.BeatModel” />
<html>
<head>
<title>DJ View</title>
</head>
<body>

Beginning of the HTML.

Here we use the model bean to
extract the BPM property.

<h1>DJ View</h1>
Beats per minutes = <jsp:getProperty name=”beatModel” property=”BPM” />
<br />
<hr>
<br />
<form method=”post” action=”/djview/servlet/DJView”>
BPM: <input type=text name=”bpm”
value=”<jsp:getProperty name=”beatModel”
property=”BPM” />”>
&nbsp;
<input type=”submit”
<input type=”submit”
<input type=”submit”
<input type=”submit”
<input type=”submit”
</form>

name=”set” value=”set”><br />
name=”decrease” value=”<<”>
name=”increase” value=”>>”><br />
name=”on” value=”on”>
name=”off” value=”off”><br />

And here’s the control part
of the view. We have a text
entry for entering a BPM
along with increase/decrease
and on/off buttons.

</body>
</html>

And here’s the end
of the HTML.
NOTICE that just like MVC, in Model 2
the view doesn’t alter the model (that’s the
controller’s job); all it does is use its state!
554

Chapter 12
Download at WoweBook.Com

Now we
generate the
view, which
prints out
the current
beats per
minute.

compound patterns

Putting Model 2 to the test...
It’s time to start your web browser, hit the DJView Servlet and give
the system a spin...

This is the view
of the model.

(1) User clicks the
on button.
(2) Request is sent to
controller via HTTP.

Here’s the set hen
of controls; w
you use these, via
they get sent
HTTP to the ller
servlet contro .
for processing

(3) Beat is turned
on and set at
default 90 BPM.
(4) View is returned
via HTTP and
displayed.

(5) User enters new
BPM in text field.

(6) User clicks
Set button.

(7) HTTP request
is made.
you are here 4
Download at WoweBook.Com

555

things 2 do with model 2

(8) Controller
changes model to
150 BPMs

(9) View returns
HTML reflecting
the current model.

Things to do

556

1

First, hit the web page; you’ll see the beats per minute at 0. Go ahead and
click the “on” button.

2

Now you should see the beats per minute at the default setting: 90 BPM. You
should also hear a beat on the machine the server is running on.

3

Enter a speciﬁc beat, say, 120, and click the “set” button. The page should
refresh with a beats per minute of 120 (and you should hear the beat
increase).

4

Now play with the increase/decrease buttons to adjust the beat up and down.

5

Think about how each step of the system works. The HTML interface makes
a request to the servlet (the controller); the servlet parses the user input and
then makes requests to the model. The servlet then passes control to the
JSP (the view), which creates the HTML view that is returned and displayed.

Chapter 12
Download at WoweBook.Com

compound patterns

Design Patterns and Model 2
After implementing the DJ Control for the Web using Model 2, you might be wondering where the patterns
went. We have a view created in HTML from a JSP but the view is no longer a listener of the model. We have
a controller that’s a servlet that receives HTTP requests, but are we still using the Strategy Pattern? And what
about Composite? We have a view that is made from HTML and displayed in a web browser. Is that still the
Composite Pattern?
Model 2 is an adaptation of MVC to the Web

Even though Model 2 doesn’t look exactly like “textbook” MVC, all the parts are still there; they’ve just been
adapted to reﬂect the idiosyncrasies of the web browser model. Let’s take another look...

Web
browser

Observer
The view is no longer an observer
of the model in the classic
sense; that is, it doesn’t register
with the model to receive state
change notiﬁcations.
However, the view does receive
the equivalent of notiﬁcations
indirectly from the controller
when the model has been
changed. The controller even
passes the view a bean that
allows the view to retrieve the
model’s state.
If you think about the browser
model, the view only needs an
update of state information
when an HTTP response is
returned to the browser;
notiﬁcations at any other time
would be pointless. Only when
a page is being created and
returned does it make sense to
create the view and incorporate
the model’s state.

Here’s a new page
to display

User has done
something

bean
<html>
<body>
BPM
<jsp:getProperty />
more here
</body>
</html>

Update your display,

here’s the new model
state

JSP/HTML
View

ceives
The view now rerom the
notifications fn a page
controller whe r than
is needed rathe change
on every state
in the model.

Okay, I changed
my state

atModel
Be

Controller

Change your
state

on()

setBPM() off()
getBP

M()

you are here 4
Download at WoweBook.Com

557

model 2 patterns

Strategy
In Model 2, the Strategy
object is still the controller
servlet; however, it’s not
directly composed with the
view in the classic manner.
That said, it is an object that
implements behavior for the
view, and we can swap it out
for another controller if we
want different behavior.

Composite
Like our Swing GUI, the
view is ultimately made up
of a nested set of graphical
components. In this case,
they are rendered by a
web browser from an
HTML description, however
underneath there is an
object system that most
likely forms a composite.

Web
browser

Here’s a new page
to display

User has done
something

The controller still
provides the view
behavior, even if it
isn’t composed with
the view using object
composition.

bean
<html>
<body>
BPM
<jsp:getProperty />
more here
</body>
</html>

JSP/HTML
View

Update your display,
here’s the new model
state

Okay, I changed
my state

atMod
Be on() el
setBPM() off()

getBP

558

M()

Chapter 12
Download at WoweBook.Com

Controller

Change your
state

compound patterns

Q:

It seems like you are really hand
waving the fact that the Composite
Pattern is really in MVC. Is it really
there?

A:

Yes, Virginia, there really is a
Composite Pattern in MVC. But, actually,
this is a very good question. Today GUI
packages, like Swing, have become so
sophisticated that we hardly notice the
internal structure and the use of composite
in the building and update of the display.
It’s even harder to see when we have Web
browsers that can take markup language
and convert it into a user interface.
Back when MVC was first discovered,
creating GUIs required a lot more manual
intervention and the pattern was more
obviously part of the MVC.

Q:

Does the controller ever
implement any application logic?

A:

No, the controller implements
behavior for the view. It is the smarts
that translates the actions from the view
to actions on the model. The model
takes those actions and implements the
application logic to decide what to do in
response to those actions. The controller
might have to do a little work to determine
what method calls to make on the model,
but that’s not considered the “application
logic.” The application logic is the code that
manages and manipulates your data and it
lives in your model.

Q:

I’ve always found the word
“model” hard to wrap my head around.
I now get that it’s the guts of the
application, but why was such a vague,
hard-to-understand word used to
describe this aspect of the MVC?

there are no

Dumb Questions

A:

When MVC was named they needed
a word that began with a “M” or otherwise
they couldn’t have called it MVC.
But seriously, we agree with you, everyone
scratches their head and wonders what a
model is. But then everyone comes to the
realization that they can’t think of a better
word either.

Q:

You’ve talked a lot about the state
of the model. Does this mean it has the
State Pattern in it?

A:

No, we mean the general idea of
state. But certainly some models do use the
State Pattern to manage their internal states.

Q:

I’ve seen descriptions of the MVC
where the controller is described as a
“mediator” between the view and the
model. Is the controller implementing the
Mediator Pattern?

A:

We haven’t covered the Mediator
Pattern (although you’ll find a summary of
the pattern in the appendix), so we won’t go
into too much detail here, but the intent of
the mediator is to encapsulate how objects
interact and promote loose coupling by
keeping two objects from referring to each
other explicitly. So, to some degree, the
controller can be seen as a mediator, since
the view never sets state directly on the
model, but rather always goes through the
controller. Remember, however, that the
view does have a reference to the model to
access its state. If the controller were truly a
mediator, the view would have to go through
the controller to get the state of the model
as well.

Q:

Does the view always have to ask
the model for its state? Couldn’t we use
the push model and send the model’s
state with the update notification?

A:

Yes, the model could certainly send
its state with the notification, and in fact, if
you look again at the JSP/HTML view, that’s
exactly what we’re doing. We’re sending
the entire model in a bean, which the view
uses to access the state it needs using the
bean properties. We could do something
similar with the BeatModel by sending just
the state that the view is interested in. If you
remember the Observer Pattern chapter,
however, you’ll also remember that there’s a
couple of disadvantages to this. If you don’t
go back and have a second look.

Q:

If I have more than one view, do I
always need more than one controller?

A:

Typically, you need one controller
per view at runtime; however, the same
controller class can easily manage many
views.

Q:

The view is not supposed to
manipulate the model, however I noticed
in your implementation that the view has
full access to the methods that change
the model’s state. Is this dangerous?

A:

You are correct; we gave the view
full access to the model’s set of methods.
We did this to keep things simple, but there
may be circumstances where you want to
give the view access to only part of your
model’s API. There’s a great design pattern
that allows you to adapt an interface to only
provide a subset. Can you think of it?
you are here 4

Download at WoweBook.Com

559

design toolbox

Tools for your Design Toolbox
You could impress anyone with your design toolbox.
Wow, look at all those principles, patterns and now,
compound patterns!

BULLET POINTS

ß The Model View Controller

s
OO Principrilees.

Pattern (MVC) is a compound
pattern consisting of the
Observer, Strategy and
Composite patterns.

OO Basics

what va
Encapsulate
inheritance.
sition over
Favor compo
not
interfaces,
Program to ions.
implementat
led designs
loosely coup
Strive for jects that interact.
between ob
extension
be open for n.
ld
ou
sh
es
ss
io
Cla
or modificat
but closed f
. Do not
abstractions
Depend on ncrete classes.
depend on co
ds.
o your frien
Only talk t
u.
, we’ll call yo
Don’t call us
reason
ave only one
h
ld
ou
sh
s
A clas
to change.

Abstraction
n
Encapsulatio
m
Polymorphis
Inheritance

ß The model makes use of the
Observer Pattern so that it can
keep observers updated yet
stay decoupled from them.

ß The controller is the strategy
for the view. The view can use
different implementations of
the controller to get different
behavior.

ß The view uses the Composite
Pattern to implement the
user interface, which usually
consists of nested components
like panels, frames and
buttons.

ß These patterns work together

OO Patteinresnafsinfamesoilyaryoofna-edal-dDPgotitreoriofio-tviinnmhmdaeaels,nayannheasts

dF
tceEtEdhtntnnocamsuocacdakbarpsuhjegpesueslasuocflaaabctttlasuantjetheescmtesrlacosomdilsertbasssyieoajengtrstaaochreomontreqalyfeqe,ticauqeultbaoestuullresttyrin. itts
-e eaAan
cchyot-ronM
aAbteesbacgesycorttrv-roaeadrrtef
StrOD
e,w--cE
e
F
n
d
t
o
n
e
ea
a
b
t
r
ll
es
e
m
y
r
le
A
at
ulC
ofatesifgmraancbaaoccpaciltexeitd.eyfiefSo-ostc-rraetttPc,otacrregnntoheoaecdwaahviyanhnantetetdpplegrainosrinreentbefowonsinbgsjebalevioyhttstyjeticdxheelehcaleeibrhettnaltlerasctaetgola,linogwinabristlossgitglljetbitayhhmtyacitto.otleusuptetconohtanges.
encadrpsein
rdP
enF
rd
nge
eSin
o
einchpspteStA
leooobrboabjerje
ngts
trdviee,edfncteoidclitraieenanttds atwnhaitditcttlahhuooussspdeddcexif
atfedrreit
eenealaaab
pdercwsefceopohro
otlaaoanbstorpssu
ld
vielarhstssolynje
inter
habedintndacnost
wDhrleeecnan
moctcil.coliif
tga.ewreftohr ehifs.letas,fetnnegsdaeaninndd
etaeiecrssopnryintpesitesM
it
n
n
li
iz
t
e
e
r
en
l
o
ss
a
e
la
t
ir
w
en
s
c
e
e
iz
b
ss
c
a
t
h
r
t
ep
t
a
e
n
e
t
su
d
F
st
c
s,
c
q
e
r
t
e
m
c
in
e
f
g
e
o
a
je
d
u
st
.
a
varydaesp
cahaonryetnaintivmiaorabtolls,elyaqquueineuusteeaoonrrtloialogtgiorrneqtuoe the
ltinpeeostpnrcpTnif
.st
lietfs,ye.r oabblele ooppeerraattioionns.s.
afuuatnocrmrtlaceealaqiossqtussnuiceeadst
tterns
tt uunnddoa
r
o
p
o
p
p
su
e
p
Compound Pa
subsuclass rs.

We have a new
category! MVC
and Model 2 are
compound patterns.

ines two
attern comb lution that
P
d
un
po
om
so
AC
m.
terns into a
or more pat rring or general proble
cu
re
a
es
solv

560

Chapter 12
Download at WoweBook.Com

to decouple the three players in
the MVC model, which keeps
designs clear and flexible.

ß The Adapter Pattern can be
used to adapt a new model to
an existing view and controller.

ß Model 2 is an adaptation of
MVC for web applications.

ß In Model 2, the controller is
implemented as a servlet and
JSP & HTML implement the
view.

compound patterns

Exercise solutions
Sharpen your pencil
The QuackCounter is a Quackable too. When we change Quackable to extend
QuackObservable, we have to change every class that implements Quackable,
including QuackCounter:

le, so
QuackCounter is a Quackab too.
le
vab
ser
now it’s a QuackOb
public class QuackCounter implements Quackable {
Quackable duck;
static int numberOfQuacks;
public QuackCounter(Quackable duck) {
this.duck = duck;
}
public void quack() {
duck.quack();
numberOfQuacks++;
}
public static int getQuacks() {
return numberOfQuacks;
}

Here’s the duck that the
QuackCounter is decorating.
It’s this duck that really
needs to handle the
observable methods.

the
All of this code is us
same as the previo ounter.
version of QuackC

public void registerObserver(Observer observer) {
duck.registerObserver(observer);
}
public void notifyObservers() {
duck.notifyObservers();
}
}

Here are the two
QuackObservable
methods. Notice that
we just delegate both
calls to the duck that
we’re decorating.

you are here 4
Download at WoweBook.Com

561

sharpen solution

Sharpen your pencil
What if our Quackologist wants to observe an entire ﬂock? What does that mean
anyway? Think about it like this: if we observe a composite, then we’re observing
everything in the composite. So, when you register with a ﬂock, the ﬂock composite
makes sure you get registered with all its children, which may include other ﬂocks.

Flock is a Quackable, so now
it’s a QuackObservable too.
public class Flock implements Quackable {
ArrayList ducks = new ArrayList();
public void add(Quackable duck) {
ducks.add(duck);
}

Here’s the Quackables that
are in the Flock.

public void quack() {
Iterator iterator = ducks.iterator();
while (iterator.hasNext()) {
Quackable duck = (Quackable)iterator.next();
duck.quack();
}
}
public void registerObserver(Observer observer) {
Iterator iterator = ducks.iterator();
while (iterator.hasNext()) {
Quackable duck = (Quackable)iterator.next();
duck.registerObserver(observer);
}
}
public void notifyObservers() { }
}

562

Each Quackable does its own notification,
so Flock doesn’t have to worry about it.
This happens when Flock delegates quack()
to each Quackable in the Flock.

Chapter 12
Download at WoweBook.Com

Observer
When you register as antually
with the Flock, you ac erything
get registered with ev ich is
that’s IN the flock, whher it’s a
every Quackable, whet
duck or another Flock.
We iterate through all the
Quackables in the Flock and
delegate the call to each
Quackable. If the Quackable
is another Flock, it will do
the same.

compound patterns

Sharpen your pencil
We’re still directly instantiating Geese by relying on concrete classes. Can you write
an Abstract Factory for Geese? How should it handle creating “goose ducks?”

You could add a createGooseDuck() method to the existing Duck Factories. Or, you
could create a completely separate Factory for creating families of Geese.

Design Class
You’ve seen that the View and Controller together make use of the Strategy Pattern. Can you draw a
class diagram of the two that shows this pattern?

The view delegates
behavior to the
controller. The
behavior it
delegates is how to
control the model
based on user input.

<<interface>>
ControllerInterface

DJView
controller

setBPM()

createView()

increaseBPM()

updateBPM()

decreaseBPM()

updateBeat()
createControls()

The
ControllerInterface
is the interface
that all concrete
controllers implement.
This is the strategy
interface.

enableStopMenuItem()
disableStopMenuItem()

Controller

enableStartMenuItem()
disableStartMenuItem()

setBPM()

actionPerformed()

increaseBPM()
decreaseBPM()

We can plug in
different controllers
to provide different
behaviors for the view.

you are here 4
Download at WoweBook.Com

563

ready-bake code: the dj application

Ready-bake Code

Here’s the complete implementation of the DJView. It shows all the
MIDI code to generate the sound, and all the Swing components to
create the view. You can also download this code at
http://www.headfirstlabs.com. Have fun!

package headﬁrst.combined.djview;
public class DJTestDrive {
public static void main (String[] args) {
BeatModelInterface model = new BeatModel();
ControllerInterface controller = new BeatController(model);
}
}

The Beat Model
package headﬁrst.combined.djview;
public interface BeatModelInterface {
void initialize();
void on();
void off();
void setBPM(int bpm);
int getBPM();
void registerObserver(BeatObserver o);
void removeObserver(BeatObserver o);
void registerObserver(BPMObserver o);
void removeObserver(BPMObserver o);
}

564

Chapter 12
Download at WoweBook.Com

compound patterns

package headﬁrst.combined.djview;
import javax.sound.midi.*;
import java.util.*;
public class BeatModel implements BeatModelInterface, MetaEventListener {
Sequencer sequencer;
ArrayList beatObservers = new ArrayList();
ArrayList bpmObservers = new ArrayList();
int bpm = 90;
// other instance variables here
Sequence sequence;
Track track;
public void initialize() {
setUpMidi();
buildTrackAndStart();
}
public void on() {
sequencer.start();
setBPM(90);
}
public void off() {
setBPM(0);
sequencer.stop();
}
public void setBPM(int bpm) {
this.bpm = bpm;
sequencer.setTempoInBPM(getBPM());
notifyBPMObservers();
}
public int getBPM() {
return bpm;
}
void beatEvent() {
notifyBeatObservers();
}

public void registerObserver(BeatObserver o) {
beatObservers.add(o);
}
public void notifyBeatObservers() {
for(int i = 0; i < beatObservers.size(); i++) {
you are here 4
Download at WoweBook.Com

565

ready-bake code: model

Ready-bake Code
BeatObserver observer = (BeatObserver)beatObservers.get(i);
observer.updateBeat();
}
}
public void registerObserver(BPMObserver o) {
bpmObservers.add(o);
}
public void notifyBPMObservers() {
for(int i = 0; i < bpmObservers.size(); i++) {
BPMObserver observer = (BPMObserver)bpmObservers.get(i);
observer.updateBPM();
}
}

public void removeObserver(BeatObserver o) {
int i = beatObservers.indexOf(o);
if (i >= 0) {
beatObservers.remove(i);
}
}

public void removeObserver(BPMObserver o) {
int i = bpmObservers.indexOf(o);
if (i >= 0) {
bpmObservers.remove(i);
}
}

public void meta(MetaMessage message) {
if (message.getType() == 47) {
beatEvent();
sequencer.start();
setBPM(getBPM());
}
}
public void setUpMidi() {
try {
sequencer = MidiSystem.getSequencer();

566

Chapter 12
Download at WoweBook.Com

compound patterns

sequencer.open();
sequencer.addMetaEventListener(this);
sequence = new Sequence(Sequence.PPQ,4);
track = sequence.createTrack();
sequencer.setTempoInBPM(getBPM());
} catch(Exception e) {
e.printStackTrace();
}
}
public void buildTrackAndStart() {
int[] trackList = {35, 0, 46, 0};
sequence.deleteTrack(null);
track = sequence.createTrack();
makeTracks(trackList);
track.add(makeEvent(192,9,1,0,4));
try {
sequencer.setSequence(sequence);
} catch(Exception e) {
e.printStackTrace();
}
}
public void makeTracks(int[] list) {
for (int i = 0; i < list.length; i++) {
int key = list[i];
if (key != 0) {
track.add(makeEvent(144,9,key, 100, i));
track.add(makeEvent(128,9,key, 100, i+1));
}
}
}
public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
MidiEvent event = null;
try {
ShortMessage a = new ShortMessage();
a.setMessage(comd, chan, one, two);
event = new MidiEvent(a, tick);
} catch(Exception e) {
e.printStackTrace();
}
return event;
}
}
you are here 4
Download at WoweBook.Com

567

ready-bake code: view

The View

Ready-bake Code

package headﬁrst.combined.djview;
public interface BeatObserver {
void updateBeat();
}

package headﬁrst.combined.djview;
public interface BPMObserver {
void updateBPM();
}
package headﬁrst.combined.djview;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class DJView implements ActionListener,
BeatModelInterface model;
ControllerInterface controller;
JFrame viewFrame;
JPanel viewPanel;
BeatBar beatBar;
JLabel bpmOutputLabel;
JFrame controlFrame;
JPanel controlPanel;
JLabel bpmLabel;
JTextField bpmTextField;
JButton setBPMButton;
JButton increaseBPMButton;
JButton decreaseBPMButton;
JMenuBar menuBar;
JMenu menu;
JMenuItem startMenuItem;
JMenuItem stopMenuItem;

BeatObserver, BPMObserver {

public DJView(ControllerInterface controller, BeatModelInterface model) {
this.controller = controller;
this.model = model;
model.registerObserver((BeatObserver)this);
model.registerObserver((BPMObserver)this);
}
public void createView() {

568

Chapter 12
Download at WoweBook.Com

compound patterns
// Create all Swing components here
viewPanel = new JPanel(new GridLayout(1, 2));
viewFrame = new JFrame(“View”);
viewFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
viewFrame.setSize(new Dimension(100, 80));
bpmOutputLabel = new JLabel(“ofﬂine”, SwingConstants.CENTER);
beatBar = new BeatBar();
beatBar.setValue(0);
JPanel bpmPanel = new JPanel(new GridLayout(2, 1));
bpmPanel.add(beatBar);
bpmPanel.add(bpmOutputLabel);
viewPanel.add(bpmPanel);
viewFrame.getContentPane().add(viewPanel, BorderLayout.CENTER);
viewFrame.pack();
viewFrame.setVisible(true);
}

public void createControls() {
// Create all Swing components here
JFrame.setDefaultLookAndFeelDecorated(true);
controlFrame = new JFrame(“Control”);
controlFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
controlFrame.setSize(new Dimension(100, 80));
controlPanel = new JPanel(new GridLayout(1, 2));
menuBar = new JMenuBar();
menu = new JMenu(“DJ Control”);
startMenuItem = new JMenuItem(“Start”);
menu.add(startMenuItem);
startMenuItem.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {
controller.start();
}
});
stopMenuItem = new JMenuItem(“Stop”);
menu.add(stopMenuItem);
stopMenuItem.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {
controller.stop();
//bpmOutputLabel.setText(“ofﬂine”);
}
});
JMenuItem exit = new JMenuItem(“Quit”);
exit.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {
System.exit(0);
}
});

you are here 4
Download at WoweBook.Com

569

ready-bake code: view

Ready-bake Code
menu.add(exit);
menuBar.add(menu);
controlFrame.setJMenuBar(menuBar);
bpmTextField = new JTextField(2);
bpmLabel = new JLabel(“Enter BPM:”, SwingConstants.RIGHT);
setBPMButton = new JButton(“Set”);
setBPMButton.setSize(new Dimension(10,40));
increaseBPMButton = new JButton(“>>”);
decreaseBPMButton = new JButton(“<<”);
setBPMButton.addActionListener(this);
increaseBPMButton.addActionListener(this);
decreaseBPMButton.addActionListener(this);
JPanel buttonPanel = new JPanel(new GridLayout(1, 2));
buttonPanel.add(decreaseBPMButton);
buttonPanel.add(increaseBPMButton);
JPanel enterPanel = new JPanel(new GridLayout(1, 2));
enterPanel.add(bpmLabel);
enterPanel.add(bpmTextField);
JPanel insideControlPanel = new JPanel(new GridLayout(3, 1));
insideControlPanel.add(enterPanel);
insideControlPanel.add(setBPMButton);
insideControlPanel.add(buttonPanel);
controlPanel.add(insideControlPanel);
bpmLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
bpmOutputLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
controlFrame.getRootPane().setDefaultButton(setBPMButton);
controlFrame.getContentPane().add(controlPanel, BorderLayout.CENTER);
controlFrame.pack();
controlFrame.setVisible(true);
}
public void enableStopMenuItem() {
stopMenuItem.setEnabled(true);
}
public void disableStopMenuItem() {
stopMenuItem.setEnabled(false);

570

Chapter 12
Download at WoweBook.Com

compound patterns

}
public void enableStartMenuItem() {
startMenuItem.setEnabled(true);
}
public void disableStartMenuItem() {
startMenuItem.setEnabled(false);
}
public void actionPerformed(ActionEvent event) {
if (event.getSource() == setBPMButton) {
int bpm = Integer.parseInt(bpmTextField.getText());
controller.setBPM(bpm);
} else if (event.getSource() == increaseBPMButton) {
controller.increaseBPM();
} else if (event.getSource() == decreaseBPMButton) {
controller.decreaseBPM();
}
}
public void updateBPM() {
int bpm = model.getBPM();
if (bpm == 0) {
bpmOutputLabel.setText(“ofﬂine”);
} else {
bpmOutputLabel.setText(“Current BPM: “ + model.getBPM());
}
}
public void updateBeat() {
beatBar.setValue(100);
}
}

The Controller
package headﬁrst.combined.djview;
public interface ControllerInterface {
void start();
void stop();
void increaseBPM();
void decreaseBPM();
void setBPM(int bpm);
}
you are here 4
Download at WoweBook.Com

571

ready-bake code: controller

Ready-bake Code

package headﬁrst.combined.djview;
public class BeatController implements ControllerInterface {
BeatModelInterface model;
DJView view;
public BeatController(BeatModelInterface model) {
this.model = model;
view = new DJView(this, model);
view.createView();
view.createControls();
view.disableStopMenuItem();
view.enableStartMenuItem();
model.initialize();
}
public void start() {
model.on();
view.disableStartMenuItem();
view.enableStopMenuItem();
}
public void stop() {
model.off();
view.disableStopMenuItem();
view.enableStartMenuItem();
}
public void increaseBPM() {
int bpm = model.getBPM();
model.setBPM(bpm + 1);
}
public void decreaseBPM() {
int bpm = model.getBPM();
model.setBPM(bpm - 1);
}
public void setBPM(int bpm) {
model.setBPM(bpm);
}
}

572

Chapter 12
Download at WoweBook.Com

compound patterns

The Heart Model
package headﬁrst.combined.djview;
public class HeartTestDrive {
public static void main (String[] args) {
HeartModel heartModel = new HeartModel();
ControllerInterface model = new HeartController(heartModel);
}
}

package headﬁrst.combined.djview;
public interface HeartModelInterface {
int getHeartRate();
void registerObserver(BeatObserver o);
void removeObserver(BeatObserver o);
void registerObserver(BPMObserver o);
void removeObserver(BPMObserver o);
}

package headﬁrst.combined.djview;
import java.util.*;
public class HeartModel implements HeartModelInterface, Runnable {
ArrayList beatObservers = new ArrayList();
ArrayList bpmObservers = new ArrayList();
int time = 1000;
int bpm = 90;
Random random = new Random(System.currentTimeMillis());
Thread thread;
public HeartModel() {
thread = new Thread(this);
thread.start();
}
public void run() {
int lastrate = -1;
for(;;) {
int change = random.nextInt(10);
if (random.nextInt(2) == 0) {
change = 0 - change;
}
int rate = 60000/(time + change);
if (rate < 120 && rate > 50) {
time += change;
you are here 4
Download at WoweBook.Com

573

ready-bake code: heart beat model
notifyBeatObservers();
if (rate != lastrate) {
lastrate = rate;
notifyBPMObservers();
}

Ready-bake Code

}
try {
Thread.sleep(time);
} catch (Exception e) {}
}
}
public int getHeartRate() {
return 60000/time;
}
public void registerObserver(BeatObserver o) {
beatObservers.add(o);
}
public void removeObserver(BeatObserver o) {
int i = beatObservers.indexOf(o);
if (i >= 0) {
beatObservers.remove(i);
}
}
public void notifyBeatObservers() {
for(int i = 0; i < beatObservers.size(); i++) {
BeatObserver observer = (BeatObserver)beatObservers.get(i);
observer.updateBeat();
}
}
public void registerObserver(BPMObserver o) {
bpmObservers.add(o);
}
public void removeObserver(BPMObserver o) {
int i = bpmObservers.indexOf(o);
if (i >= 0) {
bpmObservers.remove(i);
}
}
public void notifyBPMObservers() {
for(int i = 0; i < bpmObservers.size(); i++) {
BPMObserver observer = (BPMObserver)bpmObservers.get(i);
observer.updateBPM();
}
}
}

574

Chapter 12
Download at WoweBook.Com

compound patterns

The Heart Adapter
package headﬁrst.combined.djview;
public class HeartAdapter implements BeatModelInterface {
HeartModelInterface heart;
public HeartAdapter(HeartModelInterface heart) {
this.heart = heart;
}
public void initialize() {}
public void on() {}
public void off() {}
public int getBPM() {
return heart.getHeartRate();
}
public void setBPM(int bpm) {}
public void registerObserver(BeatObserver o) {
heart.registerObserver(o);
}
public void removeObserver(BeatObserver o) {
heart.removeObserver(o);
}
public void registerObserver(BPMObserver o) {
heart.registerObserver(o);
}
public void removeObserver(BPMObserver o) {
heart.removeObserver(o);
}
}

you are here 4
Download at WoweBook.Com

575

ready-bake code: heart beat controller

The Controller

Ready-bake Code

package headﬁrst.combined.djview;
public class HeartController implements ControllerInterface {
HeartModelInterface model;
DJView view;
public HeartController(HeartModelInterface model) {
this.model = model;
view = new DJView(this, new HeartAdapter(model));
view.createView();
view.createControls();
view.disableStopMenuItem();
view.disableStartMenuItem();
}
public void start() {}
public void stop() {}
public void increaseBPM() {}
public void decreaseBPM() {}
public void setBPM(int bpm) {}
}

576

Chapter 12
Download at WoweBook.Com

13 Better Living with Patterns

hPatterns in the

h g

Real World

g

Ahhhh, now you’re ready for a bright new world filled with
Design Patterns. But, before you go opening all those new doors of opportunity, we
need to cover a few details that you’ll encounter out in the real world – that’s right, things get
a little more complex than they are here in Objectville. Come along, we’ve got a nice guide to
help you through the transition on the next page...

this is a new chapter
Download at WoweBook.Com

577

what you’ll learn from the guide

ide to
u
G
le
il
v
t
c
je
b
O
e
Th
rns
e
t
t
a
P
n
ig
s
e
D
h
Better Living wit
s in the real
n
er
tt
a
p
h
it
w
g
n
vi

li
tips & tricks for
h
it
w
e
id
u
g
y
d
n
r ha
Please accept ouguide you will:
world. In this
e deﬁnition of a
th
t
u
o
b
a
s
n
o
ti
p
ce
iscon
ll too common m
a
e
th
rn
ea
L
b
n.”
“Design Patter
y you just have to
h
w
d
n
a
s
g
lo
ta
a
C
Design Pattern
ty
if
n
se
o
th
r
ve
co
b Dis
get one.
e wrong time.
th
t
a
n
er
tt
a
P
n
ig
t of using a Des
en
m
ss
a
rr
a
b
em
e
b Avoid th
they belong.
e
er
h
w
s
n
o
ti
ca
iﬁ
in class
to keep patterns
w
o
h
rn
ea
L
b
read our quick
s;
ru
u
g
e
th
r
fo
st
isn’t ju
covering patterttnserns writer too.
is
d
t
a
th
ee
S
b
ome a pa
d.
HowTo and bec
of Four is reveale
g
n
a
G
s
u
io
er
st
y
m
ue identity of the
tr
e
th
en
h
w
e
er
b Be th
y patterns user
n
a
s
k
o
o
b
le
b
ta
ffee
eighbors – the co
n
e
th
h
it
w
p
u
p
b Kee
must own.
en master.
Z
a
e
k
li
d
in
m
r
u
train yo
b Learn to
your patterns
g
n
vi
ro
p
im
y
b
s
er
inﬂuence develop
d
n
a
s
d
n
ie
fr
in
b W
vocabulary.

578

Chapter 13
Download at WoweBook.Com

better living with patterns

Design Pattern defined
We bet you’ve got a pretty good idea of what a pattern is after reading this book. But
we’ve never really given a deﬁnition for a Design Pattern. Well, you might be a bit
surprised by the deﬁnition that is in common use:

A Pattern is a solution to a problem in a context.

That’s not the most revealing deﬁnition is it? But don’t worry, we’re going to step
through each of these parts, context, problem and solution:

Example: You have a
collection of objects.
The context is the situation in which the pattern applies. This
should be a recurring situation.
The problem refers to the goal you are trying to achieve in this
context, but it also refers to any constraints that occur in the
context.
The solution is what you’re after: a general design that anyone
can apply which resolves the goal and set of constraints.

You need to step
through the objects
without exposing
the collection’s
implementation.

Encapsulate the
iteration into a
separate class.

This is one of those deﬁnitions that takes a while to sink in, but take it one step at a
time. Here’s a little mnemonic you can repeat to yourself to remember it:

“If you find yourself in a context with a problem that has a goal
that is affected by a set of constraints, then you can apply
a design that resolves the goal and constraints and leads to a
solution.”
Now, this seems like a lot of work just to ﬁgure out what a Design Pattern is. After all,
you already know that a Design Pattern gives you a solution to a common recurring
design problem. What is all this formality getting you? Well, you’re going to see that
by having a formal way of describing patterns we can create a catalog of patterns,
which has all kinds of beneﬁts.

you are here 4
Download at WoweBook.Com

579

design pattern deﬁned

I’ve been thinking
about the three-part
deﬁnition, and I don’t think
it deﬁnes a pattern at all.

You might be right; let’s think about this a bit... We need a problem, a
solution and a context:
Problem: How do I get to work on time?
Context: I’ve locked my keys in the car.
Solution: Break the window, get in the car, start
the engine and drive to work.
We have all the components of the deﬁnition: we have a problem,
which includes the goal of getting to work, and the constraints of time,
distance and probably some other factors. We also have a context in
which the keys to the car are inaccessible. And we have a solution that
gets us to the keys and resolves both the time and distance constraints.
We must have a pattern now! Right?

A

brain
power
We followed the Design Pattern deﬁnition and deﬁned a problem, a context, and a solution (which
works!). Is this a pattern? If not, how did it fail? Could we fail the same way when deﬁning an OO
Design Pattern?

580

Chapter 13
Download at WoweBook.Com

better living with patterns

Looking more closely at the
Design Pattern definition
Our example does seem to match the Design
Pattern deﬁnition, but it isn’t a true pattern. Why?
For starters, we know that a pattern needs to apply
to a recurring problem. While an absent-minded
person might lock his keys in the car often, breaking
the car window doesn’t qualify as a solution that
can be applied over and over (or at least isn’t likely
to if we balance the goal with another constraint:
cost).

Next time someone tells you
a pattern is a solution to a problem
in a context, just nod and smile. You
know what they mean, even if it isn’t a
deﬁnition sufﬁcient to describe what
a Design Pattern really is.

It also fails in a couple of other ways: ﬁrst, it isn’t
easy to take this description, hand it to someone
and have him apply it to his own unique problem.
Second, we’ve violated an important but simple
aspect of a pattern: we haven’t even given it a
name! Without a name, the pattern doesn’t
become part of a vocabulary that can be shared
with other developers.
Luckily, patterns are not described and documented
as a simple problem, context and solution; we
have much better ways of describing patterns and
collecting them together into patterns catalogs.

Q:

Am I going to see pattern
descriptions that are stated as a problem,
a context and a solution?

A:

Pattern descriptions, which you’ll
typically find in pattern catalogs, are usually
a bit more revealing than that. We’re going
to look at pattern catalogs in detail in just
a minute; they describe a lot more about a
pattern’s intent and motivation and where it
might apply, along with the solution design
and the consequences (good and bad) of
using it.

Q:

Is it okay to slightly alter a
pattern’s structure to fit my design? Or
am I going to have to go by the strict
definition?

A:

Of course you can alter it. Like
design principles, patterns are not meant
to be laws or rules; they are guidelines that
you can alter to fit your needs. As you’ve
seen, a lot of real-world examples don’t fit
the classic pattern designs.
However, when you adapt patterns, it
never hurts to document how your pattern
differs from the classic design – that way,
other developers can quickly recognize the
patterns you’re using and any differences
between your pattern and the classic
pattern.

Pat
te
A-C rns

Pat
te
D-G rns

Pat
te
H-N rns

Pat
te
O-R rns

Pat
te
S-Z rns

Q:

Where can I get a patterns
catalog?

A:

The first and most definitive
patterns catalog is Design Patterns:
Elements of Reusable Object-Oriented
Software, by Gamma, Helm, Johnson &
Vlissides (Addison Wesley). This catalog
lays out 23 fundamental patterns. We’ll talk
a little more about this book in a few pages.
Many other patterns catalogs are starting to
be published in various domain areas such
as enterprise software, concurrent systems
and business systems.

you are here 4
Download at WoweBook.Com

581

forces goals constraints

Geek Bits

May the force be with you

The Design Pattern
definition tells us that
the problem consists of a
goal and a set of constraints.
Patterns gurus have a term
for these: they call them
forces. Why? Well, we’re sure
they have their own reasons, but if
you remember the movie, the force
“shapes and controls the Universe.”
Likewise, the forces in the pattern
definition shape and control the solution.
Only when a solution balances both sides of
the force (the light side: your goal, and the dark
side: the constraints) do we have a useful pattern.
This “force” terminology can be quite confusing
when you first see it in pattern discussions, but
just remember that there are two sides of the force
(goals and constraints) and that they need to be
balanced or resolved to create a pattern solution. Don’t
let the lingo get in your way and may the force be with you!

582

Chapter 13
Download at WoweBook.Com

better living with patterns

I wish I’d known about
patterns catalogs a long
time ago...

Frank

Jim

Joe

Frank: Fill us in, Jim. I’ve just been learning patterns by reading a
few articles here and there.
Jim: Sure, each pattern catalog takes a set of patterns and describes
each in detail along with its relationship to the other patterns.
Joe: Are you saying there is more than one patterns catalog?
Jim: Of course; there are catalogs for fundamental Design Patterns
and there are also catalogs on domain speciﬁc patterns, like EJB
patterns.
Frank: Which catalog are you looking at?
Jim: This is the classic GoF catalog; it contains 23 fundamental
Design Patterns.
Frank: GoF?
Jim: Right, that stands for the Gang of Four. The Gang of Four are
the guys that put together the ﬁrst patterns catalog.
Joe: What’s in the catalog?
Jim: There is a set of related patterns. For each pattern there is a
description that follows a template and spells out a lot of details of the
pattern. For instance, each pattern has a name.
you are here 4
Download at WoweBook.Com

583

using a pattern catalog

Frank: Wow, that’s earth-shattering – a name! Imagine that.
Jim: Hold on Frank; actually, the name is really important. When we have a name
for a pattern, it gives us a way to talk about the pattern; you know, that whole shared
vocabulary thing.
Frank: Okay, okay. I was just kidding. Go on, what else is there?
Jim: Well, like I was saying, every pattern follows a template. For each pattern we have
a name and a few sections that tell us more about the pattern. For instance, there is an
Intent section that describes what the pattern is, kind of like a deﬁnition. Then there are
Motivation and Applicability sections that describe when and where the pattern might be
used.
Joe: What about the design itself ?
Jim: There are several sections that describe the class design along with all the classes
that make it up and what their roles are. There is also a section that describes how to
implement the pattern and often sample code to show you how.
Frank: It sounds like they’ve thought of everything.
Jim: There’s more. There are also examples of where the pattern has been used in real
systems as well as what I think is one of the most useful sections: how the pattern relates
to other patterns.
Frank: Oh, you mean they tell you things like how state and strategy differ?
Jim: Exactly!
Joe: So Jim, how are you actually using the catalog? When you have a problem, do you
go ﬁshing in the catalog for a solution?
Jim: I try to get familiar with all the patterns and their relationships ﬁrst. Then, when I
need a pattern, I have some idea of what it is. I go back and look at the Motivation and
Applicability sections to make sure I’ve got it right. There is also another really important
section: Consequences. I review that to make sure there won’t be some unintended effect
on my design.
Frank: That makes sense. So once you know the pattern is right, how do you approach
working it into your design and implementing it?
Jim: That’s where the class diagram comes in. I ﬁrst read over the Structure section to
review the diagram and then over the Participants section to make sure I understand each
classes’ role. From there I work it into my design, making any alterations I need to make
it ﬁt. Then I review the Implementation and Sample code sections to make sure I know
about any good implementation techniques or gotchas I might encounter.
Joe: I can see how a catalog is really going to accelerate my use of patterns!
Frank: Totally. Jim, can you walk us through a pattern description?
584

Chapter 13
Download at WoweBook.Com

better living with patterns

All patterns in a catalog start
with a name. The name is a vital
part of a pattern - without a
good name, a pattern can’t become
part of the vocabulary that you
share with other developers.
The motivation gives you a concrete
scenario that describes the problem and
how the solution solves the problem.

SINGLETON

Object Creational

Intent
Et aliquat, velesto ent lore feuis acillao
rperci tat, quat nonsequam il ea at nim
nos do enim
qui eratio ex ea faci tet, sequis dion
utat, volore magnisi.

Motivation
Et aliquat, velesto ent lore feuis acillao
rperci tat, quat nonsequam il ea at nim
nos do enim
qui eratio ex ea faci tet, sequis dion
utat, volore magnisi.Rud modolore
dit laoreet augiam iril
el dipis dionsequis dignibh eummy
nibh esequat. Duis nulputem ipisim
esecte conullut wissi.
Os nisissenim et lumsandre do con
el utpatuero corercipis augue doloreet
luptat amet vel
iuscidunt digna feugue dunt num etummy
nim dui blaor sequat num vel etue magna
augiat.
Aliquis nonse vel exer se minissequis
do dolortis ad magnit, sim zzrillut ipsummo
dolorem
dignibh euguer sequam ea am quate
magnim illam zzrit ad magna feu facinit
delit ut

Applicability

Duis nulputem ipisim esecte conullut
wissiEctem ad magna aliqui blamet,
conullandre
dolore magna feuis nos alit ad magnim
quate modolore vent lut luptat prat.
Dui blaore min
ea feuipit ing enit laore magnibh eniat
wisissecte et, suscilla ad mincinci blam
dolorpe rcilit
irit, conse dolore dolore et, verci enis
enit ip elesequisl ut ad esectem ing ea
con eros autem
diam nonullu tpatiss ismodignibh er.

Structure

The applicability describes situations
in which the pattern can be applied.

Singleton
static uniqueInstance
// Other useful Singleton data...
static getInstance()
// Other useful Singleton methods...

Participants

sses and
The participants are the cla
tion
sec
is
Th
.
objects in the design
and
ies
ilit
sib
pon
describes their res
roles in the pattern.

Duis nulputem ipisim esecte conullut
wissiEctem ad magna aliqui blamet,
conullandre
dolore magna feuis nos alit ad magnim
quate modolore vent lut luptat prat.
Dui blaore min
ea feuipit ing enit laore magnibh eniat
wisissecte et, suscilla ad mincinci blam
dolorpe rcilit
irit, conse dolore dolore et, verci enis
enit ip elesequisl ut ad esectem ing ea
con eros autem
diam nonullu tpatiss ismodignibh er

ß A dolore dolore et, verci enis enit
ip elesequisl ut ad esectem ing ea con
eros autem diam
nonullu tpatiss ismodignibh er

– A feuis nos alit ad magnim quate
modolore vent lut luptat prat. Dui blaore
min ea
feuipit ing enit laore magnibh eniat
wisissec
– Ad magnim quate modolore vent
lut luptat prat. Dui blaore min ea feuipit
ing enit

The structure provides a
diagram illustrating the
relationships among the
classes that participate
in the pattern.

Collaborations
ß Feuipit ing enit laore magnibh eniat
wisissecte et, suscilla ad mincinci blam
dolorpe rcilit
irit, conse dolore.

Consequences

The consequences describe the
effects that using this pattern
may have: good and bad.

This is the pattern’s
classification or
category. We’ll talk
about these in a
few pages.
The intent describes what
the pattern does in a short
statement. You can also think
of this as the pattern’s
definition (just like we’ve been
using in this book).

Duis nulputem ipisim esecte conullut

wissiEctem ad magna aliqui blamet,
conullandre:
1. Dolore dolore et, verci enis enit ip
elesequisl ut ad esectem ing ea con
eros autem
diam nonullu tpatiss ismodignibh er.
2. Modolore vent lut luptat prat. Dui
blaore min ea feuipit ing enit laore magnibh
eniat wisissecte et, suscilla ad mincinci
blam dolorpe rcilit irit, conse dolore
dolore
et, verci enis enit ip elesequisl ut ad
esectem.

Collaborations tells us
how the participants work
together in the pattern.

3. Dolore dolore et, verci enis enit ip
elesequisl ut ad esectem ing ea con
eros autem
diam nonullu tpatiss ismodignibh er.
4. Modolore vent lut luptat prat. Dui
blaore min ea feuipit ing enit laore magnibh
eniat wisissecte et, suscilla ad mincinci
blam dolorpe rcilit irit, conse dolore
dolore
et, verci enis enit ip elesequisl ut ad
esectem.

Implementation/Sample Code

Implementation provides
techniques you need to use when
implementing this pattern, and
issues you should watch out for.

DuDuis nulputem ipisim esecte conullut
wissiEctem ad magna aliqui blamet,
conullandre
dolore magna feuis nos alit ad magnim
quate modolore vent lut luptat prat.
Dui blaore min
ea feuipit ing enit laore magnibh eniat
wisissecte et, suscilla ad mincinci blam
dolorpe rcilit
irit, conse dolore dolore et, verci enis
enit ip elesequisl ut ad esectem ing ea
con eros autem
diam nonullu tpatiss ismodignibh er.
public class Singleton {
private static Singleton
uniqueInstance;
// other useful instance
variables here
private Singleton() {}
public static synchroniz
ed Singleton getInstance()
{
if (uniqueInstance == null)
{
uniqueInstance = new Singleton(
);
}
return uniqueInstance;
}
}

Known uses describes
examples of this pattern
found in real systems.

// other useful methods
here

Nos alit ad magnim quate modolore
vent lut luptat prat. Dui blaore min
ea feuipit ing enit
laore magnibh eniat wisissecte et, suscilla
ad mincinci blam dolorpe rcilit irit,
conse dolore
dolore et, verci enis enit ip elesequisl
ut ad esectem ing ea con eros autem
diam nonullu
tpatiss ismodignibh er.

Sample code
provides code
fragments tha
t
might help wit
h
your implement
ation.

Known Uses
DuDuis nulputem ipisim esecte conullut
wissiEctem ad magna aliqui blamet,
conullandre
dolore magna feuis nos alit ad magnim
quate modolore vent lut luptat prat.
Dui blaore min
ea feuipit ing enit laore magnibh eniat
wisissecte et, suscilla ad mincinci blam
dolorpe rcilit
irit, conse dolore dolore et, verci enis
enit ip elesequisl ut ad esectem ing ea
con eros autem
diam nonullu tpatiss ismodignibh er.

DuDuis nulputem ipisim esecte conullut
wissiEctem ad magna aliqui blamet,
conullandre
dolore magna feuis nos alit ad magnim
quate modolore vent lut luptat prat.
Dui blaore min
ea feuipit ing enit laore magnibh eniat
wisissecte et, suscilla ad mincinci blam
dolorpe rcilit
irit, conse dolore dolore et, verci enis
enit ip elesequisl ut ad esectem ing ea
con eros autem
diam nonullu tpatiss ismodignibh er.
alit ad magnim quate modolore vent
lut luptat prat.
Dui blaore min ea feuipit ing enit laore
magnibh eniat wisissecte et, suscilla
ad mincinci blam
dolorpe rcilit irit, conse dolore dolore
et, verci enis enit ip elesequisl ut ad
esectem ing ea con
eros autem diam nonullu tpatiss ismodignib
h er.

Related Patterns
Elesequisl ut ad esectem ing ea con
eros autem diam nonullu tpatiss ismodignib
h er. alit
ad magnim quate modolore vent lut
luptat prat. Dui blaore min ea feuipit
ing enit laore
magnibh eniat wisissecte et, suscilla
ad mincinci blam dolorpe rcilit irit,
conse dolore dolore
et, verci enis enit ip elesequisl ut ad
esectem ing ea con eros autem diam
nonullu tpatiss
ismodignibh er.

Related patterns
describes the
relationship between
this pattern and others.

you are here 4
Download at WoweBook.Com

585

discovering your own patterns

there are no

Q:

Dumb Questions

Is it possible to create your own Design
Patterns? Or is that something you have to be a
“patterns guru” to do?

A:

First, remember that patterns are discovered,
not created. So, anyone can discover a Design Pattern
and then author its description; however, it’s not easy
and doesn’t happen quickly, nor often. Being a “patterns
writer” takes commitment.
You should first think about why you’d want to – the
majority of people don’t author patterns; they just use
them. However, you might work in a specialized domain
for which you think new patterns would be helpful, or
you might have come across a solution to what you
think is a recurring problem, or you may just want to get
involved in the patterns community and contribute to the
growing body of work.

Q:
A:

I’m game; how do I get started?

So you wanna be a design
patterns star?
Well listen now to what I tell.
Get yourself a patterns
catalog,
Then take some time and
learn it well.

Like any discipline, the more you know the
better. Studying existing patterns, what they do and
how they relate to other patterns is crucial. Not only
does it make you familiar with how patterns are crafted,
it prevents you from reinventing the wheel. From there
you’ll want to start writing your patterns on paper, so you
can communicate them to other developers; we’re going
to talk more about how to communicate your patterns in
a bit. If you’re really interested, you’ll want to read the
section that follows these Q&As.

And when you’ve got your
description right,

Q:
A:

Then you’ll know it’s a
pattern alright.

How do I know when I really have a pattern?

And three developers agree
without a fight,

That’s a very good question: you don’t have a
pattern until others have used it and found it to work.
In general, you don’t have a pattern until it passes the
“Rule of Three.” This rule states that a pattern can be
called a pattern only if it has been applied in a real-world
solution at least three times.

586

Chapter 13
Download at WoweBook.Com

To the tune of “So you wanna
be a Rock’n Roll Star.”

better living with patterns

So you wanna be a Design Patterns writer
Do your homework. You need to be well versed in the
existing patterns before you can create a new one. Most patterns
that appear to be new, are, in fact, just variants of existing
patterns. By studying patterns, you become better at recognizing
them, and you learn to relate them to other patterns.
Take time to reﬂect, evaluate. Your experience – the
problems you’ve encountered, and the solutions you’ve used – are
where ideas for patterns are born. So take some time to reﬂect
on your experiences and comb them for novel designs that recur.
Remember that most designs are variations on existing patterns
and not new patterns. And when you do ﬁnd what looks like a
new pattern, its applicability may be too narrow to qualify as a
real pattern.
Get your ideas down on paper in a way others can
understand. Locating new patterns isn’t of much use if others
can’t make use of your ﬁnd; you need to document your pattern
candidates so that others can read, understand, and apply them
to their own solution and then supply you with feedback. Luckily,
you don’t need to invent your own method of documenting your
patterns. As you’ve already seen with the GoF template, a lot of
thought has already gone into how to describe patterns and their
characteristics.
Have others try your patterns; then reﬁne and reﬁne
some more. Don’t expect to get your pattern right the ﬁrst
time. Think of your pattern as a work in progress that will
improve over time. Have other developers review your candidate
pattern, try it out, and give you feedback. Incorporate that
feedback into your description and try again. Your description
will never be perfect, but at some point it should be solid enough
that other developers can read and understand it.

Use one of the existing
pattern templates to
define your pattern. A
lot of thought has gone
into these templates and
other pattern users will
recognize the format.

N ame
In te n t
io n
Mot iv at
ili ty
App lic ab
e
St ruct ur
ts
Pa rt ic ip an on s
ti
ra
bo
Co lla
...

Don’t forget the rule of three. Remember, unless your
pattern has been successfully applied in three real-world
solutions, it can’t qualify as a pattern. That’s another good
reason to get your pattern into the hands of others so they can
try it, give feedback, and allow you to converge on a working
pattern.
you are here 4
Download at WoweBook.Com

587

who does what?

Match each pattern with its description:

Pattern

Decorator
State
Iterator
Facade
Strategy
Proxy
Factory Method
Adapter
Observer
Template Method
Composite
Singleton
Abstract Factory
Command
588

Description

Wraps an object and provides a different
interface to it.
Subclasses decide how to implement steps
in an algorithm.
Subclasses decide which concrete classes to
create.
Ensures one and only object is created.
Encapsulates interchangeable behaviors and
uses delegation to decide which one to use.
Clients treat collections of objects and
individual objects uniformly.
Encapsulates state-based behaviors and uses
delegation to switch between behaviors.
Provides a way to traverse a collection of
objects without exposing its implementation.
Simpliﬁes the interface of a set of classes.
Wraps an object to provide new behavior.
Allows a client to create families of objects
without specifying their concrete classes.
Allows objects to be notiﬁed when state
changes.
Wraps an object to control access to it.
Encapsulates a request as an object.

Chapter 13
Download at WoweBook.Com

better living with patterns

Organizing Design Patterns
As the number of discovered Design Patterns grows, it makes sense to partition them into classiﬁcations so
that we can organize them, narrow our searches to a subset of all Design Patterns, and make comparisons
within a group of patterns.
In most catalogs you’ll ﬁnd patterns grouped into one of a few classiﬁcation schemes. The most well-known
scheme was used by the ﬁrst pattern catalog and partitions patterns into three distinct categories based on
their purposes: Creational, Behavioral and Structural.

Sharpen your pencil
Abstract Factory
State

Decorator

Observer

Composite

Adapter

Factory Method

Command

Proxy
Iterator

Strategy

Singleton

Read each category description and see
if you can corral these patterns into their
correct categories. This is a toughy! But
give it your best shot and then check out
the answers on the next page.

Template Method
Facade

tterns belongs
Each of these pacategories
in one of those

Any pattern that is a Behavioral
Pattern is concerned with how
classes and objects interact and
distribute responsibility.

Creational patterns involve
object instantiation and all
provide a way to decouple a client
from the objects it needs to
instantiate.

Creation al

Behavioral

Structural

Structural patterns let you
compose classes or objects
into larger structures.

you are here 4
Download at WoweBook.Com

589

pattern categories

Solution: Pattern Categories
Here’s the grouping of patterns into categories. You probably found the exercise difﬁcult,
because many of the patterns seem like they could ﬁt into more than one category. Don’t worry,
everyone has trouble ﬁguring out the right categories for the patterns.

Creational patterns involve
object instantiation and all
provide a way to decouple a client
from the objects it needs to
instantiate.

Any pattern that is a Behavioral
Pattern is concerned with how
classes and objects interact and
distribute responsibility.

Creation al

Behavioral

Mediator
Visitor
Iterator
Command
Memento
Interpreter
Observer
Chain of Responsibility
State
Strategy

Singleton

Builder
Prototype

Template Method

Abstract Factory
Factory Method

Structural
Decorator
Flyweight

Composite

Proxy

Facade
Bridge

Adapter

Structural patterns let you
compose classes or objects
into larger structures.

590

Chapter 13
Download at WoweBook.Com

We’ve got a few patterns
(in grey) that you haven’t
seen yet. You’ll find an
overview of the these
patterns in the appendix.

better living with patterns
Patterns are often classiﬁed by a second attribute: whether or not
the pattern deals with classes or objects:
Object patterns describe
relationships between
objects and are primarily
deﬁned by composition.
Relationships in object
patterns are typically
created at runtime and
are more dynamic and
ﬂexible.

Class patterns describe how relationships between
classes are deﬁned via inheritance. Relationships in
class patterns are established at compile time.

Class

Object

Template Method
Factory Method

Visitor
Iterator
Command
Memento
Facade
Observer
Chain of Responsibility
Bridge
Mediator
State
Prototype
Flyweight
Composite

Adapter

Decorator
Proxy
Strategy

Interpreter

Abstract Factory

Builder
Singleton

Q:

Are these the only classification
schemes?

there are no

Dumb Questions

A:

A:

Q:

Q:

No, other schemes have been
proposed. Some other schemes start
with the three categories and then add
subcategories, like “Decoupling Patterns.”
You’ll want to be familiar with the most
common schemes for organizing patterns,
but also feel free to create your own, if it
helps you to understand the patterns better.
Does organizing patterns into
categories really help you remember
them?

It certainly gives you a framework
for the sake of comparison. But many
people are confused by the creational,
structural and behavioral categories; often
a pattern seems to fit into more than one
category. The most important thing is to
know the patterns and the relationships
among them. When categories help, use
them!
Why is the Decorator Pattern in
the structural category? I would have
thought of that as a behavioral pattern;
after all it adds behavior!

a
Notice there’jesct
lot more ob an
patterns th ns!
class patter

A:

Yes, lots of developers say that!
Here’s the thinking behind the Gang of Four
classification: structural patterns describe
how classes and objects are composed to
create new structures or new functionality.
The Decorator Pattern allows you to
compose objects by wrapping one object
with another to provide new functionality.
So the focus is on how you compose the
objects dynamically to gain functionality,
rather than on the communication and
interconnection between objects, which is
the purpose of behavioral patterns. But
remember, the intent of these patterns
is different, and that’s often the key to
understanding which category a pattern
belongs to.

you are here 4
Download at WoweBook.Com

591

pattern categories

Master and Student...
Master: Grasshopper, you look troubled.
Student: Yes, I’ve just learned about
pattern classiﬁcation and I’m confused.
Master: Grasshopper, continue...
Student: After learning much about patterns, I’ve
just been told that each pattern ﬁts into one of three
classiﬁcations: structural, behavioral or creational. Why
do we need these classiﬁcations?
Master: Grasshopper, whenever we have a large
collection of anything, we naturally ﬁnd categories to ﬁt
those things into. It helps us to think of the items at a
more abstract level.
Student: Master; can you give me an example?
Master: Of course. Take automobiles; there are many
different models of automobiles and we naturally put
them into categories like economy cars, sports cars,
SUVs, trucks and luxury car categories.
Master: Grasshopper, you look shocked, does this not
make sense?
Student: Master, it makes a lot of sense, but I am
shocked you know so much about cars!
Master: Grasshopper, I can’t relate everything to lotus
ﬂowers or rice bowls. Now, may I continue?
Student: Yes, yes, I’m sorry, please continue.
Master: Once you have classiﬁcations or categories
you can easily talk about the different groupings: “If
you’re doing the mountain drive from Silicon Valley to
Santa Cruz, a sports car with good handling is the best
option.” Or, “With the worsening oil situation you really
want to buy a economy car, they’re more fuel-efﬁcient.”
Student: So by having categories we can talk about a
set of patterns as a group. We might know we need a
creational pattern, without knowing exactly which one,
but we can still talk about creational patterns.
Master: Yes, and it also gives us a way to compare a
member to the rest of the category, for example, “the
Mini really is the most stylish compact car around”, or
to narrow our search, “I need a fuel efﬁcient car.”

592

Chapter 13
Download at WoweBook.Com

better living with patterns

Student: I see, so I might say that the Adapter pattern
is the best structural pattern for changing an object’s
interface.
Master: Yes. We also can use categories for one more
purpose: to launch into new territory; for instance,
“we really want to deliver a sports car with ferrari
performance at miata prices.”
Student: That sounds like a death trap.
Master: I’m sorry, I did not hear you Grasshopper.
Student: Uh, I said “I see that.”
Student: So categories give us a way to think about the
way groups of patterns relate and how patterns within
a group relate to one another. They also give us a way
to extrapolate to new patterns. But why are there three
categories and not four, or ﬁve?
Master: Ah, like stars in the night sky, there are as many
categories as you want to see. Three is a convenient
number and a number that many people have decided
makes for a nice grouping of patterns. But others have
suggested four, ﬁve or more.

you are here 4
Download at WoweBook.Com

593

thinking in patterns

Thinking in Patterns
Contexts, constraints, forces, catalogs, classiﬁcations... boy, this
is starting to sound mighty academic. Okay, all that stuff is
important and knowledge is power. But, let’s face it, if you
understand the academic stuff and don’t have the experience
and practice using patterns, then it’s not going to make much
difference in your life.
Here’s a quick guide to help you start to think in patterns. What do
we mean by that? We mean being able to look at a design and see
where patterns naturally ﬁt and where they don’t.

Your Brain on Patterns

Keep it simple (KISS)
First of all, when you design, solve things in the simplest way possible. Your goal should be simplicity, not
“how can I apply a pattern to this problem.” Don’t feel like you aren’t a sophisticated developer if you
don’t use a pattern to solve a problem. Other developers will appreciate and admire the simplicity of your
design. That said, sometimes the best way to keep your design simple and ﬂexible is to use a pattern.

Design Patterns aren’t a magic bullet; in fact they’re not even a bullet!
Patterns, as you know, are general solutions to recurring problems. Patterns also have the beneﬁt of being
well tested by lots of developers. So, when you see a need for one, you can sleep well knowing many
developers have been there before and solved the problem using similar techniques.
However, patterns aren’t a magic bullet. You can’t plug one in, compile and then take an early lunch. To
use patterns, you also need to think through the consequences on the rest of your design.

You know you need a pattern when...
Ah... the most important question: when do you use a pattern? As you approach your design, introduce a
pattern when you’re sure it addresses a problem in your design. If a simpler solution might work, give that
consideration before you commit to using a pattern.
Knowing when a pattern applies is where your experience and knowledge come in. Once you’re sure a
simple solution will not meet your needs, you should consider the problem along with the set of constraints
under which the solution will need to operate — these will help you match your problem to a pattern. If
you’ve got a good knowledge of patterns, you may know of a pattern that is a good match. Otherwise,
survey patterns that look like they might solve the problem. The intent and applicability sections of the
patterns catalogs are particularly useful for this. Once you’ve found a pattern that appears to be a good
match, make sure it has a set of consequences you can live with and study its effect on the rest of your
design. If everything looks good, go for it!

594

Chapter 13
Download at WoweBook.Com

better living with patterns

There is one situation in which you’ll want to use a pattern even if a
simpler solution would work: when you expect aspects of your system to
vary. As we’ve seen, identifying areas of change in your design is usually a
good sign that a pattern is needed. Just make sure you are adding patterns
to deal with practical change that is likely to happen, not hypothetical change
that may happen.
Design time isn’t the only time you want to consider introducing patterns,
you’ll also want to do so at refactoring time.

Refactoring time is Patterns time!
Refactoring is the process of making changes to your code to improve
the way it is organized. The goal is to improve its structure, not change
its behavior. This is a great time to reexamine your design to see if it
might be better structured with patterns. For instance, code that is full
of conditional statements might signal the need for the State pattern. Or,
it may be time to clean up concrete dependencies with a Factory. Entire
books have been written on the topic of refactoring with patterns, and as
your skills grow, you’ll want to study this area more.

Take out what you don’t really need. Don’t be afraid
to remove a Design Pattern from your design.
No one ever talks about when to remove a pattern. You’d think it was
blasphemy! Nah, we’re all adults here; we can take it.
So when do you remove a pattern? When your system has become
complex and the ﬂexibility you planned for isn’t needed. In other words,
when a simpler solution without the pattern would be better.

Center your thinking
on design, not on patterns.
Use patterns when there
is a natural need for them.
If something simpler will
work, then use it.

If you don’t need it now, don’t do it now.
Design Patterns are powerful, and it’s easy to see all kinds of ways
they can be used in your current designs. Developers naturally love to
create beautiful architectures that are ready to take on change from any
direction.
Resist the temptation. If you have a practical need to support change in
a design today, go ahead and employ a pattern to handle that change.
However, if the reason is only hypothetical, don’t add the pattern, it is
only going to add complexity to your system, and you might never need it!
you are here 4
Download at WoweBook.Com

595

patterns emerge naturally

Master and Student...
Master: Grasshopper, your initial training is almost
complete. What are your plans?
Student: I’m going to Disneyland! And, then I’m
going to start creating lots of code with patterns!
Master: Whoa, hold on. Never use your big guns unless you have to.
Student: What do you mean, Master? Now that I’ve learned design
patterns shouldn’t I be using them in all my designs to achieve
maximum power, ﬂexibility and manageability?
Master: No; patterns are a tool, and a tool that should only be used
when needed. You’ve also spent a lot of time learning design principles.
Always start from your principles and create the simplest code you can
that does the job. However, if you see the need for a pattern emerge,
then use it.
Student: So I shouldn’t build my designs from patterns?
Master: That should not be your goal when beginning a design. Let
patterns emerge naturally as your design progresses.
Student: If patterns are so great, why should I be so careful about
using them?
Master: Patterns can introduce complexity, and we never want
complexity where it is not needed. But patterns are powerful when used
where they are needed. As you already know, patterns are proven
design experience that can be used to avoid common mistakes. They’re
also a shared vocabulary for communicating our design to others.
Student: Well, when do we know it’s okay to introduce design patterns?
Master: Introduce a pattern when you are sure it’s necessary to solve a
problem in your design, or when you are quite sure that it is needed to
deal with a future change in the requirements of your application.
Student: I guess my learning is going to continue even though I already
understand a lot of patterns.
Master: Yes, grasshopper; learning to manage the complexity and
change in software is a life long pursuit. But now that you know a good
set of patterns, the time has come to apply them where needed in your
design and to continue learning more patterns.
Student: Wait a minute, you mean I don’t know them ALL?
Master: Grasshopper, you’ve learned the fundamental patterns; you’re
going to ﬁnd there are many more, including patterns that just apply to
particular domains such as concurrent systems and enterprise systems.
But now that you know the basics, you’re in good shape to learn them!

596

Chapter 13
Download at WoweBook.Com

better living with patterns

Your Mind on Patterns

Beginner Mind

The Beginner uses patterns everywhere. This is good:
the beginner gets lots of experience with and practice using
patterns. The beginner also thinks, “The more patterns I use,
the better the design.” The beginner will learn this is not so,
that all designs should be as simple as possible. Complexity
and patterns should only be used where they are needed for
practical extensibility.

“I need a pattern for Hello World.”

As learning progresses, the Intermediate mind
starts to see where patterns are needed and
where they aren’t. The intermediate mind still tries
to fit too many square patterns into round holes, but
also begins to see that patterns can be adapted to
fit situations where the canonical pattern doesn’t fit.

Intermediate
Mind

“Maybe I need a Singleton here.”

Zen Mind

“This is a natural place for Decorator.”

The Zen mind is able to see patterns where they fit naturally.
The Zen mind is not obsessed with using patterns; rather it
looks for simple solutions that best solve the problem. The Zen
mind thinks in terms of the object principles and their trade-offs.
When a need for a pattern naturally arises, the Zen mind applies
it knowing well that it may require adaptation. The Zen mind
also sees relationships to similar patterns and understands the
subtleties of differences in the intent of related patterns. The
Zen mind is also a Beginner mind — it doesn’t let all that pattern
knowledge overly influence design decisions.

you are here 4
Download at WoweBook.Com

597

when not to use patterns

WARNING: Overuse of design patterns can lead to

is downright over-engineered. Always go with code that
solution that does the job and introduce patte the simplest
rns where the need
emerges.

Wait a minute; I’ve
read this entire book and now
you’re telling me NOT to use
patterns?

Of course we want you to
use Design Patterns!
But we want you to be a good OO designer even
more.
When a design solution calls for a pattern, you get
the beneﬁts of using a solution that has been time
tested by lots of developers. You’re also using a
solution that is well documented and that other
developers are going to recognize (you know, that
whole shared vocabulary thing).
However, when you use Design Patterns, there
can also be a downside. Design Patterns often
introduce additional classes and objects, and so
they can increase the complexity of your designs.
Design Patterns can also add more layers to your
design, which adds not only complexity, but also
inefﬁciency.
Also, using a Design Pattern can sometimes be
outright overkill. Many times you can fall back on
your design principles and ﬁnd a much simpler
solution to solve the same problem. If that
happens, don’t ﬁght it. Use the simpler solution.
Don’t let us discourage you, though. When a
Design Pattern is the right tool for the job, the
advantages are many.
598

Chapter 13
Download at WoweBook.Com

better living with patterns

Don’t forget the power of the
shared vocabulary
We’ve spent so much time in this book discussing OO nuts and bolts that it’s
easy to forget the human side of Design Patterns – they don’t just help load
your brain with solutions, they also give you a shared vocabulary with other
developers. Don’t underestimate the power of a shared vocabulary, it’s one of
the biggest beneﬁts of Design Patterns.
Just think, something has changed since the last time we talked about shared
vocabularies; you’ve now started to build up quite a vocabulary of your own!
Not to mention, you have also learned a full set of OO design principles from
which you can easily understand the motivation and workings of any new
patterns you encounter.
Now that you’ve got the Design Pattern basics down, it’s time for you to
go out and spread the word to others. Why? Because when your fellow
developers know patterns and use a shared vocabulary as well, it leads to
better designs, better communication and, best of all, it’ll save you a lot of
time that you can spend on cooler things.

So I created this broadcast class. It
keeps track of all the objects listening to it
and anytime a new piece of data comes along
it sends a message to each listener. What’s cool
is that the listeners can join the broadcast at any
time or they can even remove themselves. And the
broadcast class itself doesn’t know anything about
the listeners, any object can register that
implements the right interface.

Time-consuming
Incomplete

Confusing

you are here 4
Download at WoweBook.Com

599

ﬁve ways to share your vocabulary

Top ﬁve ways to share your vocabulary
1 In design meetings: When you meet with your team to discuss
a software design, use design patterns to help stay “in the design”
longer. Discussing designs from the perspective of Design Patterns
and OO principles keeps your team from getting bogged down in
implementation details and prevent many misunderstandings.
2 With other developers: Use patterns in your discussions with
other developers. This helps other developers learn about new
patterns and builds a community. The best part about sharing what
you’ve learned is that great feeling when someone else “gets it!”
3 In architecture documentation: When you write
architectural documentation, using patterns will reduce the amount
of documentation you need to write and gives the reader a clearer
picture of the design.
4 In code comments and naming conventions: When
you’re writing code, clearly identify the patterns you’re using in
comments. Also, choose class and methods names that reveal any
patterns underneath. Other developers who have to read your
code will thank you for allowing them to quickly understand your
implementation.
5 To groups of interested developers: Share your knowledge.
Many developers have heard about patterns but don’t have a good
understanding of what they are. Volunteer to give a brown-bag lunch
on patterns or a talk at your local user group.

Succinct
Precise

Observer

Complete

600

Chapter 13
Download at WoweBook.Com

better living with patterns

Cruisin’ Object ville with
the Gang of Four
You won’t ﬁnd the Jets or Sharks hanging around Objectville, but
you will ﬁnd the Gang of Four. As you’ve probably noticed, you
can’t get far in the World of Patterns without running into them.
So, who is this mysterious gang?
Put simply, “the GoF,” which includes Erich Gamma, Richard
Helm, Ralph Johnson and John Vlissides, is the group of guys who
put together the ﬁrst patterns catalog and in the process, started an
entire movement in the software ﬁeld!

The GoF launched the software
patterns movement, but many others
have made significant contributions,
including Ward Cunningham, Kent
Beck, Jim Coplien, Grady Booch, Bruce
Anderson, Richard Gabriel, Doug Lea,
Peter Coad, and Doug Schmidt, to
name just a few.

How did they get that name? No one knows for sure; it’s just a
name that stuck. But think about it: if you’re going to have a
“gang element” running around Objectville, could you think of a
nicer bunch of guys? In fact, they’ve even agreed to pay us a visit...

Today
there are more
patterns than in the
GoF book; learn about
them as well.

Shoot for practical
extensibility. Don’t
provide hypothetical
generality; be extensible
in ways that matter.

Richard
Helm

John Vlissides

Objectville Patterns Tour

Go for simplicity
and don’t become over-excited.
If you can come up with a
simpler solution without using a
pattern, then go for it.

Ralph
Johnson

Patterns are
tools not rules - they
need to be tweaked and
adapted to
your problem.

Erich Gamma

you are here 4
Download at WoweBook.Com

601

patterns resources

Your journey has just begun...
Now that you’re on top of Design Patterns and ready to dig deeper, we’ve got three deﬁnitive
texts that you need to add to your bookshelf...

The deﬁnitive Design Patterns text
This is the book that kicked off the entire ﬁeld of Design
Patterns when it was released in 1995. You’ll ﬁnd all the
fundamental patterns here. In fact, this book is the basis for
the set of patterns we used in Head First Design Patterns.
You won’t ﬁnd this book to be the last word on Design
Patterns – the ﬁeld has grown substantially since its
publication – but it is the ﬁrst and most deﬁnitive.
Picking up a copy of Design Patterns is a great way to start
exploring patterns after Head First.

ign Patterns areof Four”
The authors of Des
n as the “Gang
affectionately knt.ow
or GoF for shor

Christopher Alexander invented
patterns, which inspired applying
similar solutions to software.
The deﬁnitive Patterns texts
Patterns didn’t start with the GoF; they started with
Christopher Alexander, a Professor of Architecture
at Berkeley – that’s right, Alexander is an architect,
not a computer scientist. Alexander invented
patterns for building living architectures (like
houses, towns and cities).
The next time you’re in the mood for some deep,
engaging reading, pick up The Timeless Way of
Building and A Pattern Language. You’ll see the true
beginnings of Design Patterns and recognize
the direct analogies between creating “living
architecture” and ﬂexible, extensible software.
So grab a cup of Starbuzz Coffee, sit back, and
enjoy...

602

Chapter 13
Download at WoweBook.Com

better living with patterns

Other Design Pattern resources
You’re going to ﬁnd there is a vibrant, friendly community of patterns
users and writers out there and they’re glad to have you join them.
Here’s a few resources to get you started...
Websites
The Portland Patterns Repository, run by
Ward Cunningham, is a WIKI devoted to all
things related to patterns. Anyone can participate.
You’ll ﬁnd threads of discussion on every topic
you can think of related to patterns and OO
systems.
http://c2.com/cgi/wiki?WelcomeVisitors

The Hillside Group fosters common
programming and design practices and provides
a central resource for patterns work. The site
includes information on many patterns-related
resources such as articles, books, mailing lists and
tools.
http://hillside.net/

���������������������������

�

���������������������������������������

����������������������������������������������
�������������������������������������������������
��������������������
�����������������������������������������
�����������������������������������
�������������
��������������������

��������������
�����������
�����������
������������ �
������������������������������
���������������
��������������������

��������������
�����������
�����������
��������������������
����������������������
����������������������
��������������������
���������������������

��������������
�����������
������������ �
���������
����������������������
������������������
��������
������������������
������������
��������������������

�����������������������

��������������
�����������
���������
����������������������
������������������
��������
������������������
������������
�����������������������
������������������

����������������������

��������������
�����������
�����������
���������
����������������������
������������������
��������
������������������
�������������������
����������������������

����
���������
����������

�������������������������������������������������������������������������
�����������������������������������������������������������������������
������������������������������������������������������������������������
�������������������������������������������������������������������������
������������������������������������������������������������������������
������������������������������������������������������������������������������
��������������������������������������������������������������������������
���������������������������������������������������������������
�
� �������������������������������������������������������������������
����������������������������������������������������������������������
���������������������������������������������������������������������������
�������������������������������������

������
���������
���������

������������

�������
�������

���������������
��������������������������������������������������������������
��������������������������������������������������������������������������������������������������������
������������������������ ��������������������������������������������������������
����������������

����������������������
��������������������������������������
���������������������������

�����������������������
��������������
���������������������������������������
��������������������������������������������
�����������������������������������������

��������������������������
������������������
������������������������������������������

�����������������������
�����������������������������������������

��������������������������
���������������������������������
���������������������

������������������������
����������������������������

Conferences and Workshops
And if you’d like to get some face-to-face time with
the patterns community, be sure to check out the
many patterns related conferences and workshops.
The Hillside site maintains a complete list. At
the least you’ll want to check out OOPSLA, the
ACM Conference on Object-Oriented Systems,
Languages and Applications.

�������������������������������������������������������������������
��� �������������������������������������������������������
��� ������������������������������������������������������

�������������������������������������������������������������������������������

you are here 4
Download at WoweBook.Com

603

patterns zoo

The Patterns Zoo
As you’ve just seen, patterns didn’t start with software; they started
with the architecture of buildings and towns. In fact, the patterns
concept can be applied in many different domains. Take a walk
around the Patterns Zoo to see a few...

Architectural Patterns are
used to create the living,
vibrant architecture of
buildings, towns, and cities.
This is where patterns got
their start.

Habitat: seen hanging around
3-tier architectures, clientserver systems and the web.

Habitat: found in buildings you
like to live in, look at and visit.

Application Patterns are
patterns for creating
system level architecture.
Many multi-tier
architectures fall into this
category.

Field note: MVC has been
known to pass for an
application pattern.

Domain-Speciﬁc Patterns
are patterns that concern
problems in speciﬁc domains,
like concurrent systems or
real-time systems.

604

Help find a habitat
J2EE

Chapter 13
Download at WoweBook.Com

better living with patterns

Seen hanging around co
rporate
boardrooms and projec
t
management meetings.

Business Process Patterns
describe the interaction
between businesses, customers
and data, and can be applied
to problems such as how
to effectively make and
communicate decisions.

Organizational Patterns
describe the structures
and practices of human
organizations. Most
efforts to date have
focused on organizations
that produce and/or
support software.

Help find a habitat
Development team
Customer support team

User Interface
Design Patterns
address the
problems of how to
design interactive
software programs.

Habitat: seen in the vicinity
of video game designers, GUI
builders, and producers.

Field notes: please add your observations of pattern domains here:

you are here 4
Download at WoweBook.Com

605

anti-patterns

Annihilating evil with Anti-Patterns
The Universe just wouldn’t be complete if we had patterns and no
anti-patterns, now would it?
If a Design Pattern gives you a general solution to a recurring
problem in a particular context, then what does an anti-pattern
give you?

An Anti-Pattern tells you how to go from a problem
to a BAD solution.

You’re probably asking yourself, “Why on earth would anyone
waste their time documenting bad solutions?”
Think about it like this: if there is a recurring bad solution to a
common problem, then by documenting it we can prevent other
developers from making the same mistake. After all, avoiding bad
solutions can be just as valuable as ﬁnding good ones!
Let’s look at the elements of an anti-pattern:
An anti-pattern tells you why a bad solution is
attractive. Let’s face it, no one would choose a bad solution if
there wasn’t something about it that seemed attractive up front.
One of the biggest jobs of the anti-pattern is to alert you to the
seductive aspect of the solution.
An anti-pattern tells you why that solution in the long
term is bad. In order to understand why it’s an anti-pattern,
you’ve got to understand how it’s going to have a negative effect
down the road. The anti-pattern describes where you’ll get into
trouble using the solution.
An anti-pattern suggests other patterns that are
applicable which may provide good solutions. To be
truly helpful an anti-pattern needs to point you in the right
direction; it should suggest other possibilities that may lead to
good solutions.
Let’s have a look at an anti-pattern.

606

Chapter 13
Download at WoweBook.Com

An anti-pattern always
looks like a good solution,
but then turns out to be
a bad solution when it is
applied.
By documenting antipatterns we help
others to recognize bad
solutions before they
implement them.
Like patterns, there
are many types
of anti-patterns
including development,
OO, organizational,
and domain specific
anti-patterns.

better living with patterns

Here’s an example of a software development anti-pattern.
Just like a Design Pattern,
an anti-pattern has a name
so we can create a shared
vocabulary.

The problem and context,
just like a Design Pattern
description.

Anti-Pattern
Name: Golden Hammer
Problem: You need to choose technologies for
your development and you believe that exactly one
technology must dominate the architecture.
Context: You need to develop some new system
or piece of software that doesn’t fit well with the
technology that the development team is familiar with.
Forces:
• The development team is committed to the
technology they know.

Tells you why
the solution is
attractive.

The bad, yet attractive solution.
How to get to a
good solution.

Example of where this anti-pattern
has been observed.

• The development team is not familiar with
other technologies.
• Unfamiliar technologies are seen as risky.
• It is easy to plan and estimate for
development using the familiar technology.
Supposed Solution: Use the familiar technology
anyway. The technology is applied obsessively to
many problems, including places where it is clearly
inappropriate.
Refactored Solution: Expanding the knowledge of
developers through education, training, and book
study groups that expose developers to new solutions.
Examples:
Web companies keep using and maintaining their
internal homegrown caching systems when open
source alternatives are in use.

Portland Patteomrn/
e
th
m
ro
f
d
te
Adap
I at http://c2.c
Repository’s WIKd many anti patterns and
where you’ll fin
discussions.
you are here 4
Download at WoweBook.Com

607

design toolbox

Tools for your Design Toolbox
You’ve reached that point where you’ve outgrown us.
Now’s the time to go out in the world and explore
patterns on your own...

s
OO Principle
es.
te what vari

OO Basics

OO Patteinresnafsinfamesoilyaryoofna-edal-dDPgotitreoriofio-tviinnmhmdaeaels,nayannheasts

608

your designs, don’t force them
in just for the sake of using a
pattern.
stone; adapt and tweak them to
meet your needs.

ß Always use the simplest
solution that meets your needs,
even if it doesn’t include a
pattern.

The time has come
for you to go out and
discover more patterns
on your own. There are
many domain-specific
patterns we haven’t even
mentioned and there are
also some foundational
ones we didn’t cover.
You’ve also got patterns
of your own to create.

dF
tceEtEdhtntnnocamsuocacdakbarpsuhjegpesueslasuocflaaabctttlasuaontjetheescmtuesrlacosomdilserrtbasssyieoajengtrstaPaochreomontraeqalyfeqe,ticautqeultbaotestuullrestteyrin.rittnss Here!
-e eaAan
cchyot-ronM
aAbteesbacgesycorttrv-roaeadrrtef
StrOD
e,
e
F
atheleae alatego,ingarilogitglltbayhhm
w
n
d
t
al spo nges.
o
n
e
ea
a
b
t
E
c
r
ll
es
at
ulC
ofatesifgmraancbaaleoccpamcilteyxeitd.eyfeiefSo-ostc-r-rraetAtPc,otacrregnntoheoaecdwaahviyanhnantetetdpplegrainosrinreentbefowonsinbgsjebY
vioyhtst
ssejeittycitto.eoteudutetc_noht_at_______
encadrpsein
rdP
enF
yjeticdxehcleibrhetntletrscatlalusowindbst
rd
nge
eSin
o
le
einchpspteStA
e
it
n
le
t
a
e
t
d
a
a
,
ngs
c
e
t
je
n
ab
r
id
_rr_eit
t
p
a
e
b
o
st
if
c
o
je
_
c
e
f
o
h
d
e
f
b
in
ha
n
_
d
rdviitmt.clifeieienntrtdt_essest_aatwe_wnrefitd_it
eenealaahabedtancovielaorohrosssborje
perwseooro
otlaaoanbstorpssu
ld
inter
wDhrleeecnan
tcotlah_hrhuoo_sspede_cxehifs.letas,fetnnegsdaeaninndd ______
o
n
li
c
p
.
e
g
M
lyateerhctrfeiz
e
n
c
n
p
t
it
in
li
o
a
y
r
en
ss
l
o
o
ss
d
il
e
t
la
t
ir
c
w
en
s
c
c
e
iz
b
ss
c
a
t
m
t
ep
t
u
a
n
a
e
su
d
F
st
s,
c
q
e
r
t
inpeopncpfTadnif
t_h_e_____
varydaesp
rgebtojeel . oaqcueuuee oonrrtloialogt_gio_rrn_ee_qt_uoe_st
ltinestrecaahqaonrytetunainicetivmiaost
y
_
a
e
ll
u
a
st
q
s,
in
s,
s.
io
r
.
n
t
e
st
afuuatnocrmrtlacelaiossqssnuead.lietfyundooaabbleleoouoppneerdraatPioants._t_e_r__n_s _________
ortt undomp ______
subsusucplapppssoers. C
es two
tern combin tion that
at
P
d
un
po
solu
A Com
m.
terns into a
or more pat rring or general proble
cu
re
a
solves

ß Let Design Patterns emerge in

ß Design Patterns aren’t set in

Abstraction
n
Encapsulatio
m
Polymorphis
Inheritance

Encapsula
eritance.
ion over inh
t
si
po
m
co
Favor
not
interfaces,
Program to ions.
implementat
led designs
loosely coup
Strive for jects that interact.
between ob
tension
open for ex
e
b
ld
ou
sh
Classes for modification.
but closed
. Do not
abstractions
Depend on ncrete classes.
depend on co
ds.
o your frien
Only talk t
u.
, we’ll call yo
Don’t call us
o
one reason t
ld have only
ou
sh
s
as
cl
A
change.

BULLET POINTS

Check out the
Appendix, we’ll
give you a heads
up on some more
foundational
patterns you’ll
probably want to
have a look at.

Chapter 13
Download at WoweBook.Com

ß Study Design Pattern catalogs
to familiarize yourself with
patterns and the relationships
among them.

ß Pattern classifications (or
categories) provide groupings
for patterns. When they help,
use them.

ß You need to be committed to
be a patterns writer: it takes
time and patience, and you
have to be willing to do lots of
refinement.

ß Remember, most patterns you
encounter will be adaptations
of existing patterns, not new
patterns.

ß Build your team’s shared
vocabulary. This is one of the
most powerful benefits of using
patterns.

ß Like any community, the
patterns community has its
own lingo. Don’t let that hold
you back. Having read this
book, you now know most of it.

better living with patterns

Leaving Object ville...

Boy, it’s been great having you in Object ville.
We’re going to miss you, for sure. But don’t worry – before you know it, the
next Head First book will be out and you can visit again. What’s the next book,
you ask? Hmmm, good question! Why don’t you help us decide? Send email
to booksuggestions@wickedlysmart.com.

you are here 4
Download at WoweBook.Com

609

who does what? solution

Exercise solutions
Match each pattern with its description:

Pattern

Decorator
State
Iterator
Facade
Strategy
Proxy
Factory Method
Adapter
Observer
Template Method
Composite
Singleton
Abstract Factory
Command
610

Description

Wraps an object and provides a different
interface to it.
Subclasses decide how to implement steps in
an algorithm.
Subclasses decide which concrete classes to
create.
Ensures one and only object is created.
Encapsulates interchangeable behaviors and
uses delegation to decide which one to use.
Clients treat collections of objects and
individual objects uniformly.
Encapsulates state-based behaviors and uses
delegation to switch between behaviors.
Provides a way to traverse a collection of
objects without exposing its implementation.
Simpliﬁes the interface of a set of classes.
Wraps an object to provide new behavior.
Allows a client to create families of objects
without specifying their concrete classes.
Allows objects to be notiﬁed when state
changes.
Wraps an object to control access to it.
Encapsulates a request as an object.

Chapter 13
Download at WoweBook.Com

14

Appendix

Appendix: Leftover Patterns

Not everyone can be the most popular. A lot has changed in
the last 10 years. Since Design Patterns: Elements of Reusable Object-Oriented
Software ﬁrst came out, developers have applied these patterns thousands
of times. The patterns we summarize in this appendix are full-ﬂedged, cardcarrying, ofﬁcial GoF patterns, but aren’t always used as often as the patterns
we’ve explored so far. But these patterns are awesome in their own right, and
if your situation calls for them, you should apply them with your head held high.
Our goal in this appendix is to give you a high level idea of what these patterns
are all about.

this is the appendix
Download at WoweBook.Com

611

bridge pattern

Bridge
Use the Bridge Pattern to vary not only your
implementations, but also your abstractions.

could be
This is an abstraction. Itact
class.
an interface or an abstr

A scenario
Imagine you’re going to revolutionize “extreme
lounging.” You’re writing the code for a new
ergonomic and user-friendly remote control for
TVs. You already know that you’ve got to use
good OO techniques because while the remote is
based on the same abstraction, there will be lots of
implementations – one for each model of TV.

RemoteControl

Every remote has the
same abstraction.

on()
off()
setChannel()
// more methods

RCAControl

Lots of
implementations,
one for each TV.

SonyControl

on()

on()

off()

off()

setChannel()

setChannel()

// more methods

// more methods

{
tuneChannel(channel);

Your dilemma

}

You know that the remote’s user interface won’t be right the
ﬁrst time. In fact, you expect that the product will be reﬁned
many times as usability data is collected on the remote
control.
So your dilemma is that the remotes are going to change and
the TVs are going to change. You’ve already abstracted the user
interface so that you can vary the implementation over the many
TVs your customers will own. But you are also going to need
to vary the abstraction because it is going to change over time as
the remote is improved based on the user feedback.
So how are you going to create an OO design that allows you
to vary the implementation and the abstraction?

612

appendix
Download at WoweBook.Com

y
Using this design we can var
, not
ion
at
ent
lem
imp
only the TV
.
ace
erf
the user int

leftover patterns

Why use the Bridge Pattern?
The Bridge Pattern allows you to vary the implementation and
the abstraction by placing the two in separate class hierarchies.

Abstractiornchy.
class hiera

The relationship between
the two is referred to
as the “bridge.”

RemoteControl

Implementation class hierarc

hy.

Has-A

implementor

TV

on()

on()

off()

off()

setChannel()

tuneChannel()

implementor.tuneChannel(channel);

// more methods

// more methods

ConcreteRemote
currentStation

ion
All methods in the abstrsact
of
are implemented in term
the implementation.

on()
off()
setStation()

setChannel(currentStation + 1);

Sony

RCA
on()

on()

off()

off()

tuneChannel()

tuneChannel()

// more methods

// more methods

nextChannel()
previousChannel()

Concrete subclasses are implemented in terms of the
abstraction, not the implementation.

// more methods

Now you have two hierarchies, one for the remotes and a separate one for platform
speciﬁc TV implementations. The bridge allows you to vary either side of the two
hierarchies independently.

Bridge Uses and Drawbacks

Bridge Beneﬁts

ß Decouples an implementation so that it is not bound
ß
ß

permanently to an interface.
Abstraction and implementation can be extended
independently.
Changes to the concrete abstraction classes don’t
affect the client.

ß Useful in graphic and windowing systems that need to
ß
ß

run over multiple platforms.
Useful any time you need to vary an interface and an
implementation in different ways.
Increases complexity.

you are here 4
Download at WoweBook.Com

613

builder pattern

Builder
Use the Builder Pattern to encapsulate the construction of
a product and allow it to be constructed in steps.
A scenario
You’ve just been asked to build a vacation planner for Patternsland, a new theme
park just outside of Objectville. Park guests can choose a hotel and various types of
admission tickets, make restaurant reservations, and even book special events. To create
a vacation planner, you need to be able to create structures like this:

Each vacation is planned
over some number of days.

Vacation

D ay Tw o

Sp
ecial Ev

ter
ns on I

Ticke

t

Hotel

Sp
ecial Ev

irq
t
ue
Du P a

C

at

P

Dinner

Pa
rk

Dining

Dinner

combination
y
n
a
e
v
a
h
n
a
Each day c rvations, tickets,
of hotel reseecial events.
meals and sp
You need a ﬂexible design
Each guest’s planner can vary in the number of days and types of activities it includes.
For instance, a local resident might not need a hotel, but wants to make dinner and
special event reservations. Another guest might be ﬂying into Objectville and needs a
hotel, dinner reservations, and admission tickets.
So, you need a ﬂexible data structure that can represent guest planners and all their
variations; you also need to follow a sequence of potentially complex steps to create the
planner. How can you provide a way to create the complex structure without mixing it
with the steps for creating it?
614

appendix
Download at WoweBook.Com

ter
ns

t

t

Ticke

t

Pa
rk

en

Hotel

s

Dining

ce

t
Ticke

e
Da
yThre

en

Pa
rk

s

Hotel

s

D ay O n e

leftover patterns

Why use the Builder Pattern?
Remember Iterator? We encapsulated the iteration into a separate
object and hid the internal representation of the collection from the
client. It’s the same idea here: we encapsulate the creation of the
trip planner in an object (let’s call it a builder), and have our client
ask the builder to construct the trip planner structure for it.

The Client
directs the
builder to
construct the
planner.

Client

builder

AbstractBuilder
buildDay()
addHotel()
addReservation()
addSpecialEvent()
addTickets()
getVacationPlanner()

constructPlanner()

builder.buildDay(date);
builder.addHotel(date, “Grand Facadian”);
builder.addTickets(“Patterns on Ice”);
// plan rest of vacation

VacationBuilder
vacation

Planner yourPlanner =
builder.getVacationPlanner();

Builder Uses and Drawbacks

Builder Beneﬁts

ß Encapsulates the way a complex object is

ß
ß

The concrete builducerts
creates real prod
and stores them
in the vacation e.
composite structur

buildDay()
addHotel()
addReservation()
addSpecialEvent()
addTickets()
getVacationPlanner()

the builder to create
The Client directs mb
er of steps and
the planner in a nu acationPlanner()
then calls the getVe the complete object.
method to retriev

ß

The client uses an
abstract interface to
build the planner.

constructed.
Allows objects to be constructed in a multistep and
varying process (as opposed to one step factories).
Hides the internal representation of the product from
the client.
Product implementations can be swapped in and out
because the client only sees an abstract interface.

ß Often used for building composite structures.
ß Constructing objects requires more domain
knowledge of the client than when using a Factory.

you are here 4
Download at WoweBook.Com

615

chain of responsibility pattern

Chain of Responsibility
Use the Chain of Responsibility Pattern when you want to
give more than one object a chance to handle a request.
A scenario
Mighty Gumball has been getting more email
than they can handle since the release of the
Java-powered Gumball Machine. From their
own analysis they get four kinds of email: fan
mail from customers that love the new 1 in 10
game, complaints from parents whose kids
are addicted to the game and requests to put
machines in new locations. They also get a fair
amount of spam.
All fan mail needs to go straight to the CEO,
all complaints go to the legal department and
all requests for new machines go to business
development. Spam needs to be deleted.

Your task
Mighty Gumball has already written some AI
detectors that can tell if an email is spam, fan
mail, a complaint, or a request, but they need you
to create a design that can use the detectors to
handle incoming email.

616

You’ve
got to help us
deal with the ﬂood
of email we’re getting
since the release of
the Java Gumball
Machine.

appendix
Download at WoweBook.Com

leftover patterns

How to use the Chain of Responsibility Pattern
With the Chain of Responsibility Pattern, you create a chain of objects
that examine a request. Each object in turn examines the request and
handles it, or passes it on to the next object in the chain.

Handler
successor

ain
Each object in theanchd has
acts as a handler . If it
a successor objectquest,
can handle the re , it
it does; otherwise est to
forwards the requ
its successor.

handleRequest()

SpamHandler

FanHandler

ComplaintHandler

NewLocHandler

handleRequest()

handleRequest()

handleRequest()

handleRequest()

As email is received, it is passed to the ﬁrst handler: the
SpamHandler. If the SpamHandler can’t handle the request,
it is passed on to the FanHandler. And so on...

Email is not handled if it
falls off the end of the chain
- although, you can always
implement a catch-all handler.

Each email is passed to
the first handler.
Spam
Handler

Fan
Handler

ß Decouples the sender of the request and its

ß

NewLoc
Handler

Chain of Responsibility Uses and Drawbacks

Chain of Responsibility Beneﬁts

ß

Complaint
Handler

receivers.
Simplifies your object because it doesn’t have to
know the chain’s structure and keep direct references
to its members.
Allows you to add or remove responsibilities
dynamically by changing the members or order of the
chain.

ß Commonly used in windows systems to handle
ß
ß

events like mouse clicks and keyboard events.
Execution of the request isn’t guaranteed; it may fall
off the end of the chain if no object handles it (this can
be an advantage or a disadvantage).
Can be hard to observe the runtime characteristics
and debug.

you are here 4
Download at WoweBook.Com

617

ﬂyweight pattern

Flyweight
Use the Flyweight Pattern when one instance of a class
can be used to provide many “virtual instances.”
A scenario
You want to add trees as objects in your hot new landscape design application. In
your application, trees don’t really do very much; they have an X-Y location, and they
can draw themselves dynamically, depending on how old they are. The thing is, a user
might want to have lots and lots of trees in one of their home landscape designs. It
might look something like this:

Tree
Tree

Tree
Tree

Each Tree
instance
maintains it
s own state
.

Tree

Tree

Tree

House
Tree

xCoord
yCoord
age
display() {
// use X-Y coords
// & complex age
// related calcs
}

Your big clientʼs dilemma
You’ve just landed your “reference account.” That key client
you’ve been pitching for months. They’re going to buy 1,000
seats of your application, and they’re using your software
to do the landscape design for huge planned communities.
After using your software for a week, your client is
complaining that when they create large groves of trees, the
app starts getting sluggish...
618

appendix
Download at WoweBook.Com

leftover patterns

Why use the Flyweight Pattern?
What if, instead of having thousands of Tree objects, you
could redesign your system so that you’ve got only one
instance of Tree, and a client object that maintains the state
of ALL your trees? That’s the Flyweight!

All the state, for ALL
of your virtual Tree
objects, is stored in
this 2D-array.

One, single
Tree objec, state-free
t.
TreeManager
treeArray

Tree

displayTrees() {
// for all trees {
// get array row
display(x, y, age);
}
}

display(x, y, age) {
// use X-Y coords
// & complex age
// related calcs
}

Flyweight Uses and Drawbacks

Flyweight Beneﬁts

ß Reduces the number of object instances at runtime,
ß

saving memory.
Centralizes state for many “virtual” objects into a
single location.

ß The Flyweight is used when a class has many
ß

instances, and they can all be controlled identically.
A drawback of the Flyweight pattern is that once
you’ve implemented it, single, logical instances of the
class will not be able to behave independently from
the other instances.

you are here 4
Download at WoweBook.Com

619

interpreter pattern

Interpreter
Use the Interpreter Pattern to build an
interpreter for a language.
A scenario
Remember the Duck Pond Simulator? You have a hunch it
would also make a great educational tool for children to learn
programming. Using the simulator, each child gets to control one
duck with a simple language. Here’s an example of the language:

requires
ter Pattern mmars.
re
rp
te
In
ra
Th e
f formal g
wledge o
al
rm
fo
some k no
d
ie
h
ever stud
ad throug
If you’ve n
ad and re
e
.
h
it
a
f
o
o
t
g
,
is
t the g
grammars
u’ll still ge
o
y
;
rn
e
tt
the pa

k right.

Turn the duc
right;
while (daylight) ﬂy;
quack;

Fly all day...
...and then quack.

Now, remembering how to create grammars from one of your old
introductory programming classes, you write out the grammar:

g
ssion consistin
e
r
p
x
e
n
a
is
A program es of commands and
of sequenc (“while” statements).
repetitions
A sequence is a
set of expressions
expression ::= <command> | <sequence> | <repetition>
separated by
sequence ::= <expression> ‘;’ <expression>
semicolons.
command ::= right | quack | ﬂy
repetition ::= while ‘(‘ <variable> ‘)’<expresion>
We have three
variable ::= [A-Z,a-z]+
commands: right,
quack, and fly.
A while statement
a conditional variablise just
and an expression.

Now what?
You’ve got a grammar; now all you need is a way to represent and
interpret sentences in the grammar so that the students can see the
effects of their programming on the simulated ducks.

620

appendix
Download at WoweBook.Com

leftover patterns

How to implement an interpreter
When you need to implement a simple language, the
Interpreter Pattern deﬁnes a class-based representation for its
grammar along with an interpreter to interpret its sentences.
To represent the language, you use a class to represent each
rule in the language. Here’s the duck language translated
into classes. Notice the direct mapping to the grammar.
Expression

interpret(context)

Sequence
expression1
expression2
interpret(context)

Repetition
variable
expression
interpret(context)

Variable

interpret(context)

QuackCommand

RightCommand

interpret(context)

interpret(context)

FlyCommand

interpret(context)

To interpret the language, call the interpret() method on each
expression type. This method is passed a context – which
contains the input stream of the program we’re parsing – and
matches the input and evaluates it.

Interpreter Uses and Drawbacks

Interpreter Beneﬁts

ß Representing each grammar rule in a class makes
ß
ß

the language easy to implement.
Because the grammar is represented by classes, you
can easily change or extend the language.
By adding additional methods to the class structure,
you can add new behaviors beyond interpretation,
like pretty printing and more sophisticated program
validation.

ß Use interpreter when you need to implement a
ß
ß
ß

simple language.
Appropriate when you have a simple grammar and
simplicity is more important than efficiency.
Used for scripting and programming languages.
This pattern can become cumbersome when the
number of grammar rules is large. In these cases a
parser/compiler generator may be more appropriate.

you are here 4
Download at WoweBook.Com

621

mediator pattern

Mediator
Use the Mediator Pattern to centralize complex
communications and control between related objects.
A scenario
Bob has a Java-enabled auto-house, thanks to the good folks at HouseOfTheFuture.
All of his appliances are designed to make his life easier. When Bob stops hitting the
snooze button, his alarm clock tells the coffee maker to start brewing. Even though
life is good for Bob, he and other clients are always asking for lots of new features:
No coffee on the weekends... Turn off the sprinkler 15 minutes before a shower is
scheduled... Set the alarm early on trash days...

Alarm

CoffeePot

Alarm

onEvent() {
checkCalendar()
checkSprinkler()
startCoffee()
// do more stuff
}

Calendar

CoffeePot

Calendar

Sprinkler

onEvent() {
checkDayOfWeek()
doSprinkler()
doCoffee()
doAlarm()
// do more stuff
}

Sprinkler
onEvent() {
checkCalendar()
checkShower()
checkTemp()
checkWeather()
// do more stuff
}

HouseOfTheFutureʼs dilemma
It’s getting really hard to keep track of which rules reside in which objects, and how
the various objects should relate to each other.
622

onEvent() {
checkCalendar()
checkAlarm()
// do more stuff
}

appendix
Download at WoweBook.Com

leftover patterns

Mediator in action...

It’s such a
relief, not having to
ﬁgure out that Alarm
clock’s picky rules!

With a Mediator added to the system, all
of the appliance objects can be greatly
simpliﬁed:

ß They tell the Mediator when their state
changes.

ß They respond to requests from the

CoffeePot

Alarm

Mediator.
Before adding the Mediator, all of the
appliance objects needed to know about each
other... they were all tightly coupled. With the
Mediator in place, the appliance objects are
all completely decoupled from each other.

Mediator

Mediator

The Mediator contains all of the control
logic for the entire system. When an existing
appliance needs a new rule, or a new
appliance is added to the system, you’ll know
that all of the necessary logic will be added to
the Mediator.

Calendar

Mediator Uses and Drawbacks

Mediator Beneﬁts

ß Increases the reusability of the objects supported by
ß
ß

Sprinkler

if(alarmEvent){
checkCalendar()
checkShower()
checkTemp()
}
if(weekend) {
checkWeather()
// do more stuff
}
if(trashDay) {
resetAlarm()
// do more stuff
}

the Mediator by decoupling them from the system.
Simplifies maintenance of the system by centralizing
control logic.
Simplifies and reduces the variety of messages sent
between objects in the system.

ß The Mediator is commonly used to coordinate related
ß

GUI components.
A drawback of the Mediator pattern is that without
proper design, the Mediator object itself can become
overly complex.

you are here 4
Download at WoweBook.Com

623

memento pattern

Memento
Use the Memento Pattern when you need
to be able to return an object to one of its
previous states; for instance, if your user
requests an “undo.”
A scenario
Your interactive role playing game is hugely successful,
and has created a legion of addicts, all trying to get
to the fabled “level 13.” As users progress to more
challenging game levels, the odds of encountering
a game-ending situation increase. Fans who have
spent days progressing to an advanced level are
understandably miffed when their character gets snuffed,
and they have to start all over. The cry goes out for a
“save progress” command, so that players can store their
game progress and at least recover most of their efforts
when their character is unfairly extinguished. The
“save progress” function needs to be designed to return
a resurrected player to the last level she completed
successfully.

624

appendix
Download at WoweBook.Com

Just be careful how you go about
saving the game state. It’s pretty
complicated, and I don’t want anyone
else with access to it mucking it up and
breaking my code.

leftover patterns

The Memento at work
The Memento has two goals:

ß Saving the important state of a system’s key object.
ß Maintaining the key object’s encapsulation.
Keeping the single responsibility principle in mind, it’s also
a good idea to keep the state that you’re saving separate
from the key object. This separate object that holds the
state is known as the Memento object.

While this isn’t a terribly
fancy implementation,
notice that the Client
has no access to the
Memento’s data.

GameMemento
savedGameState

Client

MasterGameObject

// when new level is reached
Object saved =
(Object) mgo.getCurrentState();

gameState

// when a restore is required
mgo.restoreState(saved);

restoreState(Object savedState) {
// restore state
}
// do other game stuff

Memento Uses and Drawbacks

Memento Beneﬁts

ß Keeping the saved state external from the key object
ß
ß

Object getCurrentState() {
// gather state
return(gameState);
}

helps to maintain cohesion.
Keeps the key object’s data encapsulated.
Provides easy-to-implement recovery capability.

ß The Memento is used to save state.
ß A drawback to using Memento is that saving and
ß

restoring state can be time consuming.
In Java systems, consider using Serialization to save
a system’s state.

you are here 4
Download at WoweBook.Com

625

prototype pattern

Prototype
Use the Prototype Pattern when creating an
instance of a given class is either expensive or
complicated.
A scenario
Your interactive role playing game has an insatiable appetite for monsters. As your
heros make their journey through a dynamically created landscape, they encounter
an endless chain of foes that must be subdued. You’d like the monster’s characteristics
to evolve with the changing landscape. It doesn’t make a lot of sense for bird-like
monsters to follow your characters into underseas realms. Finally, you’d like to allow
advanced players to create their own custom monsters.

It would be a lot cleaner if we
could decouple the code that handles
the details of creating the monsters
from the code that actually needs to
create the instances on the ﬂy.

626

Yikes! Just the act
of creating all of these different
kinds of monster instances is getting
tricky... Putting all sorts of state detail in the
constructors doesn’t seem to be very cohesive. It
would be great if there was a single place where
all of the instantiation details could be
encapsulated...

appendix
Download at WoweBook.Com

leftover patterns

Prototype to the rescue
The Prototype Pattern allows you to make new instances by
copying existing instances. (In Java this typically means using
the clone() method, or de-serialization when you need deep
copies.) A key aspect of this pattern is that the client code can
make new instances without knowing which speciﬁc class is
being instantiated.

<<interface>>
Monster

WellKnownMonster

MonsterMaker

DynamicPlayerGeneratedMonster

er
The client needs a new monst
t
ren
appropriate to the cur n’t know
situation. (The client wo gets.)
what kind of monster he

makeRandomMonster() {
Monster m =
MonsterRegistry.getMonster();
}

MonsterRegistry
Monster getMonster() {
// ﬁnd the correct monster
return correctMonster.clone();
}

The registry finds th
appropriate monster, e
clone of it, and retu makes a
rns the clone.

Prototype Uses and Drawbacks

Prototype Beneﬁts

ß Hides the complexities of making new instances from
ß
ß

the client.
Provides the option for the client to generate objects
whose type is not known.
In some circumstances, copying an object can be
more efficient than creating a new object.

ß Prototype should be considered when a system must
ß

create new objects of many types in a complex class
hierarchy.
A drawback to using the Prototype is that making a
copy of an object can sometimes be complicated.

you are here 4
Download at WoweBook.Com

627

visitor pattern

Visitor
Use the Visitor Pattern when you want to
add capabilities to a composite of objects
and encapsulation is not important.
A scenario
Customers who frequent the Objectville Diner and Objectville
Pancake House have recently become more health conscious. They
are asking for nutritional information before ordering their meals.
Because both establishments are so willing to create special orders,
some customers are even asking for nutritional information on a
per ingredient basis.
Menu

Louʼs proposed solution:

// new methods
getHealthRating
getCalories
getProtein
getCarbs

MenuItem

MenuItem

// new methods
getHealthRating
getCalories
getProtein
getCarbs

Ingredient

Melʼs concerns...
“Boy, it seems like we’re opening Pandora’s box. Who knows what
new method we’re going to have to add next, and every time we
add a new method we have to do it in two places. Plus, what if
we want to enhance the base application with, say, a recipes class?
Then we’ll have to make these changes in three different places...”

628

appendix
Download at WoweBook.Com

Ingredient

leftover patterns

The Visitor drops by
The Visitor must visit each element of the Composite; that
functionality is in a Traverser object. The Visitor is guided by the
Traverser to gather state from all of the objects in the Composite.
Once state has been gathered, the Client can have the Visitor perform
various operations on the state. When new functionality is required,
only the Visitor must be enhanced.

The Client asks
the Visitor to get
information from the
Composite structure...
New methods can be
added to the Visitor
without affecting the
Composite.

g()
tin
a
R )
lth
ea ries(
H
t
ge tCalo ein()
ge tProt bs()
ge tCar
ge

All these composite
classes have to do is add
a getState() method
le to call (and not worry about
The Visitor needs to be s,aband
this is
getState() across classe thods for exposing themselves).
where you can add new me
the client to use.

getState()
getS
tate
()
ge
tS
tat
MenuItem
e(
)

Visitor

MenuItem

e()
tat
tS
ge

Client /
Traverser

The Traverser knows how to
guide the Visitor through.
the Composite structure

Ingredient

Ingredient

Visitor Drawbacks

Visitor Beneﬁts

ß Allows you to add operations to a Composite
ß
ß

Menu

te()
getSta

structure without changing the structure itself.
Adding new operations is relatively easy.
The code for operations performed by the Visitor is
centralized.

ß The Composite classes’ encapsulation is broken
ß

when the Visitor is used.
Because the traversal function is involved, changes to
the Composite structure are more difficult.

you are here 4
Download at WoweBook.Com

629

Download at WoweBook.Com

g

h

Index

A
Abstract Factory Pattern 156. See also Factory Pattern

g
business process patterns 605

advantages 242

C

class adapters 244

CD Cover Viewer 463

class diagram 243

Chain of Responsibility Pattern 616–617

combining patterns 504

change 339

Adapter Pattern

deﬁned 243

anticipating 14

duck magnets 245

constant in software development 8

Enumeration Iterator Adapter 248

identifying 53

exercise 251

Choc-O-Holic, Inc. 175

explained 241

class explosion 81

ﬁreside chat 247, 252–253

code magnets 69, 179, 245, 350

introduction 237

cohesion 339–340

object adapters 244

Combining Patterns 500

Alexander, Christopher 602

Abstract Factory Pattern 508

annihilating evil 606

Adapter Pattern 504

Anti-Patterns 606–607

class diagram 524

Golden Hammer 607

Composite Pattern 513

application patterns 604

Decorator Pattern 506

architectural patterns 604

Observer Pattern 516
Command Pattern

B

class diagram 207
command object 203

Bridge Pattern 612–613

deﬁned 206–207

Builder Pattern 614–615
bullet points 32, 74, 105, 162, 186, 230, 270, 311, 380,
423, 491, 560, 608

introduction 196
loading the Invoker 201
this is the index

Download at WoweBook.Com

631

D-G

Command Pattern, continued

ﬁreside chat 252–253

logging requests 229

interview 104

macro command 224

introduction 88

Null Object 214

in Java I/O 100–101

queuing requests 228

structural pattern 591

undo 216, 220, 227

Dependency Inversion Principle 139–143
and the Hollywood Principle 298

Composite Pattern

Design Patterns

and Iterator Pattern 368
class diagram 358

Abstract Factory Pattern 156

combining patterns 513

Adapter Pattern 243

composite behavior 363

beneﬁts 599

default behavior 360

Bridge Pattern 612–613

deﬁned 356

Builder Pattern 614–615

interview 376–377

categories 589, 592–593

safety 367

Chain of Responsibility Pattern 616–617

safety versus transparency 515

class patterns 591

transparency 367, 375

Command Pattern 206

composition 23, 85, 93, 247, 309

Composite Pattern 356

compound pattern 500, 522

Decorator Pattern 91

controlling access 460. See also Proxy Pattern

deﬁned 579, 581

creating objects 134

discover your own 586–587

crossword puzzle 33, 76, 163, 187, 231, 271, 310, 378,
490

Facade Pattern 264

cubicle conversation 55, 93, 195, 208, 387, 397, 433,
583–584

Flyweight Pattern 618–619

D

Factory Method Pattern 134
Interpreter Pattern 620–621
Iterator Pattern 336
Mediator Pattern 622–623

Decorator Pattern

Memento Pattern 624–625

and Proxy Pattern 472–473

Null Object 214

class diagram 91

object patterns 591

combining patterns 506

Observer Pattern 51

cubicle conversation 93

organizing 589

deﬁned 91

Prototype Pattern 626–627

disadvantages 101, 104

Proxy Pattern 460

632

index
Download at WoweBook.Com

the index
Simple Factory 114

deﬁned 264

Singleton Pattern 177

introduction 258

State Pattern 410

Factory Method Pattern 134. See also Factory Pattern

Strategy Pattern 24

Factory Pattern

Template Method Pattern 289

Abstract Factory

use 29

and Factory Method 158–159, 160–161

versus frameworks 29

class diagram 156–157

versus libraries 29

combining patterns 508

Visitor Pattern 628–629

deﬁned 156

Design Principles. See Object Oriented Design Principles

interview 158–159

Design Puzzle 25, 133, 279, 395, 468, 542

introduction 153

Design Toolbox 32, 74, 105, 162, 186, 230, 270, 311,
380, 423, 491, 560, 608
DJ View 534

Factory Method
advantages 135
and Abstract Factory 160–161

domain speciﬁc patterns 604

class diagram 134

E

interview 158–159

Elvis 526

introduction 120, 131–132

deﬁned 134

encapsulate what varies 8–9, 75, 136, 397, 612
encapsulating algorithms 286, 289
encapsulating behavior 11
encapsulating iteration 323
encapsulating method invocation 206
encapsulating object construction 614–615
encapsulating object creation 114, 136
encapsulating requests 206

up close 125
Simple Factory
deﬁned 117
introduction 114
family of algorithms. See Strategy Pattern
family of products 145
favor composition over inheritance 23, 75
ﬁreside chat 62, 247, 252, 308, 418, 472–473

encapsulating state 399

Five minute drama 48, 478

F

forces 582

Facade Pattern
advantages 260
and Principle of Least Knowledge 269
class diagram 264

Flyweight Pattern 618–619
Friedman, Dan 171

G
Gamma, Erich 601
you are here 4
Download at WoweBook.Com

633

H-P

Gang of Four 583, 601

and collections 347–349

Gamma, Erich 601

and Composite Pattern 368

Helm, Richard 601

and Enumeration 338

Johnson, Ralph 601

and Hashtable 343, 348

Vlissides, John 601

class diagram 337

global access point 177

code magnets 350

gobble gobble 239

deﬁned 336

Golden Hammer 607

exercise 327

guide to better living with Design Patterns 578

external iterator 338

Gumball Machine Monitor 431

for/in 349

H

internal iterator 338
introduction 325
java.util.Iterator 332

HAS-A 23

Null Iterator 372

Head First learning principles xxx

polymorphic iteration 338

Helm, Richard 601

removing objects 332

Hillside Group 603
Hollywood Principle, The 296
and the Dependency Inversion Principle 298

J

Home Automation or Bust, Inc. 192

Johnson, Ralph 601

Home Sweet Home Theater 255

K

Hot or Not 475

I

KISS 594

inheritance
disadvantages 5
for reuse 5–6
versus composition 93
interface 12

L
Law of Demeter. See Principle of Least Knowledge
lazy instantiation 177
loose coupling 53

inversion 141–142

M

IS-A 23

magic bullet 594

Iterator Pattern

master and student 23, 30, 85, 136, 592, 596

Interpreter Pattern 620–621

advantages 330
634

Matchmaking in Objectville 475

index
Download at WoweBook.Com

the index
Mediator Pattern 622–623

Principle of Least Knowledge 265

Memento Pattern 624–625

program to an interface, not an implementation 11,
243, 335

middleman 237

strive for loosely coupled designs between objects that
interact 53

Mighty Gumball, Inc. 386
Model-View-Controller

Observable 64, 71

Adapter Pattern 546

Observer Pattern

and design patterns 532

class diagram 52

and the Web 549

code magnets 69

Composite Pattern 532, 559

combining patterns 516

introduction 529

cubicle conversation 55

Mediator Pattern 559

deﬁned 51–52

Observer Pattern 532

ﬁreside chat 62

ready-bake code 564–576

Five minute drama 48

song 526

introduction 44

Strategy Pattern 532, 545

in Swing 72–73

up close 530
Model 2 549. See also Model-View-Controller
and design patterns 557–558

Java support 64
pull 63
push 63

MVC. See Model-View-Controller

one-to-many relationship 51–52

N

OOPSLA 603

Null Object 214, 372

oreo cookie 526

O

organizational patterns 605

Open-Closed Principle 86–87

Objectville Diner 26, 197, 316, 628

P

Objectville Pancake House 316, 628

part-whole hierarchy 356. See also Composite Pattern

Object Oriented Design Principles 9, 30–31

patterns catalog 581, 583, 585

Dependency Inversion Principle 139–143

Patterns Exposed 104, 158, 174, 377–378

encapsulate what varies 9, 111

patterns in the wild 299, 488–489

favor composition over inheritance 23, 243, 397

patterns zoo 604

Hollywood Principle 296

Pattern Honorable Mention 117, 214

one class, one responsibility 185, 336, 339, 367

Pizza shop 112

Open-Closed Principle 86–87, 407

Portland Patterns Repository 603
you are here 4
Download at WoweBook.Com

635

Q-Y

Principle of Least Knowledge 265–268

Remote Method Invocation. See RMI

disadvantages 267

remote proxy 434. See also Proxy Pattern

program to an implementation 12, 17, 71

reuse 13, 23, 85

program to an interface 12

RMI 436

program to an interface, not an implementation 11, 75
Prototype Pattern 626–627
Proxy Pattern
and Adapter Pattern 471
and Decorator Pattern 471, 472–473

S
shared vocabulary 26–28, 599–600

class diagram 461

sharpen your pencil 5, 42, 54, 61, 94, 97, 99, 124, 137,
148, 176, 183, 205, 225, 242, 268, 284, 322, 342,
396, 400, 406, 409, 421, 483, 511, 518, 520, 589

deﬁned 460

Simple Factory 117

Dynamic Proxy 474, 479, 486

SimUDuck 2, 500

Caching Proxy 471

and RMI 486

Singleton Pattern

exercise 482

advantages 170, 184

ﬁreside chat 472–473

and garbage collection 184

java.lang.reﬂect.Proxy 474

and global variables 185

Protection Proxy 474, 477

and multithreading 180–182

Proxy Zoo 488–489

class diagram 177

ready-bake code 494

deﬁned 177

Remote Proxy 434

disadvantages 184

variants 471

double-checked locking 182

Virtual Proxy 462

interview 174

image proxy 464
publisher/subscriber 45

Q

up close 173
Single Responsibility Principle 339. See also Object
Oriented Design Principles: one class, one responsibility
skeleton 440

Quality, The. See Quality without a name

Starbuzz Coffee 80, 276

Quality without a name. See Quality, The

state machines 388–389

R

State Pattern
and Strategy Pattern 411, 418–419

refactoring 354, 595
remote control 193, 209
636

class diagram 410
deﬁned 410

index
Download at WoweBook.Com

the index
disadvantages 412, 417
introduction 398
sharing state 412
static factory 115
Strategy Pattern 24
and State Pattern 411, 418–419

V
varies. See encapsulate what varies
Visitor Pattern 628–629
Vlissides, John 601

encapsulating behavior 22

W

family of algorithms 22

Weather-O-Rama 38

ﬁreside chat 308

when not to use patterns 596–598

and Template Method Pattern 308–309

stub 440

Who Does What? 202, 254, 298, 379, 422, 487, 588

T

Why a duck? 500

Template Method Pattern

wrapping objects 88, 242, 252, 260, 473, 508. See
also Adapter Pattern, Decorator Pattern, Facade
Pattern, Proxy Pattern

advantages 288
and Applet 307
and java.util.Arrays 300
and Strategy Pattern 305, 308–309

Y

your mind on patterns 597

and Swing 306
and the Hollywood Principle 297
class diagram 289
deﬁned 289
ﬁreside chat 308–309
hook 292, 295
introduction 286
up close 290–291
The Little Lisper 171
thinking in patterns 594–595
tightly coupled 53

U
undo 216, 227
user interface design patterns 605
you are here 4
Download at WoweBook.Com

637

h

g

Colophon

g

All interior layouts were designed by Eric Freeman, Elisabeth Freeman,
Kathy Sierra and Bert Bates. Kathy and Bert created the look & feel of the Head First series.
The book was produced using Adobe InDesign CS (an unbelievably cool design tool that we can’t get
enough of) and Adobe Photoshop CS. The book was typeset using Uncle Stinky, Mister Frisky (you think
we’re kidding), Ann Satellite, Baskerville, Comic Sans, Myriad Pro, Skippy Sharp, Savoye LET, Jokerman
LET, Courier New and Woodrow typefaces.
Interior design and production all happened exclusively on Apple Macintoshes–at Head First we’re all
about “Think Different” (even if it isn’t grammatical). All Java code was created using James Gosling’s
favorite IDE, vi, although we really should try Erich Gamma’s Eclipse.
Long days of writing were powered by the caffeine fuel of Honest Tea and Tejava, the clean Santa Fe air,
and the grooving sounds of Banco de Gaia, Cocteau Twins, Buddha Bar I-VI, Delerium, Enigma, Mike
Oldﬁeld, Olive, Orb, Orbital, LTJ Bukem, Massive Attack, Steve Roach, Sasha and Digweed, Thievery
Corporation, Zero 7 and Neil Finn (in all his incarnations) along with a heck of a lot of acid trance and
more 80s music that you’d care to know about.

638

index
Download at WoweBook.Com

the index

And now, a ﬁnal word from Head First Labs...
Our world class researchers are working day and night in a mad race to
uncover the mysteries of Life, the Universe and Everything–before it’s too late.
Never before has a research team with such noble and daunting goals been
assembled. Currently, we are focusing our collective energy and brain power on
creating the ultimate learning machine. Once perfected, you and others will join
us in our quest!
You’re fortunate to be holding one of our ﬁrst protoypes in your hands. But only
through constant reﬁnement can our goal be achieved. We ask you, a pioneer
user of the technology, to send us periodic ﬁeld reports of your progress, at
ﬁeldreports@headﬁrstlabs.com
And next time you’re in Objectville,
drop by and take one of our behind
the scenes laboratory tours.

you are here 4
Download at WoweBook.Com

639

Now that you’ve applied the Head First approach to
Design Patterns, why not apply it to the rest of your life?
Come join us at the Head First Labs Web site, our virtual
hangout where you’ll ﬁnd Head First resources including
podcasts, forums, code and more.
But you won’t just be a spectator; we also encourage you to
join the fun by participating in discussions and brainstorming.

Whatʼs in it for you?

ß Get the latest news about what’s
happening in the Head First World.

ß Participate in our upcoming books and
technologies.

ß Learn how to tackle those tough
technical topics (say that three times fast)
in as little time as possible.

ß Look behind the scenes at how Head
First books are created.

ß Meet the Head First authors and the
support team who keep everything
running smoothly.

ß Why not audition to be a Head First
author yourself ?

t?
wai ers
y
h
rv
W
b se g by.
e
w
Our standin !
are sit now
Vi

http://www.headﬁrstlabs.com

Download at WoweBook.Com

Sig
n

Better than
e-books
Search
inside electronic versions
of thousands of books

Browse
books by category.
With Safari researching
any topic is a snap

Find
answers in an instant

Read books from cover
to cover. Or, simply click
to the page you need.

Search Safari! The premier electronic reference
library for programmers and IT professionals

Download at WoweBook.Com

up

FR Try it
EE
!

to
da
ya
n
sa d g
fa et
ri.
or your
eil
ly. firs
co t 1
m
4

da
ys
fre
e.

Related Titles Available from O’Reilly
Java
Ant: The Definitive Guide
Better, Faster, Lighter Java
Eclipse
Eclipse Cookbook
Enterprise JavaBeans,
4th Edition
Hardcore Java
Head First Java
Head First Servlets & JSP
Head First EJB
Hibernate:
A Developer’s Notebook
J2EE Design Patterns
Java 1.5 Tiger:
A Developer’s Notebook
Java & XML Data Binding
Java & XML
Java Cookbook, 2nd Edition
Java Data Objects
Java Database Best Practices
Java Enterprise Best Practices
Java Enterprise in a Nutshell,
2nd Edition
Java Examples in a Nutshell,
3rd Edition

Java Extreme Programming
Cookbook
Java in a Nutshell, 4th Edition
Java Management Extensions
Java Message Service
Java Network Programming,
2nd Edition
Java NIO
Java Performance Tuning,
2nd Edition
Java RMI
Java Security, 2nd Edition
JavaServer Faces
Java ServerPages, 2nd Edition
Java Servlet & JSP Cookbook
Java Servlet Programming,
2nd Edition
Java Swing, 2nd Edition
Java Web Services in a Nutshell
Learning Java, 2nd Edition
Mac OS X for Java Geeks
Programming Jakarta Struts
2nd Edition
Tomcat: The Definitive Guide
WebLogic:
The Definitive Guide

Our books are available at most retail and online bookstores.
To order direct: 1-800-998-9938 • order@oreilly.com • www.oreilly.com
Online editions of most O’Reilly titles are available by subscription at safari.oreilly.com

Download at WoweBook.Com

Keep in touch with O’Reilly
1. Download examples from our books
To find example files for a book, go to:
www.oreilly.com/catalog
select the book, and follow the “Examples” link.

2. Register your O’Reilly books
Register your book at register.oreilly.com
Why register your books?
Once you’ve registered your O’Reilly books you can:

6. Contact us
O’Reilly & Associates
1005 Gravenstein Hwy North
Sebastopol, CA 95472 USA
TEL: 707-827-7000 or 800-998-9938
(6am to 5pm PST)
FAX: 707-829-0104
order@oreilly.com
For answers to problems regarding your order or our
products. To place a book order online, visit:

•

Win O’Reilly books, T-shirts or discount
coupons in our monthly drawing.

www.oreilly.com/order_new

•

Get special offers available only to registered
O’Reilly customers.

catalog@oreilly.com
To request a copy of our latest catalog.

•

Get catalogs announcing new books
(US and UK only).

booktech@oreilly.com
For book content technical questions or corrections.

•

Get email notification of new editions of the
O’Reilly books you own.

corporate@oreilly.com
For educational, library, government, and
corporate sales.

3. Join our email lists
Sign up to get topic-specific email announcements
of new books and conferences, special offers, and
O’Reilly Network technology newsletters at:
elists.oreilly.com
It’s easy to customize your free elists subscription so
you’ll get exactly the O’Reilly news you want.

proposals@oreilly.com
To submit new book proposals to our editors and
product managers.
international@oreilly.com
For information about our international distributors
or translation queries. For a list of our distributors
outside of North America check out:
international.oreilly.com/distributors.html

4. Get the latest news, tips, and tools
•

“Top 100 Sites on the Web”—PC Magazine

adoption@oreilly.com
For information about academic use of O’Reilly
books, visit:

•

CIO Magazine’s Web Business 50 Awards

academic.oreilly.com

www.oreilly.com

Our web site contains a library of comprehensive
product information (including book excerpts and
tables of contents), downloadable software, background articles, interviews with technology leaders,
links to relevant sites, book cover art, and more.

5. Work for O’Reilly
Check out our web site for current employment
opportunities:
jobs.oreilly.com

Our books are available at most retail and online bookstores.
To order direct: 1-800-998-9938 • order@oreilly.com • www.oreilly.com
Online editions of most O’Reilly titles are available by subscription at safari.oreilly.com

Download at WoweBook.Com

